<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>linux常用基本命令</title>
      <link href="/blog/other/20200803003/"/>
      <url>/blog/other/20200803003/</url>
      
        <content type="html"><![CDATA[<p>Linux中许多常用命令是必须掌握的，这里将我学linux入门时学的一些常用的基本命令分享给大家一下，希望可以帮助你们。</p><p>这个是我将鸟哥书上的进行了一下整理的，希望不要涉及到版权问题。</p><h1 id="1、显示日期的指令：-date"><a href="#1、显示日期的指令：-date" class="headerlink" title="1、显示日期的指令： date"></a>1、显示日期的指令： date</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363935954_6311.png"></p><h1 id="2、显示日历的指令：cal"><a href="#2、显示日历的指令：cal" class="headerlink" title="2、显示日历的指令：cal"></a>2、显示日历的指令：cal</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363935980_1369.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363935990_8670.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363935996_9522.png"></p><h1 id="3、简单好用的计算器：bc"><a href="#3、简单好用的计算器：bc" class="headerlink" title="3、简单好用的计算器：bc"></a>3、简单好用的计算器：bc</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936042_6658.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936054_8908.png"></p><p>怎么10/100会变成0呢？这是因为bc预设仅输出整数，如果要输出小数点下位数，那么就必须要执行 scale=number ，那个number就是小数点位数，例如：</p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936069_2896.png"></p><h1 id="4、重要的几个热键-Tab-ctrl-c-ctrl-d"><a href="#4、重要的几个热键-Tab-ctrl-c-ctrl-d" class="headerlink" title="4、重要的几个热键[Tab],[ctrl]-c, [ctrl]-d&nbsp;"></a>4、重要的几个热键[Tab],[ctrl]-c, [ctrl]-d&nbsp;</h1><p>[Tab]按键—具有『命令补全』不『档案补齐』的功能</p><p>[Ctrl]-c按键—让当前的程序『停掉』</p><p>[Ctrl]-d按键—通常代表着：『键盘输入结束(End Of File, EOF 戒 End OfInput)』的意思；另外，他也可以用来取代exit</p><h1 id="5、man"><a href="#5、man" class="headerlink" title="5、man"></a>5、man</h1><p>退出用q，</p><p>man -f man</p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936109_3235.png"></p><h1 id="6、数据同步写入磁盘：-sync"><a href="#6、数据同步写入磁盘：-sync" class="headerlink" title="6、数据同步写入磁盘：&nbsp;sync"></a>6、数据同步写入磁盘：&nbsp;sync</h1><p>输入sync，那举在内存中尚未被更新的数据，就会被写入硬盘中；所以，这个挃令在系统关机戒重新启劢乀前， 径重要喔！最好多执行几次！</p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936120_9820.png"></p><h1 id="7、惯用的关机指令：shutdown"><a href="#7、惯用的关机指令：shutdown" class="headerlink" title="7、惯用的关机指令：shutdown"></a>7、惯用的关机指令：shutdown</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936132_1780.png"></p><p>此外，需要注意的是，时间参数请务必加入指令中，否则shutdown会自动跳到 run-level 1 (就是单人维护的登入情况)，这样就伤脑筋了！底下提供几个时间参数的例子吧：</p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936145_2758.png"></p><p>重启，关机： reboot, halt,poweroff</p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936158_4694.png"></p><h1 id="8、切换执行等级：-init"><a href="#8、切换执行等级：-init" class="headerlink" title="8、切换执行等级： init"></a>8、切换执行等级： init</h1><p>Linux共有七种执行等级：</p><p>--run level 0 :关机</p><p>--run level 3 :纯文本模式</p><p>--run level 5 :含有图形接口模式</p><p>--run level 6 :重新启动</p><p>使用init这个指令来切换各模式：</p><p>如果你想要关机的话，除了上述的shutdown -h now以及poweroff之外，你也可以使用如下的指令来关机：&nbsp;&nbsp;</p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936183_6281.png"></p><h1 id="9、改变文件的所属群组：chgrp"><a href="#9、改变文件的所属群组：chgrp" class="headerlink" title="9、改变文件的所属群组：chgrp"></a>9、改变文件的所属群组：chgrp</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936198_8642.png"></p><h1 id="10、改变文件拥有者：chown"><a href="#10、改变文件拥有者：chown" class="headerlink" title="10、改变文件拥有者：chown"></a>10、改变文件拥有者：chown</h1><p>他还可以顸便直接修改群组的名称</p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936213_8090.png"></p><h1 id="11、改变文件的权限：chmod"><a href="#11、改变文件的权限：chmod" class="headerlink" title="11、改变文件的权限：chmod"></a>11、改变文件的权限：chmod</h1><table border="0" cellspacing="0" cellpadding="0" width="722"><tbody><tr><td valign="top"><p align="left"><span style="font-size:18px;">权限的设定方法有两种， 分别可以使用数字或者是符号来进行权限的变更。</span></p></td></tr></tbody></table><p>--数字类型改变档案权限：</p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936248_2355.png"></p><p>--符号类型改变档案权限：</p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936259_4661.png"></p><h1 id="12、查看版本信息等"><a href="#12、查看版本信息等" class="headerlink" title="12、查看版本信息等"></a>12、查看版本信息等</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936285_4549.png"></p><h1 id="13、变换目录：cd"><a href="#13、变换目录：cd" class="headerlink" title="13、变换目录：cd"></a>13、变换目录：cd</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936297_1247.png"></p><h1 id="14、显示当前所在目录：pwd"><a href="#14、显示当前所在目录：pwd" class="headerlink" title="14、显示当前所在目录：pwd"></a>14、显示当前所在目录：pwd</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936306_6088.png"></p><h1 id="15、建立新目录：mkdir"><a href="#15、建立新目录：mkdir" class="headerlink" title="15、建立新目录：mkdir"></a>15、建立新目录：mkdir</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936321_4240.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936335_4740.png"></p><p>不建议常用-p这个选项，因为担心如果你打错字，那么目录名称就回变得乱七八糟的</p><h1 id="16、删除『空』的目录：rmdir"><a href="#16、删除『空』的目录：rmdir" class="headerlink" title="16、删除『空』的目录：rmdir"></a>16、删除『空』的目录：rmdir</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936353_8065.png"></p><h1 id="17、档案与目录的显示：ls"><a href="#17、档案与目录的显示：ls" class="headerlink" title="17、档案与目录的显示：ls"></a>17、档案与目录的显示：ls</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936364_8540.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936378_2040.png"></p><h1 id="18、复制档案或目录：cp"><a href="#18、复制档案或目录：cp" class="headerlink" title="18、复制档案或目录：cp"></a>18、复制档案或目录：cp</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936391_3459.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936405_1275.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936421_3936.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936434_7475.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936447_1389.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936473_8128.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936488_3487.png"></p><h1 id="19、移除档案或目录：rm"><a href="#19、移除档案或目录：rm" class="headerlink" title="19、移除档案或目录：rm"></a>19、移除档案或目录：rm</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936513_9642.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936523_3283.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936534_8970.png"></p><h1 id="20、移动档案与目录，或更名：mv"><a href="#20、移动档案与目录，或更名：mv" class="headerlink" title="20、移动档案与目录，或更名：mv"></a>20、移动档案与目录，或更名：mv</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936546_1932.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936558_1163.png"></p><h1 id="21、取得路径的文件名与目录名：basename，dirname"><a href="#21、取得路径的文件名与目录名：basename，dirname" class="headerlink" title="21、取得路径的文件名与目录名：basename，dirname"></a>21、取得路径的文件名与目录名：basename，dirname</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936571_2352.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936582_4520.png"></p><h1 id="22、由第一行开始显示档案内容：cat"><a href="#22、由第一行开始显示档案内容：cat" class="headerlink" title="22、由第一行开始显示档案内容：cat"></a>22、由第一行开始显示档案内容：cat</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936609_6282.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936621_3423.png"></p><h1 id="23、从最后一行开始显示：tac（可以看出-tac-是-cat-的倒着写）"><a href="#23、从最后一行开始显示：tac（可以看出-tac-是-cat-的倒着写）" class="headerlink" title="23、从最后一行开始显示：tac（可以看出 tac 是 cat 的倒着写）"></a>23、从最后一行开始显示：tac（可以看出 tac 是 cat 的倒着写）</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936634_1541.png"></p><h1 id="24、显示的时候，顺道输出行号：nl"><a href="#24、显示的时候，顺道输出行号：nl" class="headerlink" title="24、显示的时候，顺道输出行号：nl"></a>24、显示的时候，顺道输出行号：nl</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936651_6458.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936671_4557.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936684_7797.png"></p><h1 id="25、一页一页的显示档案内容：more"><a href="#25、一页一页的显示档案内容：more" class="headerlink" title="25、一页一页的显示档案内容：more"></a>25、一页一页的显示档案内容：more</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936710_9067.png"></p><h1 id="26、与-more-类似，但是比-more-更好的是，他可以往前翻页：less"><a href="#26、与-more-类似，但是比-more-更好的是，他可以往前翻页：less" class="headerlink" title="26、与 more 类似，但是比 more 更好的是，他可以往前翻页：less"></a>26、与 more 类似，但是比 more 更好的是，他可以往前翻页：less</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936728_2729.png"></p><h1 id="27、只看头几行：head"><a href="#27、只看头几行：head" class="headerlink" title="27、只看头几行：head"></a>27、只看头几行：head</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936748_3301.png"></p><h1 id="28、只看尾几行：tail"><a href="#28、只看尾几行：tail" class="headerlink" title="28、只看尾几行：tail"></a>28、只看尾几行：tail</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936798_8160.png"></p><h1 id="29、以二进制的放置读取档案内容：od"><a href="#29、以二进制的放置读取档案内容：od" class="headerlink" title="29、以二进制的放置读取档案内容：od"></a>29、以二进制的放置读取档案内容：od</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936808_2619.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936819_8586.png"></p><h1 id="30、修改档案时间或新建档案：touch"><a href="#30、修改档案时间或新建档案：touch" class="headerlink" title="30、修改档案时间或新建档案：touch"></a>30、修改档案时间或新建档案：touch</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936832_1025.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936847_2396.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936857_7179.png"></p><h1 id="31、档案预设权限：umask"><a href="#31、档案预设权限：umask" class="headerlink" title="31、档案预设权限：umask"></a>31、档案预设权限：umask</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936868_1680.png"></p><h1 id="32、配置文件档案隐藏属性：chattr"><a href="#32、配置文件档案隐藏属性：chattr" class="headerlink" title="32、配置文件档案隐藏属性：chattr"></a>32、配置文件档案隐藏属性：chattr</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936877_4715.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936886_3351.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936897_2939.png"></p><h1 id="33、显示档案隐藏属性：lsattr"><a href="#33、显示档案隐藏属性：lsattr" class="headerlink" title="33、显示档案隐藏属性：lsattr"></a>33、显示档案隐藏属性：lsattr</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936910_4210.png"></p><h1 id="34、观察文件类型：file"><a href="#34、观察文件类型：file" class="headerlink" title="34、观察文件类型：file"></a>34、观察文件类型：file</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936923_3379.png"></p><h1 id="35、寻找【执行挡】：which"><a href="#35、寻找【执行挡】：which" class="headerlink" title="35、寻找【执行挡】：which"></a>35、寻找【执行挡】：which</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936932_2949.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936946_1973.png"></p><h1 id="36、寻找特定档案：whereis"><a href="#36、寻找特定档案：whereis" class="headerlink" title="36、寻找特定档案：whereis"></a>36、寻找特定档案：whereis</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363936956_5666.png"></p><h1 id="37、寻找特定档案：locate"><a href="#37、寻找特定档案：locate" class="headerlink" title="37、寻找特定档案：locate"></a>37、寻找特定档案：locate</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363937757_9288.png"></p><h1 id="38、寻找特定档案：find"><a href="#38、寻找特定档案：find" class="headerlink" title="38、寻找特定档案：find"></a>38、寻找特定档案：find</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363937773_3082.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363937784_2757.png"></p><h1 id="39、压缩文件和读取压缩文件：gzip，zcat"><a href="#39、压缩文件和读取压缩文件：gzip，zcat" class="headerlink" title="39、压缩文件和读取压缩文件：gzip，zcat"></a>39、压缩文件和读取压缩文件：gzip，zcat</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363937793_4694.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363937802_1953.png"></p><h1 id="40、压缩文件和读取压缩文件：bzip2，bzcat"><a href="#40、压缩文件和读取压缩文件：bzip2，bzcat" class="headerlink" title="40、压缩文件和读取压缩文件：bzip2，bzcat"></a>40、压缩文件和读取压缩文件：bzip2，bzcat</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363937816_9269.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363937900_4463.png"></p><h1 id="41、压缩文件和读取压缩文件：tar"><a href="#41、压缩文件和读取压缩文件：tar" class="headerlink" title="41、压缩文件和读取压缩文件：tar"></a>41、压缩文件和读取压缩文件：tar</h1><p><img src="https://img-my.csdn.net/uploads/201303/22/1363937990_3354.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363938001_5653.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363938031_1319.png">  </p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363938044_9852.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363938052_3223.png"></p><p><img src="https://img-my.csdn.net/uploads/201303/22/1363938061_6833.png"></p><p>好了，累死了，终于搞完了，希望能对的大家有所帮助。</p><p><a href="https://blog.csdn.net/xiaoguaihai/article/details/8705992">转自 【csdn】 xiaoguaihai</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是BFC</title>
      <link href="/blog/web/20200803002/"/>
      <url>/blog/web/20200803002/</url>
      
        <content type="html"><![CDATA[<h3 id="BFC-定义"><a href="#BFC-定义" class="headerlink" title="BFC 定义"></a>BFC 定义</h3><blockquote><p>BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p></blockquote><p>在解释什么是BFC之前，我们需要先知道Box、Formatting Context的概念。</p><h6 id="Box：css布局的基本单位"><a href="#Box：css布局的基本单位" class="headerlink" title="Box：css布局的基本单位"></a>Box：css布局的基本单位</h6><p>Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子：</p><ul><li>block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context；</li><li>inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context；</li><li>run-in box: css3 中才有， 这儿先不讲了。</li></ul><h6 id="Formatting-Context"><a href="#Formatting-Context" class="headerlink" title="Formatting Context"></a>Formatting Context</h6><p>Formatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。</p><blockquote><p><code>BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。</code></p></blockquote><h3 id="BFC的布局规则"><a href="#BFC的布局规则" class="headerlink" title="BFC的布局规则"></a>BFC的布局规则</h3><ul><li><p>内部的Box会在垂直方向，一个接一个地放置。</p></li><li><p>Box垂直方向的距离由margin决定。属于<strong>同一个</strong>BFC的两个相邻Box的margin会发生重叠。</p></li><li><p>每个盒子（块盒与行盒）的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</p></li><li><p>BFC的区域不会与float box重叠。</p></li><li><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p></li><li><p>计算BFC的高度时，浮动元素也参与计算。</p></li></ul><h3 id="如何创建BFC"><a href="#如何创建BFC" class="headerlink" title="如何创建BFC"></a>如何创建BFC</h3><ul><li>1、float的值不是none。</li><li>2、position的值不是static或者relative。</li><li>3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex</li><li>4、overflow的值不是visible</li></ul><h3 id="BFC的作用"><a href="#BFC的作用" class="headerlink" title="BFC的作用"></a>BFC的作用</h3><h6 id="1-利用BFC避免margin重叠。"><a href="#1-利用BFC避免margin重叠。" class="headerlink" title="1.利用BFC避免margin重叠。"></a>1.利用BFC避免margin重叠。</h6><p>一起来看一个例子：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;    &lt;title&gt;防止margin重叠&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    *&amp;#123;        margin: 0;        padding: 0;    &amp;#125;    p &amp;#123;        color: #f55;        background: yellow;        width: 200px;        line-height: 100px;        text-align:center;        margin: 30px;    &amp;#125;&lt;/style&gt;&lt;body&gt;    &lt;p&gt;看看我的 margin是多少&lt;/p&gt;    &lt;p&gt;看看我的 margin是多少&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>页面生成的效果就是这样的：<br><img src="https://img-blog.csdnimg.cn/20190323155704915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NDIyMjM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>根据第二条，属于同一个BFC的两个相邻的Box会发生margin重叠，所以我们可以设置，两个不同的BFC，也就是我们可以让把第二个p用div包起来，然后激活它使其成为一个BFC</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;    &lt;title&gt;防止margin重叠&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    *&amp;#123;        margin: 0;        padding: 0;    &amp;#125;    p &amp;#123;        color: #f55;        background: yellow;        width: 200px;        line-height: 100px;        text-align:center;        margin: 30px;    &amp;#125;    div&amp;#123;        overflow: hidden;    &amp;#125;&lt;/style&gt;&lt;body&gt;    &lt;p&gt;看看我的 margin是多少&lt;/p&gt;    &lt;div&gt;        &lt;p&gt;看看我的 margin是多少&lt;/p&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://img-blog.csdnimg.cn/20190323160150540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NDIyMjM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h6 id="2-自适应两栏布局"><a href="#2-自适应两栏布局" class="headerlink" title="2.自适应两栏布局"></a>2.自适应两栏布局</h6><p>根据：</p><ul><li>每个盒子的margin box的左边，与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li></ul><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    *&amp;#123;        margin: 0;        padding: 0;    &amp;#125;    body &amp;#123;        width: 100%;        position: relative;    &amp;#125;    .left &amp;#123;        width: 100px;        height: 150px;        float: left;        background: rgb(139, 214, 78);        text-align: center;        line-height: 150px;        font-size: 20px;    &amp;#125;    .right &amp;#123;        height: 300px;        background: rgb(170, 54, 236);        text-align: center;        line-height: 300px;        font-size: 40px;    &amp;#125;&lt;/style&gt;&lt;body&gt;    &lt;div class="left"&gt;LEFT&lt;/div&gt;    &lt;div class="right"&gt;RIGHT&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>页面：<br><img src="https://img-blog.csdnimg.cn/2019032316073845.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NDIyMjM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>又因为：</p><ul><li>BFC的区域不会与float box重叠。</li></ul><p>所以我们让right单独成为一个BFC</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;    &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    *&amp;#123;        margin: 0;        padding: 0;    &amp;#125;    body &amp;#123;        width: 100%;        position: relative;    &amp;#125;    .left &amp;#123;        width: 100px;        height: 150px;        float: left;        background: rgb(139, 214, 78);        text-align: center;        line-height: 150px;        font-size: 20px;    &amp;#125;    .right &amp;#123;        overflow: hidden;        height: 300px;        background: rgb(170, 54, 236);        text-align: center;        line-height: 300px;        font-size: 40px;    &amp;#125;&lt;/style&gt;&lt;body&gt;    &lt;div class="left"&gt;LEFT&lt;/div&gt;    &lt;div class="right"&gt;RIGHT&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>页面：<br><img src="https://img-blog.csdnimg.cn/20190323161159873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NDIyMjM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>right会自动的适应宽度，这时候就形成了一个两栏自适应的布局。</p><h6 id="3-清楚浮动。"><a href="#3-清楚浮动。" class="headerlink" title="3.清楚浮动。"></a>3.清楚浮动。</h6><p>当我们不给父节点设置高度，子节点设置浮动的时候，会发生高度塌陷，这个时候我们就要清楚浮动。</p><p>比如这样：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;    &lt;title&gt;清除浮动&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    .par &amp;#123;        border: 5px solid rgb(91, 243, 30);        width: 300px;    &amp;#125;    .child &amp;#123;        border: 5px solid rgb(233, 250, 84);        width:100px;        height: 100px;        float: left;    &amp;#125;&lt;/style&gt;&lt;body&gt;    &lt;div class="par"&gt;        &lt;div class="child"&gt;&lt;/div&gt;        &lt;div class="child"&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>页面：<br><img src="https://img-blog.csdnimg.cn/20190323161720931.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NDIyMjM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>这个时候我们根据最后一条：</p><ul><li>计算BFC的高度时，浮动元素也参与计算。</li></ul><p>给父节点激活BFC</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;    &lt;title&gt;清除浮动&lt;/title&gt;&lt;/head&gt;&lt;style&gt;    .par &amp;#123;        border: 5px solid rgb(91, 243, 30);        width: 300px;        overflow: hidden;    &amp;#125;    .child &amp;#123;        border: 5px solid rgb(233, 250, 84);        width:100px;        height: 100px;        float: left;    &amp;#125;&lt;/style&gt;&lt;body&gt;    &lt;div class="par"&gt;        &lt;div class="child"&gt;&lt;/div&gt;        &lt;div class="child"&gt;&lt;/div&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>页面：<br><img src="https://img-blog.csdnimg.cn/20190323161945489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NpbmF0XzM2NDIyMjM2,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上例子都体现了：</p><blockquote><p>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</p></blockquote><p>因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。<br><a href="https://blog.csdn.net/sinat_36422236/article/details/88763187">转自 【cddn】Leon_94</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 Egg.js 框架的 Node.js 服务构建之用户管理设计</title>
      <link href="/blog/backend/20200803001/"/>
      <url>/blog/backend/20200803001/</url>
      
        <content type="html"><![CDATA[<blockquote><p>近来公司需要构建一套 EMM（Enterprise Mobility Management）的管理平台，就这种面向企业的应用管理本身需要考虑的需求是十分复杂的，技术层面管理端和服务端构建是架构核心，客户端本身初期倒不需要那么复杂，作为移动端的负责人（其实也就是一个打杂的小组长），这个平台架构我自然是免不了去参与的，作为一个前端 jser 来公司这边总是接到这种不太像前端的工作，要是以前我可能会有些抵触这种业务层面需要考虑的很多，技术实现本身又不太容易积累技术成长的活。这一年我成长了太多，总是尝试着去做一些可能自己谈不上喜欢但还是有意义的事情，所以这次接手这个任务还是想好好把这个事情做好，所以想考虑参与到 EMM 服务端构建。其实话又说回来，任何事只要想去把它做好，怎么会存在有意义还是没意义的区别呢？</p></blockquote><p>考虑到基于 Node.js 构建的服务目前越来越流行，也方便后续放在平台容器云上构建微服务，另外作为一个前端 jser 出身的程序员，使用 Node.js 来构建服务格外熟悉。之前学习过一段时间 Egg.js，这次毫不犹豫的选择了基于 Egg.js 框架来搭建。</p><h2 id="为什么是-Egg-js-？"><a href="#为什么是-Egg-js-？" class="headerlink" title="为什么是 Egg.js ？"></a>为什么是 Egg.js ？</h2><p>去年在 gitchat <a href="http://gitbook.cn/books/598144f5e64f69311fe1a813/index.html">JavaScript 进阶之 Vue.js + Node.js 入门实战开发</a> 中安利过 Egg.js，那个时候是初接触 Egg.js，但是还是被它惊艳到了，<strong>Egg 继承于 Koa，奉行『约定优于配置』，按照一套统一的约定进行应用开发，插件机制也比较完善</strong>。虽然说 Egg 继承于 Koa，大家可能觉得完全可以自己基于 Koa 去实现一套，没必要基于这个框架去搞，但是其实自己去设计一套这样的框架，最终也是需要去借鉴各家所长，时间成本上短期是划不来的。Koa 是一个小而精的框架，而 Egg 正如文档说的<strong>为企业级框架和应用而生</strong>，对于我们快速搭建一个完备的企业级应用还是很方便的。Egg 功能已经比较完善，另外如果没有实现的功能，自己根据 Koa 社区提供的插件封装一下也是不难的。</p><h2 id="ORM-设计选型"><a href="#ORM-设计选型" class="headerlink" title="ORM 设计选型"></a>ORM 设计选型</h2><p>在数据库选择上本次项目考虑使用 MySQL，而不是 MongoDB，开始使用的是 egg-mysql 插件，写了一部分后发现 service 里面写了太多东西，表字段修改会影响太多代码，在设计上缺乏对 Model 的管理，看到资料说可以引入 ORM 框架，比如 sequelize，而 Egg 官方恰好提供了 egg-sequelize 插件。</p><h3 id="什么是-ORM"><a href="#什么是-ORM" class="headerlink" title="什么是 ORM ?"></a>什么是 ORM ?</h3><p>首先了解一下什么是 ORM ?</p><blockquote><p>对象关系映射（英语：Object Relational Mapping，简称 ORM，或 O/RM，或 O/R mapping），是一种程序设计技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换。从效果上说，它其实是创建了一个可在编程语言里使用的“虚拟对象数据库”。</p></blockquote><p>类似于 J2EE 中的 DAO 设计模式，将程序中的数据对象自动地转化为关系型数据库中对应的表和列，数据对象间的引用也可以通过这个工具转化为表。这样就可以很好的解决我遇到的那个问题，对于表结构修改和数据对象操作是两个独立的部分，从而使得代码更好维护。其实是否选择 ORM 框架，和以前前端是选择模板引擎还是手动拼字符串一样，ORM 框架避免了在开发的时候手动拼接 SQL 语句，可以防止 SQL 注入，另外也将数据库和数据 CRUD 解耦，更换数据库也相对更容易。</p><h3 id="sequelize-框架"><a href="#sequelize-框架" class="headerlink" title="sequelize 框架"></a>sequelize 框架</h3><p>sequelize 是 Node.js 社区比较流行的一个 ORM 框架，相关文档：</p><ul><li>sequelize.js 文档：<a href="http://docs.sequelizejs.com/">http://docs.sequelizejs.com/</a></li></ul><h4 id="sequelize-使用"><a href="#sequelize-使用" class="headerlink" title="sequelize 使用"></a>sequelize 使用</h4><p><strong>安装：</strong></p><pre><code>$ npm install --save sequelize</code></pre><p><strong>建立连接：</strong></p><pre><code>const Sequelize = require("sequelize");// 完整用法const sequelize = new Sequelize("database", "username", "password", &amp;#123;  host: "localhost",  dialect: "mysql" | "sqlite" | "postgres" | "mssql",  operatorsAliases: false,  pool: &amp;#123;    max: 5,    min: 0,    acquire: 30000,    idle: 10000  &amp;#125;,  // SQLite only  storage: "path/to/database.sqlite");</code></pre><p>// 简单用法</p><pre><code>const sequelize = new Sequelize("postgres://user:pass@example.com:5432dbname");</code></pre><p><strong>校验连接是否正确：</strong></p><pre><code>sequelize  .authenticate()  .then(() =&gt; &amp;#123;    console.log("Connection has been established successfully.");  &amp;#125;)  .catch(err =&gt; &amp;#123;    console.error("Unable to connect to the database:", err);  &amp;#125;);</code></pre><p><strong>定义 Model ：</strong></p><p>定义一个 Model 的基本语法：</p><pre><code>sequelize.define("name", &amp;#123; attributes &amp;#125;, &amp;#123; options &amp;#125;);</code></pre><p>例如：</p><pre><code>const User = sequelize.define("user", &amp;#123;  username: &amp;#123;    type: Sequelize.STRING  &amp;#125;,  password: &amp;#123;    type: Sequelize.STRING  &amp;#125;&amp;#125;);</code></pre><p>对于一个 Model 字段类型设计，主要考虑以下几个方面：</p><p>Sequelize 默认会添加 createdAt 和 updatedAt，这样可以很方便的知道数据创建和更新的时间。如果不想使用可以通过设置 attributes 的 timestamps: false；</p><p>Sequelize 支持丰富的数据类型，例如：STRING、CHAR、TEXT、INTEGER、FLOAT、DOUBLE、BOOLEAN、DATE、UUID 、JSON 等多种不同的数据类型，具体可以看文档：<a href="http://docs.sequelizejs.com/variable/index.html#static-variable-DataTypes">DataTypes</a> 。</p><p>Getters &amp; setters 支持，当我们需要对字段进行处理的时候十分有用，例如：对字段值大小写转换处理。</p><pre><code>const Employee = sequelize.define("employee", &amp;#123;  name: &amp;#123;    type: Sequelize.STRING,    allowNull: false,    get() &amp;#123;      const title = this.getDataValue("title");      return this.getDataValue("name") + " (" + title + ")";    &amp;#125;  &amp;#125;,  title: &amp;#123;    type: Sequelize.STRING,    allowNull: false,    set(val) &amp;#123;      this.setDataValue("title", val.toUpperCase());    &amp;#125;  &amp;#125;&amp;#125;);</code></pre><p>字段校验有两种类型：非空校验及类型校验，Sequelize 中非空校验通过字段的 allowNull 属性判定，类型校验是通过 validate 进行判定，底层是通过 <a href="https://github.com/chriso/validator.js">validator.js</a> 实现的。如果模型的特定字段设置为允许 null（allowNull：true），并且该值已设置为 null，则 validate 属性不生效。例如，有一个字符串字段，allowNull 设置为 true，validate 验证其长度至少为 5 个字符，但也允许为空。</p><pre><code>const ValidateMe = sequelize.define("foo", &amp;#123;  foo: &amp;#123;    type: Sequelize.STRING,    validate: &amp;#123;      is: \["^\[a-z\]+$", "i"\], // will only allow letters      is: /^\[a-z\]+$/i, // same as the previous example using real RegExp      not: \["\[a-z\]", "i"\], // will not allow letters      isEmail: true, // checks for email format (foo@bar.com)      isUrl: true, // checks for url format (http://foo.com)      isIP: true, // checks for IPv4 (129.89.23.1) or IPv6 format      isIPv4: true, // checks for IPv4 (129.89.23.1)      isIPv6: true, // checks for IPv6 format      isAlpha: true, // will only allow letters      isAlphanumeric: true, // will only allow alphanumeric characters, so "\_abc" will fail      isNumeric: true, // will only allow numbers      isInt: true, // checks for valid integers      isFloat: true, // checks for valid floating point numbers      isDecimal: true, // checks for any numbers      isLowercase: true, // checks for lowercase      isUppercase: true, // checks for uppercase      notNull: true, // won't allow null      isNull: true, // only allows null      notEmpty: true, // don't allow empty strings      equals: "specific value", // only allow a specific value      contains: "foo", // force specific substrings      notIn: \[\["foo", "bar"\]\], // check the value is not one of these      isIn: \[\["foo", "bar"\]\], // check the value is one of these      notContains: "bar", // don't allow specific substrings      len: \[2, 10\], // only allow values with length between 2 and 10      isUUID: 4, // only allow uuids      isDate: true, // only allow date strings      isAfter: "2011-11-05", // only allow date strings after a specific date      isBefore: "2011-11-05", // only allow date strings before a specific date      max: 23, // only allow values &lt;= 23      min: 23, // only allow values &gt;= 23      isCreditCard: true, // check for valid credit card numbers      // custom validations are also possible:      isEven(value) &amp;#123;        if (parseInt(value) % 2 != 0) &amp;#123;          throw new Error("Only even values are allowed!");          // we also are in the model's context here, so this.otherField          // would get the value of otherField if it existed        &amp;#125;      &amp;#125;    &amp;#125;  &amp;#125;&amp;#125;);</code></pre><p>最后我们说明一个最重要的字段<strong>主键 id</strong> 的设计， 需要通过字段 <code>primaryKey: true</code> 指定为主键。MySQL 里面主键设计主要有两种方式：<strong>自动递增</strong>；<strong>UUID</strong>。</p><p>自动递增设置 <code>autoIncrement: true</code> 即可，对于一般的小型系统这种方式是最方便，查询效率最高的，但是这种不利于分布式集群部署，这种基本用过 MySQL 里面应用都用过，这里不做深入讨论。</p><p>UUID, 又名全球独立标识(Globally Unique Identifier)，UUID 是 128 位(长度固定)unsigned integer, 能够保证在空间(Space)与时间(Time)上的唯一性。而且无需注册机制保证, 可以按需随时生成。据 WIKI, 随机算法生成的 UUID 的重复概率为 170 亿分之一。Sequelize 数据类型中有 UUID，UUID1，UUID4 三种类型，基于<a href="https://github.com/kelektiv/node-uuid">node-uuid</a> 遵循 <a href="http://www.ietf.org/rfc/rfc4122.txt">RFC4122</a> 。例如：</p><pre><code>const User = sequelize.define("user", &amp;#123;  id: &amp;#123;    type: Sequelize.UUID,    primaryKey: true,    allowNull: false,    defaultValue: Sequelize.UUID1  &amp;#125;&amp;#125;);</code></pre><p>这样 id 默认值生成一个 uuid 字符串，例如：’1c572360-faca-11e7-83ee-9d836d45ff41’，很多时候我们不太想要这个 <code>-</code> 字符，我们可以通过设置 defaultValue 实现，例如：</p><pre><code>const uuidv1 = require("uuid/v1");const User = sequelize.define("user", &amp;#123;  id: &amp;#123;    type: Sequelize.UUID,    primaryKey: true,    allowNull: false,    defaultValue: function() &amp;#123;      return uuidv1().replace(/-/g, "");    &amp;#125;  &amp;#125;&amp;#125;);</code></pre><p><strong>使用 Model 对象：</strong></p><p>对于 Model 对象操作，Sequelize 提供了一系列的方法：</p><ul><li>find：搜索数据库中的一个特定元素，可以通过 findById 或 findOne；</li><li>findOrCreate：搜索特定元素或在不可用时创建它；</li><li>findAndCountAll：搜索数据库中的多个元素，返回数据和总数；</li><li>findAll：在数据库中搜索多个元素；</li><li>复杂的过滤/ OR / NOT 查询；</li><li>使用 limit(限制)，offset(偏移量)，order(顺序)和 group(组)操作数据集;</li><li>count：计算数据库中元素的出现次数；</li><li>max：获取特定表格中特定属性的最大值；</li><li>min：获取特定表格中特定属性的最小值；</li><li>sum：特定属性的值求和；</li><li>create：创建数据库 Model 实例；</li><li>update：更新数据库 Model 实例；</li><li>destroy：销毁数据库 Model 实例。</li></ul><p>通过上述提供的一系列方法可以实现数据的增删改查（CRUD），例如：</p><pre><code>User.create(&amp;#123; username: "fnord", job: "omnomnom" &amp;#125;)  .then(() =&gt;    User.findOrCreate(&amp;#123;      where: &amp;#123; username: "fnord" &amp;#125;,      defaults: &amp;#123; job: "something else" &amp;#125;    &amp;#125;)  )  .spread((user, created) =&gt; &amp;#123;    console.log(      user.get(&amp;#123;        plain: true      &amp;#125;)    );    console.log(created);    /\*    In this example, findOrCreate returns an array like this:    \[ &amp;#123;        username: 'fnord',        job: 'omnomnom',        id: 2,        createdAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET),        updatedAt: Fri Mar 22 2013 21: 28: 34 GMT + 0100(CET)      &amp;#125;,      false    \]    \*/  &amp;#125;);</code></pre><h3 id="egg-sequelize-插件"><a href="#egg-sequelize-插件" class="headerlink" title="egg-sequelize 插件"></a>egg-sequelize 插件</h3><p>文档：egg-sequelize：<a href="https://github.com/eggjs/egg-sequelize">https://github.com/eggjs/egg-sequelize</a></p><h5 id="源码简析"><a href="#源码简析" class="headerlink" title="源码简析"></a>源码简析</h5><p>这里我们暂时先不分析 egg 插件规范，暂时先只看看 egg-sequelize/lib/loader.js 里面的实现：</p><pre><code>"use strict";const path = require("path");const Sequelize = require("sequelize");const MODELS = Symbol("loadedModels");const chalk = require("chalk");Sequelize.prototype.log = function() &amp;#123;  if (this.options.logging === false) &amp;#123;    return;  &amp;#125;  const args = Array.prototype.slice.call(arguments);  const sql = args\[0\].replace(/Executed \\(.+?\\):\\s&amp;#123;0,1&amp;#125;/, "");  this.options.logging.info("\[model\]", chalk.magenta(sql), \`($&amp;#123;args\[1\]&amp;#125;ms)\`);&amp;#125;;module.exports = app =&gt; &amp;#123;  const defaultConfig = &amp;#123;    logging: app.logger,    host: "localhost",    port: 3306,    username: "root",    benchmark: true,    define: &amp;#123;      freezeTableName: false,      underscored: true    &amp;#125;  &amp;#125;;  const config = Object.assign(defaultConfig, app.config.sequelize);  app.Sequelize = Sequelize;  const sequelize = new Sequelize(    config.database,    config.username,    config.password,    config  );  // app.sequelize  Object.defineProperty(app, "model", &amp;#123;    value: sequelize,    writable: false,    configurable: false  &amp;#125;);  loadModel(app);  app.beforeStart(function\*() &amp;#123;    yield app.model.authenticate();  &amp;#125;);&amp;#125;;function loadModel(app) &amp;#123;  const modelDir = path.join(app.baseDir, "app/model");  app.loader.loadToApp(modelDir, MODELS, &amp;#123;    inject: app,    caseStyle: "upper",    ignore: "index.js"  &amp;#125;);  for (const name of Object.keys(app\[MODELS\])) &amp;#123;    const klass = app\[MODELS\]\[name\];    // only this Sequelize Model class    if ("sequelize" in klass) &amp;#123;      app.model\[name\] = klass;      if (        "classMethods" in klass.options ||        "instanceMethods" in klass.options      ) &amp;#123;        app.logger          .error(\`$&amp;#123;name&amp;#125; model has classMethods/instanceMethods, but it was removed supports in Sequelize V4.\\see: http://docs.sequelizejs.com/manual/tutorial/models-definition.html#expansion-of-models\`);      &amp;#125;    &amp;#125;  &amp;#125;  for (const name of Object.keys(app\[MODELS\])) &amp;#123;    const klass = app\[MODELS\]\[name\];    if ("associate" in klass) &amp;#123;      klass.associate();    &amp;#125;  &amp;#125;&amp;#125;</code></pre><p>很明显在插件初始化的时候进行了 Sequelize 对象的实例化，并将 Sequelize 对象挂载在 app 对象下，即我们可以通过 app.Sequelize 访问 Sequelize 对象，同时我们可以通过 app.model 对 Sequelize 实例化进行访问，app/model 文件夹下存放 model 对象文件。</p><h5 id="用户-Model-设计"><a href="#用户-Model-设计" class="headerlink" title="用户 Model 设计"></a>用户 Model 设计</h5><p>这里我们以 egg-sequelize 的使用为例加以说明。</p><p><strong>安装：</strong></p><pre><code>$ npm i --save egg-sequelize$ npm install --save mysql2 # For both mysql and mariadb dialects</code></pre><p><strong>配置：</strong></p><pre><code>app/config/plugin.js 配置：exports.sequelize = &amp;#123;  enable: true,  package: "egg-sequelize"&amp;#125;;app/config/config.default.js 配置：// 数据库信息配置exports.sequelize = &amp;#123;  // 数据库类型  dialect: "mysql",  // host  host: "localhost",  // 端口号  port: "3306",  // 用户名  username: "root",  // 密码  password: "xxx",  // 数据库名  database: "AEMM"&amp;#125;;</code></pre><p><strong>Model 层：</strong></p><p>直接使用 Sequelize 虽然可以，但是存在一些问题。团队开发时，有人喜欢自己加 timestamp，有人又喜欢自增主键，并且自定义表名。一个大型 Web App 通常都有几十个映射表，一个映射表就是一个 Model。如果按照各自喜好，那业务代码就不好写。Model 不统一，很多代码也无法复用。所以我们需要一个统一的模型，强迫所有 Model 都遵守同一个规范，这样不但实现简单，而且容易统一风格。</p><p>我们首先要定义的就是 Model 存放的文件夹必须在 models 内，并且以 Model 名字命名，例如：Pet.js，User.js 等等。其次，每个 Model 必须遵守一套规范：</p><ul><li>统一主键，名称必须是 id，类型必须是 UUID；</li><li>所有字段默认为 NULL，除非显式指定；</li><li>统一 timestamp 机制，每个 Model 必须有 createdAt、updatedAt 和 version，分别记录创建时间、修改时间和版本号。</li></ul><p>所以，我们不要直接使用 Sequelize 的 API，而是通过 db.js 间接地定义 Model。例如，User.js 应该定义如下：</p><pre><code>app/db.js：const uuidv1 = require("uuid/v1");function generateUUID() &amp;#123;  return uuidv1().replace(/-/g, "");&amp;#125;function defineModel(app, name, attributes) &amp;#123;  const &amp;#123; UUID &amp;#125; = app.Sequelize;  let attrs = &amp;#123;&amp;#125;;  for (let key in attributes) &amp;#123;    let value = attributes\[key\];    if (typeof value === "object" &amp;&amp; value\["type"\]) &amp;#123;      value.allowNull = value.allowNull || true;      attrs\[key\] = value;    &amp;#125; else &amp;#123;      attrs\[key\] = &amp;#123;        type: value,        allowNull: true      &amp;#125;;    &amp;#125;  &amp;#125;  attrs.id = &amp;#123;    type: UUID,    primaryKey: true,    defaultValue: () =&gt; &amp;#123;      return generateUUID();    &amp;#125;  &amp;#125;;  return app.model.define(name, attrs, &amp;#123;    createdAt: "createdAt",    updatedAt: "updatedAt",    version: true,    freezeTableName: true  &amp;#125;);&amp;#125;module.exports = &amp;#123; defineModel &amp;#125;;</code></pre><p>我们定义的 defineModel 就是为了强制实现上述规则。</p><pre><code>app/model/User.js：const db = require("../db");module.exports = app =&gt; &amp;#123;  const &amp;#123; STRING, INTEGER, DATE, BOOLEAN &amp;#125; = app.Sequelize;  const User = db.defineModel(app, "users", &amp;#123;    username: &amp;#123; type: STRING, unique: true, allowNull: false &amp;#125;, // 用户名    email: &amp;#123; type: STRING, unique: true, allowNull: false &amp;#125;, // 邮箱    password: &amp;#123; type: STRING, allowNull: false &amp;#125;, // 密码    name: STRING, // 姓名    sex: INTEGER, // 用户性别：1男性, 2女性, 0未知    age: INTEGER, // 年龄    avatar: STRING, // 头像    company: STRING, // 公司    department: STRING, // 部门    telePhone: STRING, // 联系电话    mobilePhone: STRING, // 手机号码    info: STRING, // 备注说明    roleId: STRING, // 角色id    status: STRING, // 用户状态    token: STRING, // 认证 token    lastSignInAt: DATE // 上次登录时间  &amp;#125;);  return User;&amp;#125;;</code></pre><p>在数据库操作设计中，我们一般是通过脚本提前生成表结构，如果手动写创建表的 SQL，每次修改表结构其实是一件麻烦事。Sequelize 提供了<a href="http://docs.sequelizejs.com/manual/tutorial/migrations.html">Migrations</a> 帮助创建或迁移数据库，egg-sequelize 里面也提供了方便的方法。如果是开发阶段，可以使用下面的方法自动执行：</p><pre><code>// &amp;#123;app\_root&amp;#125;/app.jsmodule.exports = app =&gt; &amp;#123;  if (app.config.env === "local") &amp;#123;    app.beforeStart(function\*() &amp;#123;      yield app.model.sync(&amp;#123; force: true &amp;#125;);    &amp;#125;);  &amp;#125;&amp;#125;;</code></pre><p>当然也可以在 package.json 里面添加下面的脚本：</p><p>命令</p><p>说明</p><pre><code>npm run migrate:new</code></pre><p>在 ./migrations/ 中创建一个 迁移文件 to</p><pre><code>npm run migrate:up</code></pre><p>执行迁移</p><pre><code>npm run migrate:down</code></pre><p>回滚一次迁移</p><pre><code>package.json：..."scripts": &amp;#123;  "migrate:new": "egg-sequelize migration:create --name init",  "migrate:up": "egg-sequelize db:migrate",  "migrate:down": "egg-sequelize db:migrate:undo"&amp;#125;...</code></pre><p>执行 npm run migrate:new 后修改 migrations 文件夹下的文件：</p><pre><code>module.exports = &amp;#123;  async up(queryInterface, Sequelize) &amp;#123;    const &amp;#123; UUID, STRING, INTEGER, DATE, BOOLEAN &amp;#125; = Sequelize;    await queryInterface.createTable("users", &amp;#123;      id: &amp;#123;        type: UUID,        primaryKey: true,        allowNull: false      &amp;#125;, // 用户 ID（主键）      username: &amp;#123;         type: STRING,         unique: true,         allowNull: false       &amp;#125;, // 用户名      email: &amp;#123;         type: STRING,         unique: true,         allowNull: false      &amp;#125;, // 邮箱      password: &amp;#123;         type: STRING,         allowNull: false       &amp;#125;, // 登录密码      name: STRING, // 姓名      age: INTEGER, // 用户年龄      info: STRING, // 备注说明      sex: INTEGER, // 用户性别：1男性, 2女性, 0未知      telePhone: STRING, // 联系电话      mobilePhone: STRING, // 手机号码      roleId: STRING, // 角色ID      location: STRING, // 常住地      avatar: STRING, // 头像      company: STRING, // 公司      department: STRING, // 部门      emailVerified: BOOLEAN, // 邮箱验证      token: STRING, // 身份认证令牌      status: &amp;#123; type: INTEGER, allowNull: false &amp;#125;, // 用户状态：1启用, 0禁用, 2隐藏, 3删除      createdAt: DATE, // 用户创建时间      updatedAt: DATE, // 用户信息更新时间      lastSignInAt: DATE // 上次登录时间    &amp;#125;);  &amp;#125;,  async down(queryInterface, Sequelize) &amp;#123;    await queryInterface.dropTable("users");  &amp;#125;&amp;#125;;</code></pre><h2 id="用户认证选型"><a href="#用户认证选型" class="headerlink" title="用户认证选型"></a>用户认证选型</h2><p>所谓用户认证（Authentication），就是让用户登录，并且在接下来的一段时间内让用户访问网站时可以使用其账户，而不需要再次登录的机制。</p><blockquote><p>小知识：可别把用户认证和用户授权（Authorization）搞混了。用户授权指的是规定并允许用户使用自己的权限，例如发布帖子、管理站点等。</p></blockquote><p>用户认证主要分为两个部分：</p><ul><li>用户通过用户名和密码登录生成并且获取 Token；</li><li>用户通过 Token 验证用户身份获取相关信息。</li></ul><h3 id="JSON-Web-Token（JWT）规范"><a href="#JSON-Web-Token（JWT）规范" class="headerlink" title="JSON Web Token（JWT）规范"></a>JSON Web Token（JWT）规范</h3><p><a href="https://jwt.io/">JSON Web Token</a> （JWT）是一个非常轻巧的<a href="https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-32">规范</a> 。这个规范允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息。</p><h4 id="JWT-的组成"><a href="#JWT-的组成" class="headerlink" title="JWT 的组成"></a>JWT 的组成</h4><p>一个 JWT 实际上就是一个字符串，它由三部分组成，头部、载荷与签名。</p><p><strong>头部（Header）</strong></p><p>JWT 需要一个头部，头部用于描述关于该 JWT 的最基本的信息，例如其类型以及签名所用的算法等。这也可以被表示成一个 JSON 对象。</p><pre><code>&amp;#123;  "typ": "JWT",  "alg": "HS256"&amp;#125;</code></pre><p>在这里，我们说明了这是一个 JWT，并且我们所用的签名算法是 HS256 算法。对它也要进行 Base64 编码，之后的字符串就成了 JWT 的 Header（头部）。</p><pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</code></pre><p>这里我们使用 base64url 模块进行 Base64 编码来得到这个字符串，测试代码如下：</p><pre><code>const base64url = require("base64url");let header = &amp;#123;  typ: "JWT",  alg: "HS256"&amp;#125;;console.log("header: " + base64url(JSON.stringify(header)));// header: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</code></pre><blockquote><p>小知识：Base64 是一种编码，也就是说，它是可以被翻译回原来的样子来的。它并不是一种加密过程。</p></blockquote><p><strong>载荷（Payload）</strong></p><p>说白了就是我们需要包含的数据，类似于网络请求的请求体 body，例如：</p><pre><code>&amp;#123;  "iss": "zhaomenghaun",  "sub": "\*@agree.com.cn",  "aud": "www.agree.com.cn",  "exp": 1526875179,  "iat": 1526871579,  "id": "49a9dd505c9d11e8b5e86b9776bb3c4f"&amp;#125;</code></pre><p>这里面的前五个字段都是由 JWT 的标准所定义的。</p><ul><li>iss: 该 JWT 的签发者</li><li>sub: 该 JWT 所面向的用户</li><li>aud: 接收该 JWT 的一方</li><li>exp(expires): 什么时候过期，这里是一个 Unix 时间戳</li><li>iat(issued at): 在什么时候签发的</li></ul><p>将下面的 JSON 对象进行<strong>base64 编码</strong>可以得到下面的字符串，这个字符串我们将它称作 JWT 的 Payload（载荷）。</p><pre><code>const base64url = require("base64url");let payload = &amp;#123;  id: "49a9dd505c9d11e8b5e86b9776bb3c4f",  iat: 1526871579,  exp: 1526875179&amp;#125;;console.log("payload: " + base64url(JSON.stringify(payload)));// payload: eyJpZCI6IjQ5YTlkZDUwNWM5ZDExZThiNWU4NmI5Nzc2YmIzYzRmIiwiaWF0IjoxNTI2ODcxNTc5LCJleHAiOjE1MjY4NzUxNzl9</code></pre><p><strong>签名（Signature）</strong></p><p>将上面的两个编码后的字符串都用句号.连接在一起（头部在前），就形成了:</p><pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6IjQ5YTlkZDUwNWM5ZDExZThiNWU4NmI5Nzc2YmIzYzRmIiwiaWF0IjoxNTI2ODcxNTc5LCJleHAiOjE1MjY4NzUxNzl9</code></pre><p>最后，我们将上面拼接完的字符串用 HS256 算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。我们可以使用 <a href="https://github.com/brianloveswords/node-jwa">node-jwa</a> 进行 HS256 算法加密。如果我们用 123456 作为密钥的话，那么就可以得到我们加密后的内容，这一部分又叫做签名。最后一步签名的过程，实际上是对头部以及载荷内容进行签名。</p><p><img src="https://blog.leapoahead.com/2015/09/06/understanding-jwt/sig1.png"></p><pre><code>const jwa = require("jwa");const hmac = jwa("HS256");let secret = "123456";const signature = hmac.sign(  "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6IjQ5YTlkZDUwNWM5ZDExZThiNWU4NmI5Nzc2YmIzYzRmIiwiaWF0IjoxNTI2ODcxNTc5LCJleHAiOjE1MjY4NzUxNzl9",  secret);console.log("signature: " + signature);// signature: JtrTx9QaN3BD1QkZhY58MTu6WHn\_vQwRBxO9VwJgkhE</code></pre><p>最后将这一部分签名也拼接在被签名的字符串后面，我们就得到了完整的 JWT，如下：</p><pre><code>eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6IjQ5YTlkZDUwNWM5ZDExZThiNWU4NmI5Nzc2YmIzYzRmIiwiaWF0IjoxNTI2ODcxNTc5LCJleHAiOjE1MjY4NzUxNzl9.JtrTx9QaN3BD1QkZhY58MTu6WHn\_vQwRBxO9VwJgkhE</code></pre><p>整个完整过程走下来我们需要思考一下问题，Token 是否安全，是否可以传输敏感信息？</p><p>我们现在明白了一个 token 是由 Header 的 Base64 编码 + Payload 的 Base64 编码 + Signature 三段组成，当其他人拿到我们的 Token，可以通过 Token 前两段 Base64 解码得到 Header 和 Payload 对象，这里我们通过 <a href="https://github.com/auth0/node-jsonwebtoken">node-jsonwebtoken</a> 模块 decode 方法直接 “破解” 我们的 Token。</p><pre><code>const jwt = require("jsonwebtoken");let decoded = jwt.decode(  "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6IjQ5YTlkZDUwNWM5ZDExZThiNWU4NmI5Nzc2YmIzYzRmIiwiaWF0IjoxNTI2ODcxNTc5LCJleHAiOjE1MjY4NzUxNzl9.JtrTx9QaN3BD1QkZhY58MTu6WHn\_vQwRBxO9VwJgkhE",  &amp;#123; complete: true &amp;#125;);console.log("jsonwebtoken: " + JSON.stringify(decoded));// jsonwebtoken: &amp;#123;"header":&amp;#123;"typ":"JWT","alg":"HS256"&amp;#125;,"payload":&amp;#123;"id":"49a9dd505c9d11e8b5e86b9776bb3c4f","iat":1526871579,"exp":1526875179&amp;#125;,"signature":"JtrTx9QaN3BD1QkZhY58MTu6WHn\_vQwRBxO9VwJgkhE"&amp;#125;</code></pre><p>所以我们的 payload 不能里面不能包含诸如密码这种敏感信息，对于我们这里的 id 是一串 uuid，即使拿到也无法直接判定相关内容，从而不会直接泄露我们的内容。</p><p>一般而言，加密算法对于不同的输入产生的输出总是不一样的。对于两个不同的输入，产生同样的输出的概率极其地小。如果有人对头部以及载荷的内容解码之后进行修改，再进行编码的话，那么新的头部和载荷的签名和之前的签名就将是不一样的，而且如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的。</p><p>所以服务端拿到 JWT 后，首先会校验签名是否过期，以及对头部和载荷的内容用同一算法（通过 JWT 的头部 alg 字段指定）再次签名得到的 JWT 和用户传递的 JWT 是否一致。如果服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个 Token 的内容被别人动过的，我们应该拒绝这个 Token，返回一个 HTTP 401 Unauthorized 响应。</p><h3 id="egg-jwt-插件"><a href="#egg-jwt-插件" class="headerlink" title="egg-jwt 插件"></a>egg-jwt 插件</h3><p>文档：<a href="https://github.com/okoala/egg-jwt">https://github.com/okoala/egg-jwt</a></p><p>egg-jwt 基于 <a href="https://github.com/auth0/node-jsonwebtoken">node-jsonwebtoken</a> 实现，完整文档可以参考 <a href="https://github.com/auth0/node-jsonwebtoken">https://github.com/auth0/node-jsonwebtoken</a> 。jwt 对象挂载在 app 对象下，可以通过 app.jwt 访问 jwt 的三个方法：</p><ul><li>jwt.sign(payload, secretOrPrivateKey, [options, callback])————生成 token 字符串</li><li>jwt.verify(token, secretOrPublicKey, [options, callback])————校验 token 合法性</li><li>jwt.decode(token [, options])————token 译码</li></ul><p><strong>安装：</strong></p><pre><code>$ npm i egg-jwt --save</code></pre><p><strong>配置：</strong></p><pre><code>app/config/plugin.js 配置：exports.jwt = &amp;#123;  enable: true,  package: "egg-jwt"&amp;#125;;app/config/config.default.js 配置：exports.jwt = &amp;#123;  enable: false,  secret: "xxxxxxxxxxxxx"&amp;#125;;</code></pre><p><strong>调用：</strong></p><p>请求头：</p><pre><code>Authorization: Bearer &amp;#123;access\_token&amp;#125;</code></pre><p>注：access_token 为登录后返回的 token 值。</p><pre><code>app/service/user.js：/\*\* \* 生成 Token \* @param &amp;#123;Object&amp;#125; data \*/createToken(data) &amp;#123;  return app.jwt.sign(data, app.config.jwt.secret, &amp;#123;    expiresIn: "12h"  &amp;#125;);&amp;#125;/\*\* \* 验证token的合法性 \* @param &amp;#123;String&amp;#125; token \*/verifyToken(token) &amp;#123;  return new Promise((resolve, reject) =&gt; &amp;#123;    app.jwt.verify(token, app.config.jwt.secret, function(err, decoded) &amp;#123;      let result = &amp;#123;&amp;#125;;      if (err) &amp;#123;        /\*          err = &amp;#123;            name: 'TokenExpiredError',            message: 'jwt expired',            expiredAt: 1408621000          &amp;#125;        \*/        result.verify = false;        result.message = err.message;      &amp;#125; else &amp;#123;        result.verify = true;        result.message = decoded;      &amp;#125;      resolve(result);    &amp;#125;);  &amp;#125;);&amp;#125;extend/helper.js：// 获取 Tokenexports.getAccessToken = ctx =&gt; &amp;#123;  let bearerToken = ctx.request.header.authorization;  return bearerToken &amp;&amp; bearerToken.replace("Bearer ", "");&amp;#125;;// 校验 Tokenexports.verifyToken = async (ctx, userId) =&gt; &amp;#123;  let token = this.getAccessToken(ctx);  let verifyResult = await ctx.service.user.verifyToken(token);  if (!verifyResult.verify) &amp;#123;    ctx.helper.error(ctx, 401, verifyResult.message);    return false;  &amp;#125;  if (userId != verifyResult.message.id) &amp;#123;    ctx.helper.error(ctx, 401, "用户 ID 与 Token 不一致");    return false;  &amp;#125;  return true;&amp;#125;;// 处理成功响应exports.success = (ctx, result = null, message = "请求成功", status = 200) =&gt; &amp;#123;  ctx.body = &amp;#123;    code: 0,    message: message,    data: result  &amp;#125;;  ctx.status = status;&amp;#125;;// 处理失败响应exports.error = (ctx, code, message) =&gt; &amp;#123;  ctx.body = &amp;#123;    code: code,    message: message  &amp;#125;;  ctx.status = code;&amp;#125;;controller 中调用：// 生成Tokenlet token = ctx.service.user.createToken(&amp;#123; id: user.id &amp;#125;);// 校验Token合法性let isVerify = await ctx.helper.verifyToken(ctx, id);if (isVerify) &amp;#123;  // 合法逻辑  // ...&amp;#125;</code></pre><p>这样对于需要进行身份认证的 restful API，就可以通过 token 进行认证，从而实现用户认证和授权。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.leapoahead.com/2015/09/06/understanding-jwt/">JSON Web Token - 在 Web 应用间安全地传递信息</a></li><li><a href="https://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt/">八幅漫画理解使用 JSON Web Token 设计单点登录系统</a></li></ul><p>【转自】<a href="https://zhaomenghuan.js.org/blog/nodejs-eggjs-usersytem.html">https://zhaomenghuan.js.org/blog/nodejs-eggjs-usersytem.html</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github+matery搭建自己的个人博客</title>
      <link href="/blog/other/20200731001/"/>
      <url>/blog/other/20200731001/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前用<code>wordpress</code>折腾了个博客，服务器、域名、备案、<code>docker</code>、乱七八糟的折腾了好久，现在推荐一个生成静态网站的工具，用来写博客，简直不需要太爽，<code>Hexo</code>配合<code>github</code>以及配合 <code>Travis CI</code> 工具自动打包，happy啊…..</p></blockquote><p><strong>本人用的是mac，windows大同小异，水平有限，有毛病随时交流哈…….</strong></p><p><a href="https://hexo.io/zh-cn/docs/">Hexo 官网地址</a></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>本地开发环境先装上<code>node</code>以及<code>git</code>,具体安装方式自行<strong>百度</strong></p><h2 id="本地部分"><a href="#本地部分" class="headerlink" title="本地部分"></a>本地部分</h2><h3 id="1-全局安装hexo-cli"><a href="#1-全局安装hexo-cli" class="headerlink" title="1.全局安装hexo-cli"></a>1.全局安装<code>hexo-cli</code></h3><pre><code>npm install -g hexo-cli</code></pre><h3 id="2-进入一个本地文件夹，初始化hexo"><a href="#2-进入一个本地文件夹，初始化hexo" class="headerlink" title="2.进入一个本地文件夹，初始化hexo"></a>2.进入一个本地文件夹，初始化hexo</h3><ul><li><p>初始化hexo</p><pre><code>//名字随便取，我已经部署过blog了，这里用delfinohexo init delfino</code></pre></li><li><p>初始化后，进入该目录，安装依赖</p><pre><code>cd delfinonpm install</code></pre></li><li><p>安装完了之后就是启动服务了</p><pre><code>hexo server//端口默认4000//可以指定端口运行，如下：hexo server -p 5000//自定义IPhexo server -i 192.168.1.1</code></pre></li><li><p>浏览器打开试一下是否成功<a href="http://localhost:4000/">http://localhost:4000/</a></p></li><li><p>初始化本地的git仓库，方便提交到github</p><pre><code>git init</code></pre></li></ul><h2 id="github部分"><a href="#github部分" class="headerlink" title="github部分"></a>github部分</h2><h3 id="1-创建一个test的仓库"><a href="#1-创建一个test的仓库" class="headerlink" title="1.创建一个test的仓库"></a>1.创建一个test的仓库</h3><p><strong>没有github的自行注册</strong><br><img src="https://imgkr2.cn-bj.ufileos.com/62a22056-41b2-471f-9f5a-4b8dc5b69d12.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;Signature=MvsPE6RgxjzEuwe9FKdobURcCzY%253D&amp;Expires=1596260088"></p><p>仓库选择公开，点击创建,成功后如下图：<br><img src="https://imgkr2.cn-bj.ufileos.com/b13b351b-a714-4de2-bf6d-489284e2c5c9.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;Signature=IcuuD6bkJCLeyqSi8wKqKYUveQE%253D&amp;Expires=1596260163"></p><h3 id="2-将本地的项目推送到github"><a href="#2-将本地的项目推送到github" class="headerlink" title="2.将本地的项目推送到github"></a>2.将本地的项目推送到github</h3><pre><code>//进入本地项目目录git remote add origin https://github.com/simple-delfino/delfino.gitgit add .git commit -m "提交Hexo"//第一次提交到github上加上 -ugit push -u origin master//后面如果需要提交,直接git push origin master</code></pre><h2 id="Travis-CI-部分"><a href="#Travis-CI-部分" class="headerlink" title="Travis CI 部分"></a>Travis CI 部分</h2><h3 id="1-将-Travis-CI添加到你的-GitHub-账户中。"><a href="#1-将-Travis-CI添加到你的-GitHub-账户中。" class="headerlink" title="1.将 Travis CI添加到你的 GitHub 账户中。"></a>1.将 <a href="https://github.com/marketplace/travis-ci">Travis CI</a>添加到你的 GitHub 账户中。</h3><p>进入到Travis CI官网，安装：<br><img src="https://imgkr2.cn-bj.ufileos.com/9ba11bb0-9413-46d7-a1f8-6f5c48fb8db1.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;Signature=O4xCHESMyn0IlX%252FADr%252FlIIBCwfU%253D&amp;Expires=1596260569"><br><strong>进入官网往下翻，看到如上图的位置，选择Open Source，你有钱当我没说，安装</strong></p><h3 id="2-配置-Travis-CI-权限"><a href="#2-配置-Travis-CI-权限" class="headerlink" title="2.配置 Travis CI 权限"></a>2.配置 Travis CI 权限</h3><p><strong>前往 <code>GitHub</code> 的 Applications settings，配置 Travis CI 权限，使其能够访问你的 repository。</strong><br><img src="https://imgkr2.cn-bj.ufileos.com/6e2f5bc0-59cc-4596-9507-6ca7f1ea1c67.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;Signature=N6Ya6o%252B4T5pk8Jg9AY1Bl8RRDYs%253D&amp;Expires=1596260819"></p><ul><li>点击Travis CI的<strong>Configure</strong><br><img src="https://imgkr2.cn-bj.ufileos.com/a9c5202b-e4fc-4dde-9367-5367cf3ef70b.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;Signature=bOkr3%252F%252F0S7gRG51DmfxP4PP%252F%252BgY%253D&amp;Expires=1596260979"></li><li>设置<strong>Repository access</strong>，我这里选择了All repositories，你也可以只选择你当前的博客仓库，随意，点击保存<br><img src="https://imgkr2.cn-bj.ufileos.com/4ca0f55c-042d-4d70-be7e-96ec4e61cecc.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;Signature=WIWTMojc%252FrdZ3X8D8oM37NRLRZc%253D&amp;Expires=1596261107"></li></ul><h3 id="3-Travis-CI-的页面"><a href="#3-Travis-CI-的页面" class="headerlink" title="3.Travis CI 的页面"></a>3.Travis CI 的页面</h3><p><strong>你应该会被重定向到 Travis CI 的页面。如果没有，请 <a href="https://travis-ci.com/dashboard">手动前往</a>。</strong></p><h3 id="4-新建-Personal-Access-Token"><a href="#4-新建-Personal-Access-Token" class="headerlink" title="4.新建 [Personal Access Token]"></a>4.新建 [Personal Access Token]</h3><p><strong>在浏览器新建一个标签页，前往 GitHub 新建 <a href="https://github.com/settings/tokens">Personal Access Token</a>，只勾选 repo 的权限并生成一个新的 Token。Token 生成后请复制并保存好。</strong><br><img src="https://imgkr2.cn-bj.ufileos.com/e1bc538f-7d14-4db3-ac2c-7868ecdc698d.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;Signature=BVrIY1dRyntKvma7sjdlKZd01Gs%253D&amp;Expires=1596261375"></p><h3 id="5-新建Token环境变量"><a href="#5-新建Token环境变量" class="headerlink" title="5.新建Token环境变量"></a>5.新建Token环境变量</h3><p><strong>回到 Travis CI，前往你的 repository 的设置页面，在 Environment Variables 下新建一个环境变量，Name 为 GH_TOKEN，Value 为刚才你在 GitHub 生成的 Token。确保 DISPLAY VALUE IN BUILD LOG 保持 不被勾选 避免你的 Token 泄漏。点击 Add 保存</strong><br><img src="https://imgkr2.cn-bj.ufileos.com/6c00b26b-cb7c-4ac0-a6a6-19130f0178ab.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;Signature=FK1V%252F07RYKyDIdZ32d%252FfZn2BF6I%253D&amp;Expires=1596261478"></p><p><img src="https://imgkr2.cn-bj.ufileos.com/e4db1191-5315-4be4-ad98-9df9dec5ba99.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;Signature=HD45NxNDxL%252B0qVy4Nbto%252FoPjrV0%253D&amp;Expires=1596261591"></p><h3 id="6-新建-travis-yml"><a href="#6-新建-travis-yml" class="headerlink" title="6.新建.travis.yml"></a>6.新建.travis.yml</h3><p><strong>在你的 Hexo 站点文件夹中新建一个 .travis.yml 文件：</strong></p><pre><code>sudo: falselanguage: node_jsnode_js:  - 10 # use nodejs v10 LTScache: npmbranches:  only:    - master # build master branch onlyscript:  - hexo generate # generate static filesdeploy:  provider: pages  skip-cleanup: true  github-token: $GH_TOKEN  keep-history: true  on:    branch: master  local-dir: public</code></pre><h3 id="7-设置url"><a href="#7-设置url" class="headerlink" title="7.设置url"></a>7.设置url</h3><p><strong>编辑本地项目的<code>_config.yml</code>,修改如下：</strong></p><pre><code>url: https://simple-delfino.github.io/delfinoroot: /delfino</code></pre><h3 id="8-将-travis-yml以及修改的-config-yml推送到-repository-中。"><a href="#8-将-travis-yml以及修改的-config-yml推送到-repository-中。" class="headerlink" title="8.将 .travis.yml以及修改的_config.yml推送到 repository 中。"></a>8.将 .travis.yml以及修改的_config.yml推送到 repository 中。</h3><p>Travis CI 应该会自动开始运行，并将生成的文件推送到同一 repository 下的 gh-pages 分支下</p><pre><code>git add .git commit -m 'push .travis.yml'git push origin master</code></pre><h3 id="9-修改-GitHub-Pages-的部署分支为-gh-pages"><a href="#9-修改-GitHub-Pages-的部署分支为-gh-pages" class="headerlink" title="9.修改 GitHub Pages 的部署分支为 gh-pages"></a>9.修改 GitHub Pages 的部署分支为 gh-pages</h3><p>在 GitHub 中前往你的 repository 的设置页面，修改 GitHub Pages 的部署分支为 gh-pages</p><h3 id="10-尝试访问"><a href="#10-尝试访问" class="headerlink" title="10.尝试访问"></a>10.尝试访问</h3><p>前往 https://&lt;你的github用户名&gt;.github.io/&lt;博客仓库目录&gt;,eg:<a href="https://simple-delfino.github.io/delfino">https://simple-delfino.github.io/delfino</a> 查看你的站点是否可以访问。这可能需要一些时间。<br><img src="https://imgkr2.cn-bj.ufileos.com/97115fac-535b-442c-94f6-5583004a083b.jpg?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;Signature=uv0qrk%252FXj9p1mWJqW4npVInaHyQ%253D&amp;Expires=1596262739"></p><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>默认的主题有点丑，可以自己安装主题，我自己现在用的是matery，可以从我的<a href="https://simple-delfino.github.io/blog/">博客</a>上看效果,<br>当然beauty也不错，还有其他的极简风格的黑白主题，去百度搜索吧</p><h3 id="1-下载matery"><a href="#1-下载matery" class="headerlink" title="1.下载matery"></a>1.下载matery</h3><p><a href="https://github.com/blinkfox/hexo-theme-matery">matery地址</a></p><p>进入到本地项目的theme目录下</p><pre><code>cd themegit clone https://github.com/blinkfox/hexo-theme-matery.git</code></pre><h3 id="2-切换主题"><a href="#2-切换主题" class="headerlink" title="2.切换主题"></a>2.切换主题</h3><p>修改 Hexo 根目录下的 _config.yml 的 <code>theme</code> 的值：<code>theme: hexo-theme-matery</code></p><h3 id="3-新建分类-categories-页"><a href="#3-新建分类-categories-页" class="headerlink" title="3.新建分类 categories 页"></a>3.新建分类 categories 页</h3><p>categories 页是用来展示所有分类的页面，如果在你的博客 source 目录下还没有 categories/index.md 文件，那么你就需要新建一个，命令如下：</p><pre><code>hexo new page "categories"</code></pre><p>编辑你刚刚新建的页面文件 /source/categories/index.md，至少需要以下内容：</p><pre><code>---title: categoriesdate: 2018-09-30 17:25:30type: "categories"layout: "categories"---</code></pre><h3 id="4-新建标签-tags-页"><a href="#4-新建标签-tags-页" class="headerlink" title="4.新建标签 tags 页"></a>4.新建标签 tags 页</h3><p>tags 页是用来展示所有标签的页面，如果在你的博客 source 目录下还没有 tags/index.md 文件，那么你就需要新建一个，命令如下：</p><pre><code>hexo new page "tags"</code></pre><p>编辑你刚刚新建的页面文件 /source/tags/index.md，至少需要以下内容：</p><pre><code>---title: tagsdate: 2018-09-30 18:23:38type: "tags"layout: "tags"---</code></pre><h3 id="5-新建关于我-about-页"><a href="#5-新建关于我-about-页" class="headerlink" title="5.新建关于我 about 页"></a>5.新建关于我 about 页</h3><p>about 页是用来展示关于我和我的博客信息的页面，如果在你的博客 source 目录下还没有 about/index.md 文件，那么你就需要新建一个，命令如下：</p><pre><code>hexo new page "about"</code></pre><p>编辑你刚刚新建的页面文件 /source/about/index.md，至少需要以下内容：</p><pre><code>---title: aboutdate: 2018-09-30 17:25:30type: "about"layout: "about"---</code></pre><h3 id="6-新建留言板-contact-页（可选的）"><a href="#6-新建留言板-contact-页（可选的）" class="headerlink" title="6.新建留言板 contact 页（可选的）"></a>6.新建留言板 contact 页（可选的）</h3><p>contact 页是用来展示留言板信息的页面，如果在你的博客 source 目录下还没有 contact/index.md 文件，那么你就需要新建一个，命令如下：</p><pre><code>hexo new page "contact"</code></pre><p>编辑你刚刚新建的页面文件 /source/contact/index.md，至少需要以下内容：</p><pre><code>---title: contactdate: 2018-09-30 17:25:30type: "contact"layout: "contact"---</code></pre><blockquote><p>注：本留言板功能依赖于第三方评论系统，请激活你的评论系统才有效果。并且在主题的 _config.yml 文件中，第 19 至 21 行的“菜单”配置，取消关于留言板的注释即可。</p></blockquote><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>hexo还是比较好用的，其他的设置自己捉摸吧<br>比如文章的永久链接，我用的是</p><pre><code>url: https://simple-delfino.github.io/blogroot: /blogpermalink: :category/:id/permalink_defaults:</code></pre><p>当然你文章的<code>Front-matter</code>必须有<code>category</code>和<code>id</code>(id我就是固定的数字，年月日+001或者002)</p><p>其他的配置自己折腾吧，<code>hexo</code>的配置在根目录下的<code>_config.yml</code>，主题的配置在该主题目录下的<code>_config.yml</code>，有一些比较好玩的优化，比如每日一句等等 去百度吧</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack性能优化</title>
      <link href="/blog/other/20200730003/"/>
      <url>/blog/other/20200730003/</url>
      
        <content type="html"><![CDATA[<h1 id="1-剔除不必要的代码"><a href="#1-剔除不必要的代码" class="headerlink" title="1. 剔除不必要的代码"></a>1. 剔除不必要的代码</h1><h2 id="1-1-引入未使用"><a href="#1-1-引入未使用" class="headerlink" title="1.1 引入未使用"></a>1.1 引入未使用</h2><p>对于js，tree-shaking 贯穿整个依赖树，检查被使用的依赖，移除无用的依赖。 对于css,purifycss-webpack未使用的css不会被打包进来</p><h2 id="1-2-避免重复引入"><a href="#1-2-避免重复引入" class="headerlink" title="1.2 避免重复引入"></a>1.2 避免重复引入</h2><h3 id="1-2-1-externals"><a href="#1-2-1-externals" class="headerlink" title="1.2.1 externals"></a>1.2.1 externals</h3><p>(1)使用变量或外部引用来引入模块，如果两个模块有公共部分，比如jquery，可以避免重复下载。只需在入口.html文件中，使用script引入即可。</p><p>(2)将模块挂载到window上，减少重复的请求模块。配置：</p><pre><code>module.exports = &amp;#123;    externals: &amp;#123;    'react': 'React',    'react-dom': 'ReactDOM',    &amp;#125;,&amp;#125;;复制代码</code></pre><h3 id="1-2-2-CommonsChunkPlugin"><a href="#1-2-2-CommonsChunkPlugin" class="headerlink" title="1.2.2 CommonsChunkPlugin"></a>1.2.2 CommonsChunkPlugin</h3><p>提取公共部分。webpack4之后使用optimization.splitChunks代替。</p><h2 id="1-3-避免执行依赖模块的无用代码"><a href="#1-3-避免执行依赖模块的无用代码" class="headerlink" title="1.3 避免执行依赖模块的无用代码"></a>1.3 避免执行依赖模块的无用代码</h2><p>很多模块在生产production模式都会有一些警示性代码，如下图，而这类代码在实际环境中，并没什么用，却占用着资源。使用webpack的DefinePlugin可以解决这个问题。或者使用webpack.EnvironmentPlugin起到类似作用。参考：<a href="https://webpack.js.org/plugins/environment-plugin/">webpack.js.org/plugins/env…</a></p><pre><code>//将process.env.NODE_ENV替换成production。new webpack.DefinePlugin(&amp;#123;'process.env.NODE_ENV': '"production"',&amp;#125;),//上图里面的代码会变成：if("production" !== 'production')&amp;#123;//永远为false，不会进入分支    .......&amp;#125;复制代码</code></pre><h2 id="1-4-避免构建不必要的代码"><a href="#1-4-避免构建不必要的代码" class="headerlink" title="1.4 避免构建不必要的代码"></a>1.4 避免构建不必要的代码</h2><p>loader时，使用exclude将不必要的文件去除，或者include将需要的文件加进来。</p><h1 id="2-资源压缩"><a href="#2-资源压缩" class="headerlink" title="2. 资源压缩"></a>2. 资源压缩</h1><h2 id="2-1-js压缩"><a href="#2-1-js压缩" class="headerlink" title="2.1 js压缩"></a>2.1 js压缩</h2><h3 id="2-1-1-babel-minify-webpack-plugin"><a href="#2-1-1-babel-minify-webpack-plugin" class="headerlink" title="2.1.1 babel-minify-webpack-plugin"></a>2.1.1 babel-minify-webpack-plugin</h3><p>loader的时候由于文件大小通常非常大，所以会慢很多，所以这个插件有个作用，就是可以在loader的时候进行优化，减少一定的文件体积。</p><h3 id="2-1-2-uglifyjs-webpack-plugin"><a href="#2-1-2-uglifyjs-webpack-plugin" class="headerlink" title="2.1.2 uglifyjs-webpack-plugin"></a>2.1.2 uglifyjs-webpack-plugin</h3><p>js后处理，具有剔除注释、代码压缩等功能。</p><h2 id="2-2-css压缩"><a href="#2-2-css压缩" class="headerlink" title="2.2 css压缩"></a>2.2 css压缩</h2><h3 id="2-2-1-optimize-css-assets-webpack-plugin"><a href="#2-2-1-optimize-css-assets-webpack-plugin" class="headerlink" title="2.2.1 optimize-css-assets-webpack-plugin"></a>2.2.1 optimize-css-assets-webpack-plugin</h3><p>css后处理，可以将注释剔除、css代码压缩等。</p><h2 id="2-3-图片资源压缩"><a href="#2-3-图片资源压缩" class="headerlink" title="2.3 图片资源压缩"></a>2.3 图片资源压缩</h2><h3 id="2-3-1-image-webpack-loader"><a href="#2-3-1-image-webpack-loader" class="headerlink" title="2.3.1 image-webpack-loader"></a>2.3.1 image-webpack-loader</h3><p>压缩图片的作用。配合url-loader/svg-url-loader使用。</p><h2 id="2-4-gzip压缩"><a href="#2-4-gzip压缩" class="headerlink" title="2.4 gzip压缩"></a>2.4 gzip压缩</h2><p>CompressionWebpackPlugin将最后的资源进行gzip压缩，减少体积。</p><h1 id="3-减少网络请求"><a href="#3-减少网络请求" class="headerlink" title="3. 减少网络请求"></a>3. 减少网络请求</h1><h2 id="3-1-图片资源压缩和内联"><a href="#3-1-图片资源压缩和内联" class="headerlink" title="3.1 图片资源压缩和内联"></a>3.1 图片资源压缩和内联</h2><p>url-loader/svg-url-loader/image-webpack-loader url-loader/svg-url-loader设置一定大小内，图片使用内联方式插入html代码中，内联减少了http请求的数量。 image-webpack-loader有压缩图片的作用。</p><h1 id="4-懒加载"><a href="#4-懒加载" class="headerlink" title="4. 懒加载"></a>4. 懒加载</h1><h2 id="4-1-模块按需引入"><a href="#4-1-模块按需引入" class="headerlink" title="4.1 模块按需引入"></a>4.1 模块按需引入</h2><p>比如点击事情，需要用到两一个模块中的Function，只在点击的时候引入这个模块中的Function</p><h2 id="4-2-组件按需引入"><a href="#4-2-组件按需引入" class="headerlink" title="4.2 组件按需引入"></a>4.2 组件按需引入</h2><p>只在页面跳转后，将路由所需的组件加载进来，而不是在第一次刷新的时候，将所有组件都加载到一个文件中，避免文件体积过于庞大，且未使用的时候都算暂时无用的代码。</p><h1 id="5-提高构建速度"><a href="#5-提高构建速度" class="headerlink" title="5. 提高构建速度"></a>5. 提高构建速度</h1><h2 id="5-1-预编译"><a href="#5-1-预编译" class="headerlink" title="5.1 预编译"></a>5.1 预编译</h2><h3 id="5-1-1-dllplugin-amp-DllRefrencePlugin"><a href="#5-1-1-dllplugin-amp-DllRefrencePlugin" class="headerlink" title="5.1.1 dllplugin&amp;DllRefrencePlugin"></a>5.1.1 dllplugin&amp;DllRefrencePlugin</h3><p>DllPlugin结合DllRefrencePlugin插件的运用，对将要产出的bundle文件进行拆解 打包，将公共静态资源拆分打包，可以彻底地加快webpack的打包速度，从而在开发过程中极大地缩减构建时间。之后不管是dev还是production不会重复打包这部分静态资源，大大缩减了构建时间。</p><h3 id="5-1-2-ModuleConcatenationPlugin"><a href="#5-1-2-ModuleConcatenationPlugin" class="headerlink" title="5.1.2 ModuleConcatenationPlugin"></a>5.1.2 ModuleConcatenationPlugin</h3><p>打包的时候，它将一些有联系的模块，放到一个闭包函数里面去，通过减少闭包函数数量从而加快JS的执行速度。</p><h2 id="5-2-多核并行"><a href="#5-2-多核并行" class="headerlink" title="5.2 多核并行"></a>5.2 多核并行</h2><p>在多核电脑上，HappyPack能将任务拆分成多个子进程并发的执行，提高构建速度。 webpack-uglify-parallel也是并行的方式，提升uslifyPlugin的构建速度。</p><h2 id="5-3-减少搜索"><a href="#5-3-减少搜索" class="headerlink" title="5.3 减少搜索"></a>5.3 减少搜索</h2><h3 id="5-3-1-Resolve-module-amp-resolve-alias"><a href="#5-3-1-Resolve-module-amp-resolve-alias" class="headerlink" title="5.3.1 Resolve.module&amp;resolve.alias"></a>5.3.1 Resolve.module&amp;resolve.alias</h3><p>配置webpack去哪里寻找第三方，减少搜索遍历时间损耗。 resolve.alias设置别名，减少搜索路径的时间损耗。</p><h2 id="5-4-devtool"><a href="#5-4-devtool" class="headerlink" title="5.4 devtool"></a>5.4 devtool</h2><p>配置souce-map为合适的值，有的会比较耗时。</p><h1 id="6-自动化监控工具"><a href="#6-自动化监控工具" class="headerlink" title="6. 自动化监控工具"></a>6. 自动化监控工具</h1><h2 id="6-1-webpack-bundle-analyzer"><a href="#6-1-webpack-bundle-analyzer" class="headerlink" title="6.1 webpack-bundle-analyzer"></a>6.1 webpack-bundle-analyzer</h2><p>一个项目，大部分代码来自于依赖的模块，依赖的大小严重影响着项目构建包的大小。webpack-bundle-analyzer分析依赖之间的关系，能清晰看到使用到哪些依赖及对应的大小。可以帮助我们有针对性的去优化使用那些体积大的依赖。该工具会在浏览器中打开一个窗口，展示依赖图。</p><h2 id="6-2-webpack-dashboard"><a href="#6-2-webpack-dashboard" class="headerlink" title="6.2 webpack-dashboard"></a>6.2 webpack-dashboard</h2><p>是增强控制台用户体验的一款工具。dashboard里面按日志(Log)、状态(Status)、运行(Operation)、过程(Progess)、模块(Modules)、产出(Assets)这6个部分将信息按区展示。</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/12/16c83c50b451875e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h2 id="6-3-bundlesize"><a href="#6-3-bundlesize" class="headerlink" title="6.3 bundlesize"></a>6.3 bundlesize</h2><p>设置类型文件的最大大小，当超出范围，会给与警告和提示，帮助分析那些模块体积过大。</p><p><a href="https://juejin.im/post/6844903910973374478">转自 【掘金**~cyndarila**】</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞定Node.js流 （Stream）</title>
      <link href="/blog/backend/20200730004/"/>
      <url>/blog/backend/20200730004/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一直不太理解 Node.js 中 Stream 的概念，最近深入学习了一下，争取一篇文章说清楚。 文章中的代码地址：<a href="https://github.com/Maricaya/node-stream">github.com/Maricaya/no…</a></p></blockquote><h1 id="Stream-流是什么？"><a href="#Stream-流是什么？" class="headerlink" title="Stream 流是什么？"></a>Stream 流是什么？</h1><p>stream（流）是一种抽象的数据结构。就像数组或字符串一样，流是数据的集合。</p><p>不同的是，流可以每次输出少量数据，而且它不用存在内存中。</p><p>比如，对服务器发起 http 请求的 <code>request/response</code> 对象就是 Stream。</p><h2 id="图解-Stream"><a href="#图解-Stream" class="headerlink" title="图解 Stream"></a>图解 Stream</h2><p>stream 就像是水流，但默认是没有水的。 stream.write 可以让水流中有水，也就是写入数据。</p><p>左上角是产生数据的一段，称为 source（源头）。 最下面是得到数据的一段 sink（水池）。 从上向下流动的小圆点是每次写的小数据，称为 chunk（块）。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/173869cb08686702?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h2 id="为什么需要-Stream"><a href="#为什么需要-Stream" class="headerlink" title="为什么需要 Stream"></a>为什么需要 Stream</h2><p>同学们可能有这样的疑问，流的作用不就是传递数据吗，不用流 node 也可以实现读写操作啊。</p><p>是的，但是读写方式是把文件内容全部读入内存，然后再写入文件，小型文件这么处理问题不大。</p><p>但是遇到较大的文件，实在承受不住。</p><p>而流可以把文件资源拆分成小块，一块一块的运输，资源就像水流一样进行传输，减轻服务器压力。</p><h1 id="Stream-实例"><a href="#Stream-实例" class="headerlink" title="Stream 实例"></a>Stream 实例</h1><p>可能这么描述并不能让大家信服， 我们来做一个试验，看看在读写大文件时有没有必要使用流。</p><p>首先创建一个大文件：</p><h2 id="用-Stream-创建大文件"><a href="#用-Stream-创建大文件" class="headerlink" title="用 Stream 创建大文件"></a>用 Stream 创建大文件</h2><p>我们首先创建一个可写流，向文件里多次写入内容。 最后记得关闭流，得到一个大文件。</p><pre><code>// 引入文件模块const fs = require('fs');const stream = fs.createWriteStream('./../big_file.txt');for (let i = 0; i &lt; 1000000; i++) &amp;#123;  stream.write(`这是第$&amp;#123;i&amp;#125;行内容\n`);&amp;#125;stream.end()console.log('done')复制代码</code></pre><h2 id="使用-readFile"><a href="#使用-readFile" class="headerlink" title="使用 readFile"></a>使用 readFile</h2><p>我们先使用 fs.readFile 来读取文件内容，看看会发生什么。</p><pre><code>const fs = require('fs')const http = require('http')const server = http.createServer()server.on('request', (request, response) =&gt; &amp;#123;  fs.readFile('./../big_file.txt', (error, data) =&gt; &amp;#123;    if (error) throw error    response.end(data)    console.log('done')  &amp;#125;)&amp;#125;)server.listen(8889)console.log(8889)复制代码</code></pre><p>当我们访问 <code>http://localhost:8889</code> 的时候，服务器会异步读取这个大文件。</p><p>看起来一切正常，没什么毛病。</p><p>但是，我们用任务管理器查看 Node.js 的内存，大概占用 130Mb。</p><p>服务器接收 1 次请求，占用 130 Mb；那如果接受 10 次请求，就是占用 1G。 对服务器的内存消耗是很大的。</p><p>怎么解决这个问题呢？使用 Stream。</p><h2 id="使用-Stream"><a href="#使用-Stream" class="headerlink" title="使用 Stream"></a>使用 Stream</h2><p>我们来试试用 Stream 改写上面的例子。</p><p>创建一个可读流 <code>createReadStream</code>， 再把文件 <code>stream</code> 和 <code>response stream</code> 通过管道 <code>pipe</code> 相连。</p><pre><code>const fs = require('fs')const http = require('http')const server = http.createServer()server.on('request', (request, response) =&gt; &amp;#123;    const stream = fs.createReadStream('./big_file.txt')    stream.pipe(response)&amp;#125;)server.listen(8888)复制代码</code></pre><p>我们再次查看 node.js 内存占用，基本不会高于 30Mb。</p><p>因为每次只传递一小段数据，不会占用很大内存。</p><h1 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道 pipe"></a>管道 pipe</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/173869d998e4c5cf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>两个流可以用一个管道相连，stream1 的末尾连接上 stream2 的开端。</p><p>只要 stream1 有数据，就会流到 stream2。</p><p>比如上面的代码：</p><pre><code>const stream = fs.createReadStream('./big_file.txt')stream.pipe(response)复制代码</code></pre><p><code>stream</code> 就是一个文件流，下面的 stream 就是我们的 http 流 response。 本来这两个流是没有关系的，现在我们想把文件流的数据传递给 http 流。 很简单，用 pipe 连接就行啦。</p><h2 id="常用代码"><a href="#常用代码" class="headerlink" title="常用代码"></a>常用代码</h2><p><code>stream1.pipe(stream2)</code></p><ul><li>stream1 是发出数据的流，一个可读流。</li><li>stream2 是写入数据的流，一个可写流。</li></ul><h2 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h2><p>一个水流可以经过无限个管道，数据流也一样。</p><p>有两种写法：</p><pre><code>a.pipe(b).pipe(c)// 等价于a.pipe(b)b.pipe(c)复制代码</code></pre><h2 id="管道原理"><a href="#管道原理" class="headerlink" title="管道原理"></a>管道原理</h2><p>管道也可以认为是两个事件的封装</p><ul><li>监听 data 事件，stream1 一有数据就塞给 stream2</li><li>监听 end 事件，当 stream1 停了，就停掉 stream2</li></ul><pre><code>stream1.on('data', (chunk) =&gt; &amp;#123;    stream2.write(chunk)&amp;#125;)stream1.on('end', () =&gt; &amp;#123;    stream2.end()&amp;#125;)复制代码</code></pre><h1 id="Stream-对象的原型链"><a href="#Stream-对象的原型链" class="headerlink" title="Stream 对象的原型链"></a>Stream 对象的原型链</h1><p>了解 Stream 的原型链，可以更容易地记忆 Stream 的 API。</p><h2 id="fs-createReadStream-path"><a href="#fs-createReadStream-path" class="headerlink" title="fs.createReadStream(path)"></a>fs.createReadStream(path)</h2><p>如果 <code>s = fs.createReadStream(path)</code> ，那么<code>s</code>的对象层级为：</p><ol><li>自身的属性，由 <code>fs.ReadStream</code> 构造函数构造的</li><li>原型: <code>stream.Readable.prototype</code></li><li>二级原型: <code>stream.Stream.prototype</code></li><li>三级原型: <code>events.EventEmitter.prototype</code> 这是所有 Stream 都继承的原型</li><li>四级原型: <code>Object.prototype</code> 也就是所有对象都继承的原型</li></ol><h1 id="Stream-支持的事件和方法"><a href="#Stream-支持的事件和方法" class="headerlink" title="Stream 支持的事件和方法"></a>Stream 支持的事件和方法</h1><p>了解了原型链之，我们来看看 Stream 支持的事件和方法。</p><p>大概有个印象就好，用到的时候再去查。</p><table><thead><tr><th></th><th>Readable Stream</th><th>Writable Stream</th></tr></thead><tbody><tr><td>事件</td><td>data, end, error,close,readable</td><td>drain(这一次写完),finish(整个写完),error,close,pipe,unpipe</td></tr><tr><td>方法</td><td>pipe() unpipe() read()…</td><td>write() destroy() …</td></tr></tbody></table><h1 id="Stream-分类"><a href="#Stream-分类" class="headerlink" title="Stream 分类"></a>Stream 分类</h1><p>一共分为四类</p><table><thead><tr><th>名称</th><th>特点</th></tr></thead><tbody><tr><td>Readable</td><td>可读</td></tr><tr><td>Writable</td><td>可写</td></tr><tr><td>Duplex</td><td>可读可写（双向）</td></tr><tr><td>Transform</td><td>可读可写（变化）</td></tr></tbody></table><p>Readable、Writable 都是单向的，其他两个是双向的。</p><p>可读、可写好理解，剩下两个有什么区别呢？</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/173869e8a42d0879?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>Duplex 可以读写，但是读的内容和写的内容是相互独立的，没有交叉。</p><p>而 Transform 是自己写自己读。</p><p>比如一个 babel，把es6转换为，我们在左边写入 es6，从右边读取 es5。 就像洗车一样，黑车进去，白车出来。</p><h2 id="Readable-Stream-可读流"><a href="#Readable-Stream-可读流" class="headerlink" title="Readable Stream 可读流"></a>Readable Stream 可读流</h2><h3 id="静止态-paused-和流动态-flowing"><a href="#静止态-paused-和流动态-flowing" class="headerlink" title="静止态 paused 和流动态 flowing"></a>静止态 paused 和流动态 flowing</h3><p>可读流有两个状态 paused 和 flowing。</p><p>可以把可读流看成内容生产者，不发内容时就是静止态，内容恢复发送时就是流动态。</p><ul><li>可读流默认处于 paused 态。</li><li>一旦添加 data 事件监听，它就变为 flowing 态。</li><li>删掉 data 事件监听，paused 态。</li><li>pause() 可以将它变为 paused。</li><li>resume() 可以将它变为 flowing。</li></ul><pre><code>const http = require('http')const fs = require('fs')const server = http.createServer()server,on('request', (request, response) =&gt; &amp;#123;  // 默认处于 paused 态  const stream = fs.createReadStream('./big_file.txt')  stream.pipe(response)  stream.pause(); // 暂停  setTimeout(() =&gt; &amp;#123;  // 恢复    stream.resume()  &amp;#125;, 3000)&amp;#125;)server.listen(8888);复制代码</code></pre><h1 id="Writable-Stream"><a href="#Writable-Stream" class="headerlink" title="Writable Stream"></a>Writable Stream</h1><h2 id="drain-流干了事件"><a href="#drain-流干了事件" class="headerlink" title="drain 流干了事件"></a>drain 流干了事件</h2><p>表示可以加点水了，也就是可以继续写入数据了。 我们调用 <code>stream.write(chunk)</code> 的时候，可能会得到 false。</p><p>false 的意思是你写太快了，积压数据。</p><p>这个时候我们就不能再 write 了，要监听 drain。</p><p>等 drain 事件触发了，我们才能继续 write。</p><p>光看这些有点难以理解，可以看看 <a href="https://nodejs.org/api/stream.html#stream_event_drain">官网上的例子</a>：</p><pre><code>const fs = require('fs');// 将 data 写入文件 1000000 次function writeOneMillionTimes(writer, data) &amp;#123;  let i = 1000000;  write();  function write() &amp;#123;    let ok = true;    do &amp;#123;      i--;      if (i === 0) &amp;#123;        // 最后一次写入        writer.write(data);      &amp;#125; else &amp;#123;        // 在这里判断是不是可以继续写    // ok 为 false 的意思是你写太快了，数据积压        ok = writer.write(data);        if (ok === false) &amp;#123;          console.log('不能再写了')        &amp;#125;      &amp;#125;    &amp;#125; while (i &gt; 0 &amp;&amp; ok);    if (i &gt; 0) &amp;#123;      // 干涸了,可以继续写入       writer.once('drain', () =&gt; &amp;#123;        console.log('干涸了')        write()      &amp;#125;);    &amp;#125;  &amp;#125;&amp;#125;const write = fs.createWriteStream('./../big_file.txt')writeOneMillionTimes(write, 'hello world')复制代码</code></pre><h2 id="finish-事件"><a href="#finish-事件" class="headerlink" title="finish 事件"></a>finish 事件</h2><p>在调用 <code>stream.end()</code> 之后，而且缓冲区数据都已经传给底层系统之后，触发 finish 事件。</p><p>我们往文件中写入数据时，不是直接存入硬盘中，而是先放入缓冲区。 当数据到达一定大小后，才会写入硬盘。</p><h1 id="创建自己的流"><a href="#创建自己的流" class="headerlink" title="创建自己的流"></a>创建自己的流</h1><p>下面我们来看看，如何创建自己的流。</p><p>按照流的四个类型依次讲解。</p><h2 id="Writable"><a href="#Writable" class="headerlink" title="Writable"></a>Writable</h2><pre><code>const &amp;#123;Writable&amp;#125; = require('stream')const outStream = new Writable(&amp;#123;  // 如果别人调用，我们做什么  write(chunk, encoding, callback) &amp;#123;    console.log(chunk.toString())    // 进入下一个流程    callback()  &amp;#125;&amp;#125;)process.stdin.pipe(outStream);复制代码</code></pre><p>保存文件为 writable.js 然后用 node 运行。 不管你输入什么，都会得到相同的结果。</p><h2 id="Readable"><a href="#Readable" class="headerlink" title="Readable"></a>Readable</h2><h3 id="一次读取所有数据"><a href="#一次读取所有数据" class="headerlink" title="一次读取所有数据"></a>一次读取所有数据</h3><pre><code>const &amp;#123;Readable&amp;#125; = require('stream')const inStream = new Readable()inStream.push('hello world') // 写入数据inStream.push('hello node')inStream.push(null) // 没有数据了// 将这个可读流，导入到可写流 process.stdout。inStream.pipe(process.stdout)复制代码</code></pre><p>先把所有数据都 push 进 inStream，再使用管道导入到可写流 <code>process.stdout</code> 中。</p><p>这样，当我们用 node 运行文件时，我们可以从 inStream 中读取所有数据，并且打印出来。</p><p>这种方式非常简单，但是并不高效。</p><p>更好的方式是按需 push，当用户需要的时候，我们才读取数据。</p><h3 id="调用-read-才会给一次数据"><a href="#调用-read-才会给一次数据" class="headerlink" title="调用 read 才会给一次数据"></a>调用 read 才会给一次数据</h3><p>这种写法数据是按需供给的，对方调用 <code>read</code> ，我们才会给一次数据。</p><p>例如下面这个例子，我们一次 <code>push</code> 一个字符，从字符码 65（代表 A） 开始。</p><p>当用户读取时，会持续触发 <code>read</code>，我们会 <code>push</code> 更多地字符。</p><p>当字符全部 <code>push</code> 完毕，我们 <code>push null</code>，停止 Stream。</p><pre><code>const &amp;#123;Readable&amp;#125; = require('stream')const inStream = new Readable(&amp;#123;  read(size) &amp;#123;    const char = String.fromCharCode(this.currentCharCode++)    this.push(char);    console.log(`推了$&amp;#123;char&amp;#125;`)    // 这个时候停止    if (this.currentCharCode &gt; 90) &amp;#123; // Z      this.push(null)    &amp;#125;  &amp;#125;&amp;#125;)inStream.currentCharCode = 65 // AinStream.pipe(process.stdout)复制代码</code></pre><h2 id="Duplex-Stream"><a href="#Duplex-Stream" class="headerlink" title="Duplex Stream"></a>Duplex Stream</h2><p>看完了可读流、可写流，<code>Duplex Stream</code> 就简单多了。</p><p>同时实现 <code>write</code> 和 <code>read</code> 方法就好啦。</p><pre><code>const &amp;#123;Duplex&amp;#125; = require('stream')const inoutStream = new Duplex(&amp;#123;  write(chunk, encoding, callback) &amp;#123;    console.log(chunk.toString())    callback()  &amp;#125;,  read(size) &amp;#123;    this.push(String.fromCharCode(this.currentCharCode++))    if (this.currentCharCode &gt; 90) &amp;#123;      this.pull(null)    &amp;#125;  &amp;#125;&amp;#125;)inoutStream.currentCharCode = 65;process.stdin.pipe(inoutStream).pipe(process.stdout);复制代码</code></pre><h2 id="Transform-Stream"><a href="#Transform-Stream" class="headerlink" title="Transform Stream"></a>Transform Stream</h2><p>对于 Transform Stream，我们实现 transform 方法就好了，它结合了可读、可写两个方法。</p><p>这里有一个简单的 transform 例子，会以大写的格式打印任何你键入的字符：</p><pre><code>const &amp;#123;Transform&amp;#125; = require('stream')const upperCaseTr = new Transform(&amp;#123;  transform(chunk, encoding, callback) &amp;#123;    // 1. 读数据 chunk.toString()    // 2. 写数据 this.push(xxx)    this.push(chunk.toString().toUpperCase())    callback();  &amp;#125;&amp;#125;)// 监听用户输入，调用 upperCaseTr// 转化完成后，输出process.stdin.pipe(upperCaseTr)     .pipe(process.stdout)复制代码</code></pre><h1 id="Node-js-内置的-Transform-Stream"><a href="#Node-js-内置的-Transform-Stream" class="headerlink" title="Node.js 内置的 Transform Stream"></a>Node.js 内置的 Transform Stream</h1><p>比如面试中经常说的优化方案：gzip 压缩。</p><p>在 Node.js 中用 4 行代码就可以实现</p><pre><code>const fs = require('fs')const zlib = require('zlib')const file = process.argv[2]fs.createReadStream(file)  .pipe(zlib.createGzip())    .on('data', () =&gt; process.stdout.write(".")) // 打出进度条  .pipe(fs.createWriteStream(file + ".gz"))复制代码</code></pre><h1 id="Stream-在-Node-js-中随处可见"><a href="#Stream-在-Node-js-中随处可见" class="headerlink" title="Stream 在 Node.js 中随处可见"></a>Stream 在 Node.js 中随处可见</h1><table><thead><tr><th>Readable Stream</th><th>Writeable Stream</th></tr></thead><tbody><tr><td>HTTP Response 客户端</td><td>HTTP Request 客户端</td></tr><tr><td>HTTP Request 服务端</td><td>HTTP Response 服务端</td></tr><tr><td>fs read stream</td><td>fs write stream</td></tr><tr><td>zlib stream</td><td>zlib stream</td></tr><tr><td>TCP sockets</td><td>TCP sockets</td></tr><tr><td>child process stdout &amp; stderr</td><td>child process stdin</td></tr><tr><td>process.stdin</td><td>process.stdout,process.stderr</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h1 id="数据积压问题"><a href="#数据积压问题" class="headerlink" title="数据积压问题"></a>数据积压问题</h1><p>在 Stream 中，还有一个非常重要的问题：数据积压。</p><p>如果数据太多，堵住了，怎么解决。</p><p>Node.js 官网有一篇专门的文章解释如何解决，大家碰到问题的时候可以翻出来看看。</p><p>我在这里就不赘述了，<a href="https://nodejs.org/zh-cn/docs/guides/backpressuring-in-streams/">地址在这里</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>来总结下到目前为止，我们了解的 Stream 对象。</p><ul><li><p>为什么使用 Stream 呢？</p><ul><li>因为读写大文件的时候，可以有效降低内存压力。</li></ul></li><li><p>管道 pipe 是 Stream 中的一个重要概念，可以连接流。</p></li><li><p>Stream 对象都继承了 EventEmitter。</p></li><li><p>Stream 分为四类</p><ul><li>可读 Readable，有两个状态：paused、flowing。</li><li>可写 Writable，两个重要事件：drain、finish。</li><li>可读可写（双向）Duplex</li><li>可读可写（变化）Transform</li></ul></li><li><p>最后了解如何创建四类 Stream 和 Node.js 中的 Stream</p></li></ul><p><a href="https://juejin.im/post/6854573219060400141">转自【掘金 <strong>Marica</strong>】</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写async await的最简实现（20行搞定）面试必考！</title>
      <link href="/blog/interview/20200730002/"/>
      <url>/blog/interview/20200730002/</url>
      
        <content type="html"><![CDATA[<p>如果让你手写 async 函数的实现，你是不是会觉得很复杂？这篇文章带你用 20 行搞定它的核心。经常有人说 async 函数是 generator 函数的语法糖，那么到底是怎么样一个糖呢？让我们来一层层的剥开它的糖衣。有的同学想说，既然用了 generator 函数何必还要实现 async 呢？这篇文章的目的就是带大家理解清楚 async 和 generator 之间到底是如何相互协作，管理异步的。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>const getData = () =&gt;newPromise(resolve =&gt; setTimeout(() =&gt; resolve("data"), 1000)) asyncfunction test() &amp;#123; const data = await getData() console.log('data: ', data); const data2 = await getData() console.log('data2: ', data2); return'success'&amp;#125; // 这样的一个函数 应该再1秒后打印data 再过一秒打印data2 最后打印successtest().then(res =&gt;console.log(res))</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于这个简单的案例来说，如果我们把它用 generator 函数表达，会是怎么样的呢？</p><pre><code>function* testG() &amp;#123; // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return'success'&amp;#125;</code></pre><p>我们知道，generator 函数是不会自动执行的，每一次调用它的 next 方法，会停留在下一个 yield 的位置。利用这个特性，我们只要编写一个自动执行的函数，就可以让这个 generator 函数完全实现 async 函数的功能。</p><pre><code>const getData = () =&gt;newPromise(resolve =&gt; setTimeout(() =&gt; resolve("data"), 1000)) var test = asyncToGenerator( function* testG() { // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return'success' }) test().then(res =&gt;console.log(res))</code></pre><p>那么大体上的思路已经确定了，<code>asyncToGenerator</code>接受一个<code>generator</code>函数，返回一个<code>promise</code>，关键就在于，里面用<code>yield</code>来划分的异步流程，应该如何自动执行。</p><h2 id="如果是手动执行"><a href="#如果是手动执行" class="headerlink" title="如果是手动执行"></a>如果是手动执行</h2><p>在编写这个函数之前，我们先模拟手动去调用这个<code>generator</code>函数去一步步的把流程走完，有助于后面的思考。</p><pre><code>function* testG() { // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return'success'}</code></pre><p>我们先调用<code>testG</code>生成一个迭代器</p><pre><code>// 返回了一个迭代器var gen = testG()</code></pre><p>然后开始执行第一次<code>next</code></p><pre><code>// 第一次调用next 停留在第一个yield的位置// 返回的promise里 包含了data需要的数据var dataPromise = gen.next()</code></pre><p>这里返回了一个<code>promise</code>，就是第一次<code>getData()</code>所返回的<code>promise</code>，注意</p><pre><code>const data = yield getData()</code></pre><p>这段代码要切割成左右两部分来看，第一次调用<code>next</code>，其实只是停留在了<code>yield getData()</code>这里，<code>data</code>的值并没有被确定。那么什么时候 data 的值会被确定呢？<strong>「下一次调用 next 的时候，传的参数会被作为上一个 yield 前面接受的值」</strong>也就是说，我们再次调用<code>gen.next('这个参数才会被赋给data变量')</code>的时候<code>data</code>的值才会被确定为<code>'这个参数才会被赋给data变量'</code></p><pre><code>gen.next('这个参数才会被赋给data变量') // 然后这里的data才有值const data = yield getData() // 然后打印出dataconsole.log('data: ', data); // 然后继续走到下一个yieldconst data2 = yield getData() </code></pre><p>然后往下执行，直到遇到下一个<code>yield</code>，继续这样的流程…这是 generator 函数设计的一个比较难理解的点，但是为了实现我们的目标，还是得去学习它~借助这个特性，如果我们这样去控制 yield 的流程，是不是就能实现异步串行了？</p><pre><code>function* testG() { // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return'success'} var gen = testG() var dataPromise = gen.next() dataPromise.then((value1) =&gt; { // data1的value被拿到了 继续调用next并且传递给data var data2Promise = gen.next(value1) // console.log('data: ', data); // 此时就会打印出data data2Promise.then((value2) =&gt; { // data2的value拿到了 继续调用next并且传递value2 gen.next(value2) // console.log('data2: ', data2); // 此时就会打印出data2 })})</code></pre><p>这样的一个看着像<code>callback hell</code>的调用，就可以让我们的 generator 函数把异步安排的明明白白。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>有了这样的思路，实现这个高阶函数就变得很简单了。先整体看一下结构，有个印象，然后我们逐行注释讲解。</p><pre><code>function asyncToGenerator(generatorFunc) { returnfunction() { const gen = generatorFunc.apply(this, arguments) returnnewPromise((resolve, reject) =&gt; { function step(key, arg) { let generatorResult try { generatorResult = gen[key](arg) } catch (error) { return reject(error) } const { value, done } = generatorResult if (done) { return resolve(value) } else { returnPromise.resolve(value).then(val =&gt; step('next', val), err =&gt; step('throw', err)) } } step("next") }) }}</code></pre><p>不多不少，22 行。接下来逐行讲解。</p><pre><code>function asyncToGenerator(generatorFunc) { // 返回的是一个新的函数 returnfunction() { // 先调用generator函数 生成迭代器 // 对应 var gen = testG() const gen = generatorFunc.apply(this, arguments) // 返回一个promise 因为外部是用.then的方式 或者await的方式去使用这个函数的返回值的 // var test = asyncToGenerator(testG) // test().then(res =&gt; console.log(res)) returnnewPromise((resolve, reject) =&gt; { // 内部定义一个step函数 用来一步一步的跨过yield的阻碍 // key有next和throw两种取值，分别对应了gen的next和throw方法 // arg参数则是用来把promise resolve出来的值交给下一个yield function step(key, arg) { let generatorResult // 这个方法需要包裹在try catch中 // 如果报错了 就把promise给reject掉 外部通过.catch可以获取到错误 try { generatorResult = gen[key](arg) } catch (error) { return reject(error) } // gen.next() 得到的结果是一个 { value, done } 的结构 const { value, done } = generatorResult if (done) { // 如果已经完成了 就直接resolve这个promise // 这个done是在最后一次调用next后才会为true // 以本文的例子来说 此时的结果是 { done: true, value: 'success' } // 这个value也就是generator函数最后的返回值 return resolve(value) } else { // 除了最后结束的时候外，每次调用gen.next() // 其实是返回 { value: Promise, done: false } 的结构， // 这里要注意的是Promise.resolve可以接受一个promise为参数 // 并且这个promise参数被resolve的时候，这个then才会被调用 returnPromise.resolve( // 这个value对应的是yield后面的promise value ).then( // value这个promise被resove的时候，就会执行next // 并且只要done不是true的时候 就会递归的往下解开promise // 对应gen.next().value.then(value =&gt; { //    gen.next(value).value.then(value2 =&gt; { //       gen.next() // //      // 此时done为true了 整个promise被resolve了 //      // 最外部的test().then(res =&gt; console.log(res))的then就开始执行了 //    }) // }) function onResolve(val) { step("next", val) }, // 如果promise被reject了 就再次进入step函数 // 不同的是，这次的try catch中调用的是gen.throw(err) // 那么自然就被catch到 然后把promise给reject掉啦 function onReject(err) { step("throw", err) }, ) } } step("next") }) }}</code></pre><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p>这个 js 文件的代码可以直接放进浏览器里运行，欢迎调戏。<br>github.com/sl1673495/f…[2]</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文用最简单的方式实现了 asyncToGenerator 这个函数，这是 babel 编译 async 函数的核心，当然在 babel 中，generator 函数也被编译成了一个很原始的形式，本文我们直接以 generator 替代。这也是实现 promise 串行的一个很棒的模式，如果本篇文章对你有帮助，点个赞就好啦。</p><p><a href="https://mp.weixin.qq.com/s/eASescI3ZO0InccGQgQSjg">转自 图雀社区</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象深拷贝和浅拷贝</title>
      <link href="/blog/web/20200730001/"/>
      <url>/blog/web/20200730001/</url>
      
        <content type="html"><![CDATA[<p>各类技术论坛关于深拷贝的博客有很多,有些写的也比我好,那为什么我还要坚持写这篇博客呢,之前看到的一篇<a href="https://juejin.im/post/5c0c87b35188252e8966c78a">博客</a>中有句话写的非常好</p><blockquote><p>学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。</p></blockquote><p>写博客的初衷也是作为自己学到的知识点的总结,同时也希望能给点开这篇文章的人一些帮助,在前端开发的路上能够少一点坎坷多一点希望</p><p><strong>如有错误欢迎指出会在第一时间改正</strong></p><h1 id="基本类型的值和引用类型的值"><a href="#基本类型的值和引用类型的值" class="headerlink" title="基本类型的值和引用类型的值"></a>基本类型的值和引用类型的值</h1><p>JavaScript的变量中包含两种类型的值</p><h2 id="基本类型值"><a href="#基本类型值" class="headerlink" title="基本类型值"></a><strong>基本类型值</strong></h2><p>基本类型值指的是存储在栈中的一些简单的数据段</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><p>在JavaScript中基本数据类型有String,Number,Undefined,Null,Boolean，在ES6中，又定义了一种新的基本数据类型Symbol,所以一共有6种</p><p>基本类型是按值访问的，从一个变量复制基本类型的值到另一个变量后这2个变量的值是完全独立的，即使一个变量改变了也不会影响到第二个变量</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">var</span> str1 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token keyword">var</span> str2 <span class="token operator">=</span> str1<span class="token punctuation">;</span>str2 <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//'b'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//'a'</span></code></pre><h2 id="引用类型值"><a href="#引用类型值" class="headerlink" title="引用类型值"></a><strong>引用类型值</strong></h2><p>引用类型值是引用类型的实例，它是保存在堆内存中的一个对象，引用类型是一种数据结构，最常用的是Object,Array,Function类型，另外还有Date,RegExp,Error等，ES6同样也提供了Set,Map2种新的数据结构</p><h2 id="JavaScript是如何复制引用类型的"><a href="#JavaScript是如何复制引用类型的" class="headerlink" title="JavaScript是如何复制引用类型的"></a>JavaScript是如何复制引用类型的</h2><p>JavaScript对于基本类型和引用类型的赋值是不一样的</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> ob2 <span class="token operator">=</span> obj1<span class="token punctuation">;</span>obj2<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:2&amp;#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:2&amp;#125;</span></code></pre><p>在这里只修改了obj1中的a属性，却同时改变了ob1和obj2中的a属性</p><p>当变量复制引用类型值的时候，同样和基本类型值一样会将变量的值复制到新变量上，不同的是对于变量的值，它是一个指针，指向存储在堆内存中的对象（JS规定放在堆内存中的对象无法直接访问，必须要访问这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，所以引用类型的值是按引用访问）</p><p>变量的值也就是这个指针是存储在栈上的，当变量obj1复制变量的值给变量obj2时，obj1,obj2只是一个保存在栈中的指针,指向同一个存储在堆内存中的对象，所以当通过变量obj1操作堆内存的对象时，obj2也会一起改变</p><p><img src="https://imgkr.cn-bj.ufileos.com/a87f5944-9fd3-4021-be03-3ad11f39b9f7.jpg"></p><p>保存在于栈中的变量和堆内存中对象的关系</p><p>再举个例子，小明(obj1变量)知道他家的地址(对象{a:1})，然后小明告诉了小刚(obj2变量)他家的地址(复制变量)，小刚这个时候就知道了小明家的地址，然后小刚去小明家把小明家的门给拆了(修改对象)，小明回家一看就会发现门没了,这时小明和小刚去这个地址的时候都会看到一个没有门的家-.-(对象的修改反映到变量)</p><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>对于浅拷贝的定义可以理解为</p><blockquote><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p></blockquote><p>以下是一些JavaScript提供的浅拷贝方法</p><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>ES6中拷贝对象的方法，接受的第一个参数是拷贝的目标，剩下的参数是拷贝的源对象（可以是多个）</p><blockquote><p>语法：Object.assign(target, …sources)</p></blockquote><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">var</span> target <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> source <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>target <span class="token punctuation">,</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:1&amp;#125;</span>source<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:2&amp;#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:1&amp;#125;</span></code></pre><p>Object.assign是一个浅拷贝,它只是在<strong>根属性</strong>(对象的第一层级)创建了一个新的对象，但是对于属性的值是仍是对象的话依然是浅拷贝，</p><p><strong>Object.assign还有一些注意的点是:</strong></p><ol><li>不会拷贝对象继承的属性</li><li>不可枚举的属性</li><li>属性的数据属性/访问器属性</li><li>可以拷贝Symbol类型</li></ol><p>可以理解为Object.assign就是使用简单的=来赋值,遍历从右往左遍历源对象(sources)的所有属性用 <strong>=</strong> 赋值到目标对象(target)上</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>    a<span class="token punctuation">:</span><span class="token entity" title="&#123;">&amp;#123;</span>        b<span class="token punctuation">:</span><span class="token number">1</span>    <span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">,</span>    sym<span class="token punctuation">:</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span><span class="token string">'innumerable'</span><span class="token punctuation">,</span><span class="token entity" title="&#123;">&amp;#123;</span>    value<span class="token punctuation">:</span><span class="token string">'不可枚举属性'</span><span class="token punctuation">,</span>    enumerable<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>obj2<span class="token punctuation">,</span>obj1<span class="token punctuation">)</span>obj1<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj1'</span><span class="token punctuation">,</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj2'</span><span class="token punctuation">,</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p><img src="https://imgkr.cn-bj.ufileos.com/80111e2b-b228-4838-adbf-e9acff055e7b.jpg"></p><p>可以看到Symbol类型可以正确拷贝，但是不可枚举的属性被忽略了并且改变了obj1.a.b的值，obj2.a.b的值也会跟着改变，说明依旧存在访问的是堆内存中同一个对象的问题</p><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>利用扩展运算符可以在构造字面量对象时,进行克隆或者属性拷贝</p><blockquote><p>语法：var cloneObj = { …obj };</p></blockquote><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token punctuation">:</span><span class="token entity" title="&#123;">&amp;#123;</span>c<span class="token punctuation">:</span><span class="token number">1</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span><span class="token operator">...</span>obj<span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:2,b:&amp;#123;c:1&amp;#125;&amp;#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:1,b:&amp;#123;c:1&amp;#125;&amp;#125;</span>obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:2,b:&amp;#123;c:2&amp;#125;&amp;#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:1,b:&amp;#123;c:2&amp;#125;&amp;#125;</span></code></pre><p>扩展运算符Object.assign()有同样的缺陷，对于值是对象的属性无法完全拷贝成2个不同对象,但是如果属性都是基本类型的值的话,使用扩展运算符更加方便</p><h2 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h2><p>slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</p><blockquote><p>语法: arr.slice(begin, end);</p></blockquote><p>在ES6以前,没有剩余运算符,Array.from的时候可以用 Array.prototype.slice将arguments类数组转为真正的数组,它返回一个浅拷贝后的的新数组</p><pre class=" language-jsx"><code class="language-jsx">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token entity" title="&#123;">&amp;#123;</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token string">"aaa"</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token number">1</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//["aaa"]</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span></code></pre><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>浅拷贝只在根属性上在堆内存中创建了一个新的的对象，复制了基本类型的值,但是复杂数据类型也就是对象则是拷贝相同的地址，而深拷贝则是对于复杂数据类型在堆内存中开辟了一块内存地址用于存放复制的对象并且把原有的对象复制过来，这2个对象是相互独立的,也就是2个不同的地址</p><blockquote><p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p></blockquote><h2 id="一个简单的深拷贝"><a href="#一个简单的深拷贝" class="headerlink" title="一个简单的深拷贝"></a>一个简单的深拷贝</h2><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>    a<span class="token punctuation">:</span> <span class="token entity" title="&#123;">&amp;#123;</span>        b<span class="token punctuation">:</span> <span class="token number">1</span>    <span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">,</span>    c<span class="token punctuation">:</span> <span class="token number">1</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span>obj2<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span><span class="token entity" title="&#125;">&amp;#125;</span>obj2<span class="token punctuation">.</span>c <span class="token operator">=</span> obj1<span class="token punctuation">.</span>cobj2<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b <span class="token operator">=</span> obj1<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:&amp;#123;b:1&amp;#125;,c:1&amp;#125;;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:&amp;#123;b:1&amp;#125;,c:1&amp;#125;;</span>obj1<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:&amp;#123;b:2&amp;#125;,c:1&amp;#125;;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:&amp;#123;b:1&amp;#125;,c:1&amp;#125;;</span></code></pre><p>在上面的代码中，我们新建了一个obj2对象,同时根据obj1对象的a属性是一个引用类型,我们给obj2.a的值也新建一个新对象(即在内存中新开辟了一块内存地址),然后把obj1.a.b属性的值数字1复制给obj2.a.b，因为数字1是基本类型的值，所以改变obj1.a.b的值后，obj2.a不会收到影响，因为他们的引用是完全2个独立的对象,这就完成了一个简单的深拷贝</p><h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h2><p>JSON.stringify()是目前前端开发过程中最常用的深拷贝方式，原理是把一个对象序列化成为一个JSON字符串，将对象的内容转换成字符串的形式再保存在磁盘上，再用JSON.parse()反序列化将JSON字符串变成一个新的对象</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>    a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span>    b<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token keyword">var</span> str <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:1,b:[1,2,3]&amp;#125;</span>obj1<span class="token punctuation">.</span>a<span class="token operator">=</span><span class="token number">2</span>obj1<span class="token punctuation">.</span>b<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:2,b:[1,2,3,4]&amp;#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:1,b:[1,2,3]&amp;#125;</span></code></pre><p><strong>通过JSON.stringify实现深拷贝有几点要注意</strong></p><ol><li>拷贝的对象的值中如果有函数,undefined,symbol则经过JSON.stringify()序列化后的JSON字符串中这个键值对会消失</li><li>无法拷贝不可枚举的属性，无法拷贝对象的原型链</li><li>拷贝Date引用类型会变成字符串</li><li>拷贝RegExp引用类型会变成空对象</li><li>对象中含有NaN、Infinity和-Infinity，则序列化的结果会变成null</li><li>无法拷贝对象的循环应用(即obj[key] = obj)</li></ol><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>func <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>     <span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>und <span class="token operator">=</span> undefined<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>reg <span class="token operator">=</span> <span class="token regex">/123/</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token number">NaN</span> <span class="token operator">=</span> <span class="token number">NaN</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>infinity <span class="token operator">=</span> <span class="token number">Infinity</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span><span class="token string">'innumerable'</span><span class="token punctuation">,</span><span class="token entity" title="&#123;">&amp;#123;</span>    enumerable<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>    value<span class="token punctuation">:</span><span class="token string">'innumerable'</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj1'</span><span class="token punctuation">,</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> str <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj2'</span><span class="token punctuation">,</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>打印出来的结果如下</p><p><img src="https://imgkr.cn-bj.ufileos.com/5a4c6a84-751c-42d4-9898-8bbe1d49542d.jpg"></p><p>可以看到除了Object对象和数组其他基本都和原来的不一样，obj1的constructor是Obj(),而obj2的constructor指向了Object()，而对于循环引用则是直接报错了</p><p>虽说通过JSON.stringify()方法深拷贝对象也有很多无法实现的功能，但是对于日常的开发需求(对象和数组)，使用这种方法是最简单和快捷的</p><h2 id="使用第三方库实现对象的深拷贝"><a href="#使用第三方库实现对象的深拷贝" class="headerlink" title="使用第三方库实现对象的深拷贝"></a>使用第三方库实现对象的深拷贝</h2><p>1.<a href="https://github.com/lodash/lodash/blob/master/.internal/baseClone.js">lodash</a></p><p>2.<a href="https://www.jquery123.com/jQuery.extend/">jQuery</a></p><p>以上2个第三方的库都很好的封装的深拷贝的方法，有兴趣的同学可以去深入研究一下</p><h2 id="自己来实现一个深拷贝函数"><a href="#自己来实现一个深拷贝函数" class="headerlink" title="自己来实现一个深拷贝函数"></a>自己来实现一个深拷贝函数</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>这里简单封装了一个deepClone的函数，for in遍历传入参数的值，如果值是引用类型则再次调用deepClone函数，并且传入第一次调用deepClone参数的值作为第二次调用deepClone的参数，如果不是引用类型就直接复制</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>    a<span class="token punctuation">:</span><span class="token entity" title="&#123;">&amp;#123;</span>        b<span class="token punctuation">:</span><span class="token number">1</span>    <span class="token entity" title="&#125;">&amp;#125;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>    <span class="token keyword">var</span> cloneObj <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在堆内存中新建一个对象</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span><span class="token entity" title="&#123;">&amp;#123;</span> <span class="token comment" spellcheck="true">//遍历参数的键</span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span><span class="token string">'object'</span><span class="token punctuation">)</span><span class="token entity" title="&#123;">&amp;#123;</span>           cloneObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//值是对象就再次调用函数</span>       <span class="token entity" title="&#125;">&amp;#125;</span><span class="token keyword">else</span><span class="token entity" title="&#123;">&amp;#123;</span>           cloneObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">//基本类型直接复制值</span>       <span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token keyword">return</span> cloneObj <span class="token entity" title="&#125;">&amp;#125;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>obj1<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:&amp;#123;b:1&amp;#125;&amp;#125;</span></code></pre><p>但是还有很多问题</p><ul><li>首先这个deepClone函数并不能复制不可枚举的属性以及Symbol类型</li><li>这里只是针对Object引用类型的值做的循环迭代，而对于Array,Date,RegExp,Error,Function引用类型无法正确拷贝</li><li>对象循环引用成环了的情况</li></ul><h2 id="本人总结的深拷贝的方法"><a href="#本人总结的深拷贝的方法" class="headerlink" title="本人总结的深拷贝的方法"></a>本人总结的深拷贝的方法</h2><p>看过很多关于深拷贝的博客，本人总结出了一个能够深拷贝ECMAScript的<strong>原生引用类型</strong>的方法</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">const</span> isComplexDataType <span class="token operator">=</span> obj <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>obj <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token keyword">const</span> deepClone <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>obj<span class="token punctuation">,</span> hash <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Date<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//日期对象就返回一个新的日期对象</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> RegExp<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正则对象就返回一个新的正则对象</span>    <span class="token comment" spellcheck="true">//如果成环了,参数obj = obj.loop = 最初的obj 会在WeakMap中找到第一次放入的obj提前返回第一次放入WeakMap的cloneObj</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> hash<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>    <span class="token keyword">let</span> allDesc <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptors</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//遍历传入参数所有键的特性</span>    <span class="token keyword">let</span> cloneObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">,</span> allDesc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//继承原型链</span>    hash<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> cloneObj<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>   <span class="token comment" spellcheck="true">//Reflect.ownKeys(obj)可以拷贝不可枚举属性和符号类型</span>        <span class="token comment" spellcheck="true">// 如果值是引用类型(非函数)则递归调用deepClone</span>        cloneObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span>            <span class="token punctuation">(</span><span class="token function">isComplexDataType</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token operator">?</span>                <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span> <span class="token punctuation">:</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token keyword">return</span> cloneObj<span class="token punctuation">;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>    num<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    str<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>    boolean<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    unf<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span>    nul<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>    obj<span class="token punctuation">:</span> <span class="token entity" title="&#123;">&amp;#123;</span>        name<span class="token punctuation">:</span> <span class="token string">'我是一个对象'</span><span class="token punctuation">,</span>        id<span class="token punctuation">:</span> <span class="token number">1</span>    <span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">,</span>    arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    func<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是一个函数'</span><span class="token punctuation">)</span>    <span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">,</span>    date<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    reg<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">'/我是一个正则/ig'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'innumerable'</span><span class="token punctuation">,</span> <span class="token entity" title="&#123;">&amp;#123;</span>    enumerable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    value<span class="token punctuation">:</span> <span class="token string">'不可枚举属性'</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptors</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>obj<span class="token punctuation">.</span>loop <span class="token operator">=</span> obj<span class="token keyword">let</span> cloneObj <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj'</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'cloneObj'</span><span class="token punctuation">,</span> cloneObj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>cloneObj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> cloneObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> cloneObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`$&amp;#123;key&amp;#125;相同吗？ `</span></span><span class="token punctuation">,</span> cloneObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token entity" title="&#125;">&amp;#125;</span><span class="token entity" title="&#125;">&amp;#125;</span></code></pre><p>这个函数有几个要点</p><ol><li>利用Reflect.ownKeys()方法,能够遍历对象的不可枚举属性和Symbol类型</li><li>当参数为Date,RegExp类型则直接生成一个新的实例</li><li>使用Object.getOwnPropertyDescriptors()获得对象的所有属性对应的特性,结合Object.create()创建一个新对象继承传入原对象的原型链</li><li>利用WeekMap()类型作为哈希表,WeekMap()因为是弱引用的可以有效的防止内存泄露,作为检测循环引用很有帮助,如果存在循环引用直接返回WeekMap()存储的值</li></ol><p>这里我用全等判断打印了2个对象的属性是否相等,通过打印的结果可以看到,虽然值是一样的,但是在内存中是两个完全独立的对象</p><p><img src="https://imgkr.cn-bj.ufileos.com/1901f66f-d6da-4df0-ae46-2b0091bed2c5.jpg"></p><p>上述的深拷贝函数中Null和Function类型引用的还是同一个对象,因为deepClone函数对于对象的值是函数或者null时直接返回,这里没有深拷贝函数,如果需要深拷贝一个函数,可以考虑使用Function构造函数或者eval?这里还有待研究</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>封装的deepClone方法虽然能实现对ECMAScript原生引用类型的拷贝,但是对于对象来说范围太广了,仍有很多无法准确拷贝的(比如DOM节点),但是在日常开发中一般并不需要拷贝很多特殊的引用类型，深拷贝对象使用JSON.stringify依然是最方便的方法之一（当然也需要了解JSON.stringify的缺点）</p></li><li><p>实现一个完整的深拷贝是非常复杂的,需要考虑到很多边界情况,这里我也只是对部分的原生的构造函数进行了深拷贝,对于特殊的引用类型有拷贝需求的话,建议还是借助第三方完整的库</p></li><li><p>对于深入研究深拷贝的原理有助于理解JavaScript引用类型的特点，以及遇到相关特殊的问题也能迎刃而解，对于提高JavaScript的基础还是很有帮助的~~~</p></li></ol><p><strong>感谢观看</strong></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/b08bc61714c7">深入JS深拷贝对象</a></p><p>JavaScript高级程序设计第三版</p><p><a href="https://www.jianshu.com/p/c651aeabf582">转自【心_c2a2】</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装 axios 拦截器实现用户无感刷新 access_token</title>
      <link href="/blog/backend/20200728001/"/>
      <url>/blog/backend/20200728001/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近做项目的时候，涉及到一个单点登录，即是项目的登录页面，用的是公司共用的一个登录页面，在该页面统一处理逻辑。最终实现用户只需登录一次，就可以以登录状态访问公司旗下的所有网站。</p><blockquote><p>❝</p><p>单点登录( Single Sign On ，简称 SSO），是目前比较流行的企业业务整合的解决方案之一，用于多个应用系统间，用户只需要登录一次就可以访问所有相互信任的应用系统。</p><p>❞</p></blockquote><p>其中本文讲的是在登录后如何管理<code>access_token</code>和<code>refresh_token</code>，主要就是封装 axios拦截器，在此记录。</p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul><li>前置场景</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb0c1105117444d0949485c99a15c034~tplv-k3u1fbpfcp-zoom-1.image"></p><ol><li>进入该项目某个页面<code>http://xxxx.project.com/profile</code>需要登录，未登录就跳转至SSO登录平台，此时的登录网址 url为<code>http://xxxxx.com/login?app_id=project_name_id&amp;redirect_url=http://xxxx.project.com/profile</code>，其中<code>app_id</code>是后台那边约定定义好的，<code>redirect_url</code>是成功授权后指定的回调地址。</li><li>输入账号密码且正确后，就会重定向回刚开始进入的页面，并在地址栏带一个参数 <code>?code=XXXXX</code>，即是<code>http://xxxx.project.com/profile?code=XXXXXX</code>，code的值是使用一次后即无效，且10分钟内过期</li><li>立马获取这个code值再去请求一个api <code>/access_token/authenticate</code>，携带参数<code>{ verify_code: code }</code>，并且该api已经自带<code>app_id</code>和<code>app_secret</code>两个固定值参数，通过它去请求授权的api，请求成功后得到返回值<code>{ access_token: "xxxxxxx", refresh_token: "xxxxxxxx", expires_in: xxxxxxxx }</code>，存下<code>access_token</code>和<code>refresh_token</code>到cookie中（localStorage也可以），此时用户就算登录成功了。</li><li><code>access_token</code>为标准JWT格式，是授权令牌，可以理解就是验证用户身份的，是应用在调用api访问和修改用户数据必须传入的参数（放在请求头headers里），2小时后过期。也就是说，做完前三步后，你可以调用需要用户登录才能使用的api；但是假如你什么都不操作，静静过去两个小时后，再去请求这些api，就会报<code>access_token</code>过期，调用失败。</li><li>那么总不能2小时后就让用户退出登录吧，解决方法就是两小时后拿着过期的<code>access_token</code>和<code>refresh_token</code>（<code>refresh_token</code>过期时间一般长一些，比如一个月或更长）去请求<code>/refresh</code> api，返回结果为<code>{ access_token: "xxxxx", expires_in: xxxxx }</code>，换取新的<code>access_token</code>，新的<code>access_token</code>过期时间也是2小时，并重新存到cookie，循环往复继续保持登录调用用户api了。<code>refresh_token</code>在限定过期时间内（比如一周或一个月等），下次就可以继续换取新的<code>access_token</code>，但过了限定时间，就算真正意义过期了，也就要重新输入账号密码来登录了。</li></ol><p>公司网站登录过期时间都只有两小时（token过期时间），但又想让一个月内经常活跃的用户不再次登录，于是才有这样需求，避免了用户再次输入账号密码登录。</p><p>为什么要专门用一个 <code>refresh_token</code> 去更新 <code>access_token</code> 呢？首先<code>access_token</code>会关联一定的用户权限，如果用户授权更改了，这个<code>access_token</code>也是需要被刷新以关联新的权限的，如果没有 <code>refresh_token</code>，也可以刷新 <code>access_token</code>，但每次刷新都要用户输入登录用户名与密码，多麻烦。有了 <code>refresh_ token</code>，可以减少这个麻烦，客户端直接用 <code>refresh_token</code> 去更新 <code>access_token</code>，无需用户进行额外的操作。</p><p>说了这么多，或许有人会吐槽，一个登录用<code>access_token</code>就行了还要加个<code>refresh_token</code>搞得这么麻烦，或者有的公司<code>refresh_token</code>是后台包办的并不需要前端处理。但是，前置场景在那了，需求都是基于该场景下的。</p><ul><li>需求</li></ul><ol><li>当<code>access_token</code>过期的时候，要用<code>refresh_token</code>去请求获取新的<code>access_token</code>，前端需要做到用户无感知的刷新<code>access_token</code>。比如用户发起一个请求时，如果判断<code>access_token</code>已经过期，那么就先要去调用刷新token接口拿到新的<code>access_token</code>，再重新发起用户请求。</li><li>如果同时发起多个用户请求，第一个用户请求去调用刷新token接口，当接口还没返回时，其余的用户请求也依旧发起了刷新token接口请求，就会导致多个请求，这些请求如何处理，就是我们本文的内容了。</li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>写在请求拦截器里，在请求前，先利用最初请求返回的字段<code>expires_in</code>字段来判断<code>access_token</code>是否已经过期，若已过期，则将请求挂起，先刷新<code>access_token</code>后再继续请求。</p><ul><li>优点： 能节省http请求</li><li>缺点： 因为使用了本地时间判断，若本地时间被篡改，有校验失败的风险</li></ul><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>写在响应拦截器里，拦截返回后的数据。先发起用户请求，如果接口返回<code>access_token</code>过期，先刷新<code>access_token</code>，再进行一次重试。</p><ul><li>优点：无需判断时间</li><li>缺点： 会消耗多一次http请求</li></ul><p>在此我选择的是方案二。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>这里使用axios，其中做的是请求后拦截，所以用到的是axios的响应拦截器<code>axios.interceptors.response.use()</code>方法</p><h3 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h3><ul><li>@utils/auth.js</li></ul><pre><code>import Cookies from 'js-cookie'const TOKEN_KEY = 'access_token'const REGRESH_TOKEN_KEY = 'refresh_token'export const getToken = () =&gt; Cookies.get(TOKEN_KEY)export const setToken = (token, params = &amp;#123;&amp;#125;) =&gt; &amp;#123;  Cookies.set(TOKEN_KEY, token, params)&amp;#125;export const setRefreshToken = (token) =&gt; &amp;#123;  Cookies.set(REGRESH_TOKEN_KEY, token)&amp;#125;复制代码</code></pre><ul><li>request.js</li></ul><pre><code>import axios from 'axios'import &amp;#123; getToken, setToken, getRefreshToken &amp;#125; from '@utils/auth'// 刷新 access_token 的接口const refreshToken = () =&gt; &amp;#123;  return instance.post('/auth/refresh', &amp;#123; refresh_token: getRefreshToken() &amp;#125;, true)&amp;#125;// 创建 axios 实例const instance = axios.create(&amp;#123;  baseURL:  process.env.GATSBY_API_URL,  timeout: 30000,  headers: &amp;#123;    'Content-Type': 'application/json',  &amp;#125;&amp;#125;)instance.interceptors.response.use(response =&gt; &amp;#123;    return response&amp;#125;, error =&gt; &amp;#123;    if (!error.response) &amp;#123;        return Promise.reject(error)    &amp;#125;    // token 过期或无效，返回 401 状态码，在此处理逻辑    return Promise.reject(error)&amp;#125;)// 给请求头添加 access_tokenconst setHeaderToken = (isNeedToken) =&gt; &amp;#123;  const accessToken = isNeedToken ? getToken() : null  if (isNeedToken) &amp;#123; // api 请求需要携带 access_token     if (!accessToken) &amp;#123;       console.log('不存在 access_token 则跳转回登录页')    &amp;#125;    instance.defaults.headers.common.Authorization = `Bearer $&amp;#123;accessToken&amp;#125;`  &amp;#125;&amp;#125;// 有些 api 并不需要用户授权使用，则不携带 access_token；默认不携带，需要传则设置第三个参数为 trueexport const get = (url, params = &amp;#123;&amp;#125;, isNeedToken = false) =&gt; &amp;#123;  setHeaderToken(isNeedToken)  return instance(&amp;#123;    method: 'get',    url,    params,  &amp;#125;)&amp;#125;export const post = (url, params = &amp;#123;&amp;#125;, isNeedToken = false) =&gt; &amp;#123;  setHeaderToken(isNeedToken)  return instance(&amp;#123;    method: 'post',    url,    data: params,  &amp;#125;)&amp;#125;复制代码</code></pre><p>接下来改造 request.js中axios的响应拦截器</p><pre><code>instance.interceptors.response.use(response =&gt; &amp;#123;    return response&amp;#125;, error =&gt; &amp;#123;    if (!error.response) &amp;#123;        return Promise.reject(error)    &amp;#125;    if (error.response.status === 401) &amp;#123;        const &amp;#123; config &amp;#125; = error        return refreshToken().then(res=&gt; &amp;#123;            const &amp;#123; access_token &amp;#125; = res.data            setToken(access_token)            config.headers.Authorization = `Bearer $&amp;#123;access_token&amp;#125;`            return instance(config)        &amp;#125;).catch(err =&gt; &amp;#123;            console.log('抱歉，您的登录状态已失效，请重新登录！')            return Promise.reject(err)        &amp;#125;)    &amp;#125;    return Promise.reject(error)&amp;#125;)复制代码</code></pre><p>约定返回401状态码表示<code>access_token</code>过期或者无效，如果用户发起一个请求后返回结果是<code>access_token</code>过期，则请求刷新<code>access_token</code>的接口。请求成功则进入<code>then</code>里面，重置配置，并刷新<code>access_token</code>并重新发起原来的请求。</p><p>但如果<code>refresh_token</code>也过期了，则请求也是返回401。此时调试会发现函数进不到<code>refreshToken()</code>的<code>catch</code>里面，那是因为<code>refreshToken()</code>方法内部是也是用了同个<code>instance</code>实例，重复响应拦截器401的处理逻辑，但该函数本身就是刷新<code>access_token</code>，故需要把该接口排除掉，即：</p><pre><code>if (error.response.status === 401 &amp;&amp; !error.config.url.includes('/auth/refresh')) &amp;#123;&amp;#125;复制代码</code></pre><p>上述代码就已经实现了无感刷新<code>access_token</code>了，当<code>access_token</code>没过期，正常返回；过期时，则axios内部进行了一次刷新token的操作，再重新发起原来的请求。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><h3 id="防止多次刷新-token"><a href="#防止多次刷新-token" class="headerlink" title="防止多次刷新 token"></a>防止多次刷新 token</h3><p>如果token是过期的，那请求刷新<code>access_token</code>的接口返回也是有一定时间间隔，如果此时还有其他请求发过来，就会再执行一次刷新<code>access_token</code>的接口，就会导致多次刷新<code>access_token</code>。因此，我们需要做一个判断，定义一个标记判断当前是否处于刷新<code>access_token</code>的状态，如果处在刷新状态则不再允许其他请求调用该接口。</p><pre><code>let isRefreshing = false // 标记是否正在刷新 tokeninstance.interceptors.response.use(response =&gt; &amp;#123;    return response&amp;#125;, error =&gt; &amp;#123;    if (!error.response) &amp;#123;        return Promise.reject(error)    &amp;#125;    if (error.response.status === 401 &amp;&amp; !error.config.url.includes('/auth/refresh')) &amp;#123;        const &amp;#123; config &amp;#125; = error        if (!isRefreshing) &amp;#123;            isRefreshing = true            return refreshToken().then(res=&gt; &amp;#123;                const &amp;#123; access_token &amp;#125; = res.data                setToken(access_token)                config.headers.Authorization = `Bearer $&amp;#123;access_token&amp;#125;`                return instance(config)            &amp;#125;).catch(err =&gt; &amp;#123;                console.log('抱歉，您的登录状态已失效，请重新登录！')                return Promise.reject(err)            &amp;#125;).finally(() =&gt; &amp;#123;                isRefreshing = false            &amp;#125;)        &amp;#125;    &amp;#125;    return Promise.reject(error)&amp;#125;)复制代码</code></pre><h3 id="同时发起多个请求的处理"><a href="#同时发起多个请求的处理" class="headerlink" title="同时发起多个请求的处理"></a>同时发起多个请求的处理</h3><p>上面做法还不够，因为如果同时发起多个请求，在token过期的情况，第一个请求进入刷新token方法，则其他请求进去没有做任何逻辑处理，单纯返回失败，最终只执行了第一个请求，这显然不合理。</p><p>比如同时发起三个请求，第一个请求进入刷新token的流程，第二个和第三个请求需要存起来，等到token更新后再重新发起请求。</p><p>在此，我们定义一个数组<code>requests</code>，用来保存处于等待的请求，之后返回一个<code>Promise</code>，只要不调用<code>resolve</code>方法，该请求就会处于等待状态，则可以知道其实数组存的是函数；等到token更新完毕，则通过数组循环执行函数，即逐个执行resolve重发请求。</p><pre><code>let isRefreshing = false // 标记是否正在刷新 tokenlet requests = [] // 存储待重发请求的数组instance.interceptors.response.use(response =&gt; &amp;#123;    return response&amp;#125;, error =&gt; &amp;#123;    if (!error.response) &amp;#123;        return Promise.reject(error)    &amp;#125;    if (error.response.status === 401 &amp;&amp; !error.config.url.includes('/auth/refresh')) &amp;#123;        const &amp;#123; config &amp;#125; = error        if (!isRefreshing) &amp;#123;            isRefreshing = true            return refreshToken().then(res=&gt; &amp;#123;                const &amp;#123; access_token &amp;#125; = res.data                setToken(access_token)                config.headers.Authorization = `Bearer $&amp;#123;access_token&amp;#125;`                // token 刷新后将数组的方法重新执行                requests.forEach((cb) =&gt; cb(access_token))                requests = [] // 重新请求完清空                return instance(config)            &amp;#125;).catch(err =&gt; &amp;#123;                console.log('抱歉，您的登录状态已失效，请重新登录！')                return Promise.reject(err)            &amp;#125;).finally(() =&gt; &amp;#123;                isRefreshing = false            &amp;#125;)        &amp;#125; else &amp;#123;            // 返回未执行 resolve 的 Promise            return new Promise(resolve =&gt; &amp;#123;                // 用函数形式将 resolve 存入，等待刷新后再执行                requests.push(token =&gt; &amp;#123;                    config.headers.Authorization = `Bearer $&amp;#123;token&amp;#125;`                    resolve(instance(config))                &amp;#125;)              &amp;#125;)        &amp;#125;    &amp;#125;    return Promise.reject(error)&amp;#125;)复制代码</code></pre><p>最终 request.js 代码</p><pre><code>import axios from 'axios'import &amp;#123; getToken, setToken, getRefreshToken &amp;#125; from '@utils/auth'// 刷新 access_token 的接口const refreshToken = () =&gt; &amp;#123;  return instance.post('/auth/refresh', &amp;#123; refresh_token: getRefreshToken() &amp;#125;, true)&amp;#125;// 创建 axios 实例const instance = axios.create(&amp;#123;  baseURL:  process.env.GATSBY_API_URL,  timeout: 30000,  headers: &amp;#123;    'Content-Type': 'application/json',  &amp;#125;&amp;#125;)let isRefreshing = false // 标记是否正在刷新 tokenlet requests = [] // 存储待重发请求的数组instance.interceptors.response.use(response =&gt; &amp;#123;    return response&amp;#125;, error =&gt; &amp;#123;    if (!error.response) &amp;#123;        return Promise.reject(error)    &amp;#125;    if (error.response.status === 401 &amp;&amp; !error.config.url.includes('/auth/refresh')) &amp;#123;        const &amp;#123; config &amp;#125; = error        if (!isRefreshing) &amp;#123;            isRefreshing = true            return refreshToken().then(res=&gt; &amp;#123;                const &amp;#123; access_token &amp;#125; = res.data                setToken(access_token)                config.headers.Authorization = `Bearer $&amp;#123;access_token&amp;#125;`                // token 刷新后将数组的方法重新执行                requests.forEach((cb) =&gt; cb(access_token))                requests = [] // 重新请求完清空                return instance(config)            &amp;#125;).catch(err =&gt; &amp;#123;                console.log('抱歉，您的登录状态已失效，请重新登录！')                return Promise.reject(err)            &amp;#125;).finally(() =&gt; &amp;#123;                isRefreshing = false            &amp;#125;)        &amp;#125; else &amp;#123;            // 返回未执行 resolve 的 Promise            return new Promise(resolve =&gt; &amp;#123;                // 用函数形式将 resolve 存入，等待刷新后再执行                requests.push(token =&gt; &amp;#123;                    config.headers.Authorization = `Bearer $&amp;#123;token&amp;#125;`                    resolve(instance(config))                &amp;#125;)              &amp;#125;)        &amp;#125;    &amp;#125;    return Promise.reject(error)&amp;#125;)// 给请求头添加 access_tokenconst setHeaderToken = (isNeedToken) =&gt; &amp;#123;  const accessToken = isNeedToken ? getToken() : null  if (isNeedToken) &amp;#123; // api 请求需要携带 access_token     if (!accessToken) &amp;#123;       console.log('不存在 access_token 则跳转回登录页')    &amp;#125;    instance.defaults.headers.common.Authorization = `Bearer $&amp;#123;accessToken&amp;#125;`  &amp;#125;&amp;#125;// 有些 api 并不需要用户授权使用，则无需携带 access_token；默认不携带，需要传则设置第三个参数为 trueexport const get = (url, params = &amp;#123;&amp;#125;, isNeedToken = false) =&gt; &amp;#123;  setHeaderToken(isNeedToken)  return instance(&amp;#123;    method: 'get',    url,    params,  &amp;#125;)&amp;#125;export const post = (url, params = &amp;#123;&amp;#125;, isNeedToken = false) =&gt; &amp;#123;  setHeaderToken(isNeedToken)  return instance(&amp;#123;    method: 'post',    url,    data: params,  &amp;#125;)&amp;#125;复制代码</code></pre><p>参考文章：</p><ul><li><a href="https://juejin.im/post/6844903925078818829">juejin.im/post/684490…</a></li></ul><ul><li>ps： <a href="https://github.com/Jacky-Summer/personal-blog">个人技术博文 Github 仓库</a>，觉得不错的话欢迎 star，给我一点鼓励继续写作吧~</li></ul><p>转自<a href="https://juejin.im/post/5f1ba98ae51d4534b73a9d7a">【掘金 <strong>JackySummer</strong>】</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你不知道的 WebSocket</title>
      <link href="/blog/node/20200728002/"/>
      <url>/blog/node/20200728002/</url>
      
        <content type="html"><![CDATA[<p>本文阿宝哥将从多个方面入手，全方位带你一起探索 WebSocket 技术。阅读完本文，你将了解以下内容：</p><ul><li>了解 WebSocket 的诞生背景、WebSocket 是什么及它的优点；</li><li>了解 WebSocket 含有哪些 API 及如何使用 WebSocket API 发送普通文本和二进制数据；</li><li>了解 WebSocket 的握手协议和数据帧格式、掩码算法等相关知识；</li><li>了解如何实现一个支持发送普通文本的 WebSocket 服务器。</li></ul><p>在最后的 <strong>阿宝哥有话说</strong> 环节，阿宝哥将介绍 WebSocket 与 HTTP 之间的关系、WebSocket 与长轮询有什么区别、什么是 WebSocket 心跳及 Socket 是什么等内容。</p><p>推荐阅读（感谢掘友的鼓励与支持🌹🌹🌹）：</p><ul><li><a href="https://juejin.im/post/6844904198639714311">你不知道的 Web Workers （上）[7.8K 字 | 多图预警]</a>（424+ 个👍）</li><li><a href="https://juejin.im/post/6844904198639714311">你不知道的 Blob</a>（215+ 个👍）</li><li><a href="https://juejin.im/post/6844904198639714311">你不知道的 WeakMap</a>（55+ 个👍）</li><li><a href="https://juejin.im/post/6850037275579121671">玩转前端 Video 播放器 | 多图预警</a>（708+ 个👍）</li><li><a href="https://juejin.im/post/6846687590783909902">玩转前端二进制</a>（359+ 个👍）</li></ul><p>下面我们进入正题，为了让大家能够更好地理解和掌握 WebSocket 技术，我们先来介绍一下什么是 WebSocket。</p><h3 id="一、什么是-WebSocket"><a href="#一、什么是-WebSocket" class="headerlink" title="一、什么是 WebSocket"></a>一、什么是 WebSocket</h3><h4 id="1-1-WebSocket-诞生背景"><a href="#1-1-WebSocket-诞生背景" class="headerlink" title="1.1 WebSocket 诞生背景"></a>1.1 WebSocket 诞生背景</h4><p>早期，很多网站为了实现推送技术，所用的技术都是轮询。轮询是指由浏览器每隔一段时间向服务器发出 HTTP 请求，然后服务器返回最新的数据给客户端。常见的轮询方式分为轮询与长轮询，它们的区别如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e1a4971badd?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>为了更加直观感受轮询与长轮询之间的区别，我们来看一下具体的代码：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e1a49cab9d5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而 HTTP 请求与响应可能会包含较长的头部，其中真正有效的数据可能只是很小的一部分，所以这样会消耗很多带宽资源。</p><p>比较新的轮询技术是 <a href="https://zh.wikipedia.org/wiki/Comet_(web%E6%8A%80%E6%9C%AF)">Comet</a>。这种技术虽然可以实现双向通信，但仍然需要反复发出请求。而且在 Comet 中普遍采用的 HTTP 长连接也会消耗服务器资源。</p><p>在这种情况下，HTML5 定义了 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。Websocket 使用 ws 或 wss 的统一资源标志符（URI），其中 wss 表示使用了 TLS 的 Websocket。如：</p><pre><code>ws://echo.websocket.orgwss://echo.websocket.org复制代码</code></pre><p>WebSocket 与 HTTP 和 HTTPS 使用相同的 TCP 端口，可以绕过大多数防火墙的限制。默认情况下，WebSocket 协议使用 80 端口；若运行在 TLS 之上时，默认使用 443 端口。</p><h4 id="1-2-WebSocket-简介"><a href="#1-2-WebSocket-简介" class="headerlink" title="1.2 WebSocket 简介"></a>1.2 WebSocket 简介</h4><p>WebSocket 是一种网络传输协议，可在单个 TCP 连接上进行全双工通信，位于 OSI 模型的应用层。WebSocket 协议在 2011 年由 IETF 标准化为 <a href="https://tools.ietf.org/html/rfc6455">RFC 6455</a>，后由 <a href="https://tools.ietf.org/html/rfc7936">RFC 7936</a> 补充规范。</p><p>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就可以创建持久性的连接，并进行双向数据传输。</p><p>介绍完轮询和 WebSocket 的相关内容之后，接下来我们来看一下 XHR Polling 与 WebSocket 之间的区别：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e1a49d7b0ad?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h4 id="1-3-WebSocket-优点"><a href="#1-3-WebSocket-优点" class="headerlink" title="1.3 WebSocket 优点"></a>1.3 WebSocket 优点</h4><ul><li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。</li><li>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于 HTTP 请求需要等待客户端发起请求服务端才能响应，延迟明显更少。</li><li>保持连接状态。与 HTTP 不同的是，WebSocket 需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。</li><li>更好的二进制支持。WebSocket 定义了二进制帧，相对 HTTP，可以更轻松地处理二进制内容。</li><li>可以支持扩展。WebSocket 定义了扩展，用户可以扩展协议、实现部分自定义的子协议。</li></ul><p>由于 WebSocket 拥有上述的优点，所以它被广泛地应用在即时通信、实时音视频、在线教育和游戏等领域。对于前端开发者来说，要想使用 WebSocket 提供的强大能力，就必须先掌握 WebSocket API，下面阿宝哥带大家一起来认识一下 WebSocket API。</p><h3 id="二、WebSocket-API"><a href="#二、WebSocket-API" class="headerlink" title="二、WebSocket API"></a>二、WebSocket API</h3><p>在介绍 WebSocket API 之前，我们先来了解一下它的兼容性：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e1a4c1ef050?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>（图片来源：<a href="https://caniuse.com/#search=WebSocket%EF%BC%89">https://caniuse.com/#search=WebSocket）</a></p><p>从上图可知，目前主流的 Web 浏览器都支持 WebSocket，所以我们可以在大多数项目中放心地使用它。</p><p>在浏览器中要使用 WebSocket 提供的能力，我们就必须先创建 WebSocket 对象，该对象提供了用于创建和管理 WebSocket 连接，以及可以通过该连接发送和接收数据的 API。</p><p>使用 WebSocket 构造函数，我们就能轻易地构造一个 WebSocket 对象。接下来我们将从 WebSocket 构造函数、WebSocket 对象的属性、方法及 WebSocket 相关的事件四个方面来介绍 WebSocket API，首先我们从 WebSocket 的构造函数入手：</p><h4 id="2-1-构造函数"><a href="#2-1-构造函数" class="headerlink" title="2.1 构造函数"></a>2.1 构造函数</h4><p>WebSocket 构造函数的语法为：</p><pre><code>const myWebSocket = new WebSocket(url [, protocols]);复制代码</code></pre><p>相关参数说明如下：</p><ul><li>url：表示连接的 URL，这是 WebSocket 服务器将响应的 URL。</li><li>protocols（可选）：一个协议字符串或者一个包含协议字符串的数组。这些字符串用于指定子协议，这样单个服务器可以实现多个 WebSocket 子协议。比如，你可能希望一台服务器能够根据指定的协议（protocol）处理不同类型的交互。如果不指定协议字符串，则假定为空字符串。</li></ul><p>当尝试连接的端口被阻止时，会抛出 <code>SECURITY_ERR</code> 异常。</p><h4 id="2-2-属性"><a href="#2-2-属性" class="headerlink" title="2.2 属性"></a>2.2 属性</h4><p>WebSocket 对象包含以下属性：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e1a4c51c721?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>每个属性的具体含义如下：</p><ul><li><p>binaryType：使用二进制的数据类型连接。</p></li><li><p>bufferedAmount（只读）：未发送至服务器的字节数。</p></li><li><p>extensions（只读）：服务器选择的扩展。</p></li><li><p>onclose：用于指定连接关闭后的回调函数。</p></li><li><p>onerror：用于指定连接失败后的回调函数。</p></li><li><p>onmessage：用于指定当从服务器接受到信息时的回调函数。</p></li><li><p>onopen：用于指定连接成功后的回调函数。</p></li><li><p>protocol（只读）：用于返回服务器端选中的子协议的名字。</p></li><li><p>readyState（只读）：返回当前 WebSocket 的连接状态，共有 4 种状态：</p><ul><li>CONNECTING — 正在连接中，对应的值为 0；</li><li>OPEN — 已经连接并且可以通讯，对应的值为 1；</li><li>CLOSING — 连接正在关闭，对应的值为 2；</li><li>CLOSED — 连接已关闭或者没有连接成功，对应的值为 3。</li></ul></li><li><p>url（只读）：返回值为当构造函数创建 WebSocket 实例对象时 URL 的绝对路径。</p></li></ul><h4 id="2-3-方法"><a href="#2-3-方法" class="headerlink" title="2.3 方法"></a>2.3 方法</h4><ul><li>close([code[, reason]])：该方法用于关闭 WebSocket 连接，如果连接已经关闭，则此方法不执行任何操作。</li><li>send(data)：该方法将需要通过 WebSocket 链接传输至服务器的数据排入队列，并根据所需要传输的数据的大小来增加 bufferedAmount 的值 。若数据无法传输（比如数据需要缓存而缓冲区已满）时，套接字会自行关闭。</li></ul><h4 id="2-4-事件"><a href="#2-4-事件" class="headerlink" title="2.4 事件"></a>2.4 事件</h4><p>使用 addEventListener() 或将一个事件监听器赋值给 WebSocket 对象的 oneventname 属性，来监听下面的事件。</p><ul><li>close：当一个 WebSocket 连接被关闭时触发，也可以通过 onclose 属性来设置。</li><li>error：当一个 WebSocket 连接因错误而关闭时触发，也可以通过 onerror 属性来设置。</li><li>message：当通过 WebSocket 收到数据时触发，也可以通过 onmessage 属性来设置。</li><li>open：当一个 WebSocket 连接成功时触发，也可以通过 onopen 属性来设置。</li></ul><p>介绍完 WebSocket API，我们来举一个使用 WebSocket 发送普通文本的示例。</p><h4 id="2-5-发送普通文本"><a href="#2-5-发送普通文本" class="headerlink" title="2.5 发送普通文本"></a>2.5 发送普通文本</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e1a4c7a5bee?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>在以上示例中，我们在页面上创建了两个 textarea，分别用于存放 <strong>待发送的数据</strong> 和 <strong>服务器返回的数据</strong>。当用户输入完待发送的文本之后，点击 <strong>发送</strong> 按钮时会把输入的文本发送到服务端，而服务端成功接收到消息之后，会把收到的消息原封不动地回传到客户端。</p><pre><code>// const socket = new WebSocket("ws://echo.websocket.org");// const sendMsgContainer = document.querySelector("#sendMessage");function send() &amp;#123;  const message = sendMsgContainer.value;  if (socket.readyState !== WebSocket.OPEN) &amp;#123;    console.log("连接未建立，还不能发送消息");    return;  &amp;#125;  if (message) socket.send(message);&amp;#125;复制代码</code></pre><p>当然客户端接收到服务端返回的消息之后，会把对应的文本内容保存到 <strong>接收的数据</strong> 对应的 textarea 文本框中。</p><pre><code>// const socket = new WebSocket("ws://echo.websocket.org");// const receivedMsgContainer = document.querySelector("#receivedMessage");    socket.addEventListener("message", function (event) &amp;#123;  console.log("Message from server ", event.data);  receivedMsgContainer.value = event.data;&amp;#125;);复制代码</code></pre><p>为了更加直观地理解上述的数据交互过程，我们使用 Chrome 浏览器的开发者工具来看一下相应的过程：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e1907772eaa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>以上示例对应的完整代码如下所示：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;    &lt;title&gt;WebSocket 发送普通文本示例&lt;/title&gt;    &lt;style&gt;      .block &amp;#123;        flex: 1;      &amp;#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h3&gt;阿宝哥：WebSocket 发送普通文本示例&lt;/h3&gt;    &lt;div style="display: flex;"&gt;      &lt;div class="block"&gt;        &lt;p&gt;即将发送的数据：&lt;button onclick="send()"&gt;发送&lt;/button&gt;&lt;/p&gt;        &lt;textarea id="sendMessage" rows="5" cols="15"&gt;&lt;/textarea&gt;      &lt;/div&gt;      &lt;div class="block"&gt;        &lt;p&gt;接收的数据：&lt;/p&gt;        &lt;textarea id="receivedMessage" rows="5" cols="15"&gt;&lt;/textarea&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;      const sendMsgContainer = document.querySelector("#sendMessage");      const receivedMsgContainer = document.querySelector("#receivedMessage");      const socket = new WebSocket("ws://echo.websocket.org");      // 监听连接成功事件      socket.addEventListener("open", function (event) &amp;#123;        console.log("连接成功，可以开始通讯");      &amp;#125;);      // 监听消息      socket.addEventListener("message", function (event) &amp;#123;        console.log("Message from server ", event.data);        receivedMsgContainer.value = event.data;      &amp;#125;);      function send() &amp;#123;        const message = sendMsgContainer.value;        if (socket.readyState !== WebSocket.OPEN) &amp;#123;          console.log("连接未建立，还不能发送消息");          return;        &amp;#125;        if (message) socket.send(message);      &amp;#125;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;复制代码</code></pre><p>其实 WebSocket 除了支持发送普通的文本之外，它还支持发送二进制数据，比如 ArrayBuffer 对象、Blob 对象或者 ArrayBufferView 对象：</p><pre><code>const socket = new WebSocket("ws://echo.websocket.org");socket.onopen = function () &amp;#123;  // 发送UTF-8编码的文本信息  socket.send("Hello Echo Server!");  // 发送UTF-8编码的JSON数据  socket.send(JSON.stringify(&amp;#123; msg: "我是阿宝哥" &amp;#125;));  // 发送二进制ArrayBuffer  const buffer = new ArrayBuffer(128);  socket.send(buffer);  // 发送二进制ArrayBufferView  const intview = new Uint32Array(buffer);  socket.send(intview);  // 发送二进制Blob  const blob = new Blob([buffer]);  socket.send(blob);&amp;#125;;复制代码</code></pre><p>以上代码成功运行后，通过 Chrome 开发者工具，我们可以看到对应的数据交互过程：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e1906c605c4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>下面阿宝哥以发送 Blob 对象为例，来介绍一下如何发送二进制数据。</p><blockquote><p>Blob（Binary Large Object）表示二进制类型的大对象。在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。<strong>在 JavaScript 中 Blob 类型的对象表示不可变的类似文件对象的原始数据。</strong></p><p>对 Blob 感兴趣的小伙伴，可以阅读 <a href="https://juejin.im/post/6844904178725158926">“你不知道的 Blob”</a> 这篇文章。</p></blockquote><h4 id="2-6-发送二进制数据"><a href="#2-6-发送二进制数据" class="headerlink" title="2.6 发送二进制数据"></a>2.6 发送二进制数据</h4><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e1907e4cb3e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>在以上示例中，我们在页面上创建了两个 textarea，分别用于存放 <strong>待发送的数据</strong> 和 <strong>服务器返回的数据</strong>。当用户输入完待发送的文本之后，点击 <strong>发送</strong> 按钮时，我们会先获取输入的文本并把文本包装成 Blob 对象然后发送到服务端，而服务端成功接收到消息之后，会把收到的消息原封不动地回传到客户端。</p><p>当浏览器接收到新消息后，如果是文本数据，会自动将其转换成 DOMString 对象，如果是二进制数据或 Blob 对象，会直接将其转交给应用，由应用自身来根据返回的数据类型进行相应的处理。</p><p><strong>数据发送代码</strong></p><pre><code>// const socket = new WebSocket("ws://echo.websocket.org");// const sendMsgContainer = document.querySelector("#sendMessage");function send() &amp;#123;  const message = sendMsgContainer.value;  if (socket.readyState !== WebSocket.OPEN) &amp;#123;    console.log("连接未建立，还不能发送消息");    return;  &amp;#125;  const blob = new Blob([message], &amp;#123; type: "text/plain" &amp;#125;);  if (message) socket.send(blob);  console.log(`未发送至服务器的字节数：$&amp;#123;socket.bufferedAmount&amp;#125;`);&amp;#125;复制代码</code></pre><p>当然客户端接收到服务端返回的消息之后，会判断返回的数据类型，如果是 Blob 类型的话，会调用 Blob 对象的 text() 方法，获取 Blob 对象中保存的 UTF-8 格式的内容，然后把对应的文本内容保存到 <strong>接收的数据</strong> 对应的 textarea 文本框中。</p><p><strong>数据接收代码</strong></p><pre><code>// const socket = new WebSocket("ws://echo.websocket.org");// const receivedMsgContainer = document.querySelector("#receivedMessage");socket.addEventListener("message", async function (event) &amp;#123;  console.log("Message from server ", event.data);  const receivedData = event.data;  if (receivedData instanceof Blob) &amp;#123;    receivedMsgContainer.value = await receivedData.text();  &amp;#125; else &amp;#123;    receivedMsgContainer.value = receivedData;  &amp;#125; &amp;#125;);复制代码</code></pre><p>同样，我们使用 Chrome 浏览器的开发者工具来看一下相应的过程：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e1912c4f2e5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>通过上图我们可以很明显地看到，当使用发送 Blob 对象时，Data 栏位的信息显示的是 <strong>Binary Message</strong>，而对于发送普通文本来说，Data 栏位的信息是直接显示发送的文本消息。</p><p>以上示例对应的完整代码如下所示：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta charset="UTF-8" /&gt;    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;    &lt;title&gt;WebSocket 发送二进制数据示例&lt;/title&gt;    &lt;style&gt;      .block &amp;#123;        flex: 1;      &amp;#125;    &lt;/style&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h3&gt;阿宝哥：WebSocket 发送二进制数据示例&lt;/h3&gt;    &lt;div style="display: flex;"&gt;      &lt;div class="block"&gt;        &lt;p&gt;待发送的数据：&lt;button onclick="send()"&gt;发送&lt;/button&gt;&lt;/p&gt;        &lt;textarea id="sendMessage" rows="5" cols="15"&gt;&lt;/textarea&gt;      &lt;/div&gt;      &lt;div class="block"&gt;        &lt;p&gt;接收的数据：&lt;/p&gt;        &lt;textarea id="receivedMessage" rows="5" cols="15"&gt;&lt;/textarea&gt;      &lt;/div&gt;    &lt;/div&gt;    &lt;script&gt;      const sendMsgContainer = document.querySelector("#sendMessage");      const receivedMsgContainer = document.querySelector("#receivedMessage");      const socket = new WebSocket("ws://echo.websocket.org");      // 监听连接成功事件      socket.addEventListener("open", function (event) &amp;#123;        console.log("连接成功，可以开始通讯");      &amp;#125;);      // 监听消息      socket.addEventListener("message", async function (event) &amp;#123;        console.log("Message from server ", event.data);        const receivedData = event.data;        if (receivedData instanceof Blob) &amp;#123;          receivedMsgContainer.value = await receivedData.text();        &amp;#125; else &amp;#123;          receivedMsgContainer.value = receivedData;        &amp;#125;      &amp;#125;);      function send() &amp;#123;        const message = sendMsgContainer.value;        if (socket.readyState !== WebSocket.OPEN) &amp;#123;          console.log("连接未建立，还不能发送消息");          return;        &amp;#125;        const blob = new Blob([message], &amp;#123; type: "text/plain" &amp;#125;);        if (message) socket.send(blob);        console.log(`未发送至服务器的字节数：$&amp;#123;socket.bufferedAmount&amp;#125;`);      &amp;#125;    &lt;/script&gt;  &lt;/body&gt;&lt;/html&gt;复制代码</code></pre><p>可能有一些小伙伴了解完 WebSocket API 之后，觉得还不够过瘾。下面阿宝哥将带大家来实现一个支持发送普通文本的 WebSocket 服务器。</p><h3 id="三、手写-WebSocket-服务器"><a href="#三、手写-WebSocket-服务器" class="headerlink" title="三、手写 WebSocket 服务器"></a>三、手写 WebSocket 服务器</h3><p>在介绍如何手写 WebSocket 服务器前，我们需要了解一下 WebSocket 连接的生命周期。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e192b2cc1a2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>从上图可知，在使用 WebSocket 实现全双工通信之前，客户端与服务器之间需要先进行握手（Handshake），在完成握手之后才能开始进行数据的双向通信。</p><p>握手是在通信电路创建之后，信息传输开始之前。<strong>握手用于达成参数，如信息传输率，字母表，奇偶校验，中断过程，和其他协议特性。</strong> 握手有助于不同结构的系统或设备在通信信道中连接，而不需要人为设置参数。</p><p>既然握手是 WebSocket 连接生命周期的第一个环节，接下来我们就先来分析 WebSocket 的握手协议。</p><h4 id="3-1-握手协议"><a href="#3-1-握手协议" class="headerlink" title="3.1 握手协议"></a>3.1 握手协议</h4><p>WebSocket 协议属于应用层协议，它依赖于传输层的 TCP 协议。WebSocket 通过 HTTP/1.1 协议的 <strong>101</strong> 状态码进行握手。为了创建 WebSocket 连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为 “握手”（Handshaking）。</p><p>利用 HTTP 完成握手有几个好处。首先，让 WebSocket 与现有 HTTP 基础设施兼容：使得 WebSocket 服务器可以运行在 80 和 443 端口上，这通常是对客户端唯一开放的端口。其次，让我们可以重用并扩展 HTTP 的 Upgrade 流，为其添加自定义的 WebSocket 首部，以完成协商。</p><p>下面我们以前面已经演示过的发送普通文本的例子为例，来具体分析一下握手过程。</p><h5 id="3-1-1-客户端请求"><a href="#3-1-1-客户端请求" class="headerlink" title="3.1.1 客户端请求"></a>3.1.1 客户端请求</h5><pre><code>GET ws://echo.websocket.org/ HTTP/1.1Host: echo.websocket.orgOrigin: file://Connection: UpgradeUpgrade: websocketSec-WebSocket-Version: 13Sec-WebSocket-Key: Zx8rNEkBE4xnwifpuh8DHQ==Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits复制代码</code></pre><blockquote><p>备注：已忽略部分 HTTP 请求头</p></blockquote><p><strong>字段说明</strong></p><ul><li>Connection 必须设置 Upgrade，表示客户端希望连接升级。</li><li>Upgrade 字段必须设置 websocket，表示希望升级到 WebSocket 协议。</li><li>Sec-WebSocket-Version 表示支持的 WebSocket 版本。RFC6455 要求使用的版本是 13，之前草案的版本均应当弃用。</li><li>Sec-WebSocket-Key 是随机的字符串，服务器端会用这些数据来构造出一个 SHA-1 的信息摘要。把 “Sec-WebSocket-Key” 加上一个特殊字符串 <strong>“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”</strong>，然后计算 SHA-1 摘要，之后进行 Base64 编码，将结果做为 “Sec-WebSocket-Accept” 头的值，返回给客户端。如此操作，可以尽量避免普通 HTTP 请求被误认为 WebSocket 协议。</li><li>Sec-WebSocket-Extensions 用于协商本次连接要使用的 WebSocket 扩展：客户端发送支持的扩展，服务器通过返回相同的首部确认自己支持一个或多个扩展。</li><li>Origin 字段是可选的，通常用来表示在浏览器中发起此 WebSocket 连接所在的页面，类似于 Referer。但是，与 Referer 不同的是，Origin 只包含了协议和主机名称。</li></ul><h5 id="3-1-2-服务端响应"><a href="#3-1-2-服务端响应" class="headerlink" title="3.1.2 服务端响应"></a>3.1.2 服务端响应</h5><pre><code>HTTP/1.1 101 Web Socket Protocol Handshake ①Connection: Upgrade ②Upgrade: websocket ③Sec-WebSocket-Accept: 52Rg3vW4JQ1yWpkvFlsTsiezlqw= ④复制代码</code></pre><blockquote><p>备注：已忽略部分 HTTP 响应头</p></blockquote><ul><li>① 101 响应码确认升级到 WebSocket 协议。</li><li>② 设置 Connection 头的值为 “Upgrade” 来指示这是一个升级请求。HTTP 协议提供了一种特殊的机制，这一机制允许将一个已建立的连接升级成新的、不相容的协议。</li><li>③ Upgrade 头指定一项或多项协议名，按优先级排序，以逗号分隔。这里表示升级为 WebSocket 协议。</li><li>④ 签名的键值验证协议支持。</li></ul><p>介绍完 WebSocket 的握手协议，接下来阿宝哥将使用 Node.js 来开发我们的 WebSocket 服务器。</p><h4 id="3-2-实现握手功能"><a href="#3-2-实现握手功能" class="headerlink" title="3.2 实现握手功能"></a>3.2 实现握手功能</h4><p>要开发一个 WebSocket 服务器，首先我们需要先实现握手功能，这里阿宝哥使用 Node.js 内置的 <strong>http</strong> 模块来创建一个 HTTP 服务器，具体代码如下所示：</p><pre><code>const http = require("http");const port = 8888;const &amp;#123; generateAcceptValue &amp;#125; = require("./util");const server = http.createServer((req, res) =&gt; &amp;#123;  res.writeHead(200, &amp;#123; "Content-Type": "text/plain; charset=utf-8" &amp;#125;);  res.end("大家好，我是阿宝哥。感谢你阅读“你不知道的WebSocket”");&amp;#125;);server.on("upgrade", function (req, socket) &amp;#123;  if (req.headers["upgrade"] !== "websocket") &amp;#123;    socket.end("HTTP/1.1 400 Bad Request");    return;  &amp;#125;  // 读取客户端提供的Sec-WebSocket-Key  const secWsKey = req.headers["sec-websocket-key"];  // 使用SHA-1算法生成Sec-WebSocket-Accept  const hash = generateAcceptValue(secWsKey);  // 设置HTTP响应头  const responseHeaders = [    "HTTP/1.1 101 Web Socket Protocol Handshake",    "Upgrade: WebSocket",    "Connection: Upgrade",    `Sec-WebSocket-Accept: $&amp;#123;hash&amp;#125;`,  ];  // 返回握手请求的响应信息  socket.write(responseHeaders.join("\r\n") + "\r\n\r\n");&amp;#125;);server.listen(port, () =&gt;  console.log(`Server running at http://localhost:$&amp;#123;port&amp;#125;`));复制代码</code></pre><p>在以上代码中，我们首先引入了 <strong>http</strong> 模块，然后通过调用该模块的 <code>createServer()</code> 方法创建一个 HTTP 服务器，接着我们监听 <code>upgrade</code> 事件，每次服务器响应升级请求时就会触发该事件。由于我们的服务器只支持升级到 WebSocket 协议，所以如果客户端请求升级的协议非 WebSocket 协议，我们将会返回 “400 Bad Request”。</p><p>当服务器接收到升级为 WebSocket 的握手请求时，会先从请求头中获取 <strong>“Sec-WebSocket-Key”</strong> 的值，然后把该值加上一个特殊字符串 <strong>“258EAFA5-E914-47DA-95CA-C5AB0DC85B11”</strong>，然后计算 SHA-1 摘要，之后进行 Base64 编码，将结果做为 <strong>“Sec-WebSocket-Accept”</strong> 头的值，返回给客户端。</p><p>上述的过程看起来好像有点繁琐，其实利用 Node.js 内置的 <strong>crypto</strong> 模块，几行代码就可以搞定了：</p><pre><code>// util.jsconst crypto = require("crypto");const MAGIC_KEY = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";function generateAcceptValue(secWsKey) &amp;#123;  return crypto    .createHash("sha1")    .update(secWsKey + MAGIC_KEY, "utf8")    .digest("base64");&amp;#125;复制代码</code></pre><p>开发完握手功能之后，我们可以使用前面的示例来测试一下该功能。待服务器启动之后，我们只要对 “发送普通文本” 示例，做简单地调整，即把先前的 URL 地址替换成 <code>ws://localhost:8888</code>，就可以进行功能验证。</p><p>感兴趣的小伙们可以试试看，以下是阿宝哥本地运行后的结果：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e19930d1e9d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>从上图可知，我们实现的握手功能已经可以正常工作了。那么握手有没有可能失败呢？答案是肯定的。比如网络问题、服务器异常或 <strong>Sec-WebSocket-Accept</strong> 的值不正确。</p><p>下面阿宝哥修改一下 <strong>“Sec-WebSocket-Accept”</strong> 生成规则，比如修改 <strong>MAGIC_KEY</strong> 的值，然后重新验证一下握手功能。此时，浏览器的控制台会输出以下异常信息：</p><pre><code>WebSocket connection to 'ws://localhost:8888/' failed: Error during WebSocket handshake: Incorrect 'Sec-WebSocket-Accept' header value复制代码</code></pre><p>如果你的 WebSocket 服务器要支持子协议的话，你可以参考以下代码进行子协议的处理，阿宝哥就不继续展开介绍了。</p><pre><code>// 从请求头中读取子协议const protocol = req.headers["sec-websocket-protocol"];// 如果包含子协议，则解析子协议const protocols = !protocol ? [] : protocol.split(",").map((s) =&gt; s.trim());// 简单起见，我们仅判断是否含有JSON子协议if (protocols.includes("json")) &amp;#123;  responseHeaders.push(`Sec-WebSocket-Protocol: json`);&amp;#125;复制代码</code></pre><p>好的，WebSocket 握手协议相关的内容基本已经介绍完了。下一步我们来介绍开发消息通信功能需要了解的一些基础知识。</p><h4 id="3-3-消息通信基础"><a href="#3-3-消息通信基础" class="headerlink" title="3.3 消息通信基础"></a>3.3 消息通信基础</h4><p>在 WebSocket 协议中，数据是通过一系列数据帧来进行传输的。为了避免由于网络中介（例如一些拦截代理）或者一些安全问题，客户端必须在它发送到服务器的所有帧中添加掩码。服务端收到没有添加掩码的数据帧以后，必须立即关闭连接。</p><h5 id="3-3-1-数据帧格式"><a href="#3-3-1-数据帧格式" class="headerlink" title="3.3.1 数据帧格式"></a>3.3.1 数据帧格式</h5><p>要实现消息通信，我们就必须了解 WebSocket 数据帧的格式：</p><pre><code> 0                   1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-------+-+-------------+-------------------------------+|F|R|R|R| opcode|M| Payload len |    Extended payload length    ||I|S|S|S|  (4)  |A|     (7)     |             (16/64)           ||N|V|V|V|       |S|             |   (if payload len==126/127)   || |1|2|3|       |K|             |                               |+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +|     Extended payload length continued, if payload len == 127  |+ - - - - - - - - - - - - - - - +-------------------------------+|                               |Masking-key, if MASK set to 1  |+-------------------------------+-------------------------------+| Masking-key (continued)       |          Payload Data         |+-------------------------------- - - - - - - - - - - - - - - - +:                     Payload Data continued ...                :+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +|                     Payload Data continued ...                |+---------------------------------------------------------------+复制代码</code></pre><p>可能有一些小伙伴看到上面的内容之后，就开始有点 “懵逼” 了。下面我们来结合实际的数据帧来进一步分析一下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e199a03ed41?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>在上图中，阿宝哥简单分析了 “发送普通文本” 示例对应的数据帧格式。这里我们来进一步介绍一下 Payload length，因为在后面开发数据解析功能的时候，需要用到该知识点。</p><p>Payload length 表示以字节为单位的 “有效负载数据” 长度。它有以下几种情形：</p><ul><li>如果值为 0-125，那么就表示负载数据的长度。</li><li>如果是 126，那么接下来的 2 个字节解释为 16 位的无符号整形作为负载数据的长度。</li><li>如果是 127，那么接下来的 8 个字节解释为一个 64 位的无符号整形（最高位的 bit 必须为 0）作为负载数据的长度。</li></ul><p>多字节长度量以网络字节顺序表示，有效负载长度是指 “扩展数据” + “应用数据” 的长度。“扩展数据” 的长度可能为 0，那么有效负载长度就是 “应用数据” 的长度。</p><p>另外，除非协商过扩展，否则 “扩展数据” 长度为 0 字节。在握手协议中，任何扩展都必须指定 “扩展数据” 的长度，这个长度如何进行计算，以及这个扩展如何使用。如果存在扩展，那么这个 “扩展数据” 包含在总的有效负载长度中。</p><h5 id="3-3-2-掩码算法"><a href="#3-3-2-掩码算法" class="headerlink" title="3.3.2 掩码算法"></a>3.3.2 掩码算法</h5><p>掩码字段是一个由客户端随机选择的 32 位的值。掩码值必须是不可被预测的。因此，掩码必须来自强大的熵源（entropy），并且给定的掩码不能让服务器或者代理能够很容易的预测到后续帧。掩码的不可预测性对于预防恶意应用的作者在网上暴露相关的字节数据至关重要。</p><p>掩码不影响数据荷载的长度，对数据进行掩码操作和对数据进行反掩码操作所涉及的步骤是相同的。掩码、反掩码操作都采用如下算法：</p><pre><code>j = i MOD 4transformed-octet-i = original-octet-i XOR masking-key-octet-j复制代码</code></pre><ul><li>original-octet-i：为原始数据的第 i 字节。</li><li>transformed-octet-i：为转换后的数据的第 i 字节。</li><li>masking-key-octet-j：为 mask key 第 j 字节。</li></ul><p>为了让小伙伴们能够更好的理解上面掩码的计算过程，我们来对示例中 <strong>“我是阿宝哥”</strong> 数据进行掩码操作。这里 <strong>“我是阿宝哥”</strong> 对应的 UTF-8 编码如下所示：</p><pre><code>E6 88 91 E6 98 AF E9 98 BF E5 AE 9D E5 93 A5复制代码</code></pre><p>而对应的 Masking-Key 为 <code>0x08f6efb1</code>，根据上面的算法，我们可以这样进行掩码运算：</p><pre><code>let uint8 = new Uint8Array([0xE6, 0x88, 0x91, 0xE6, 0x98, 0xAF, 0xE9, 0x98,   0xBF, 0xE5, 0xAE, 0x9D, 0xE5, 0x93, 0xA5]);let maskingKey = new Uint8Array([0x08, 0xf6, 0xef, 0xb1]);let maskedUint8 = new Uint8Array(uint8.length);for (let i = 0, j = 0; i &lt; uint8.length; i++, j = i % 4) &amp;#123;  maskedUint8[i] = uint8[i] ^ maskingKey[j];&amp;#125;console.log(Array.from(maskedUint8).map(num=&gt;Number(num).toString(16)).join(' '));复制代码</code></pre><p>以上代码成功运行后，控制台会输出以下结果：</p><pre><code>ee 7e 7e 57 90 59 6 29 b7 13 41 2c ed 65 4a复制代码</code></pre><p>上述结果与 WireShark 中的 Masked payload 对应的值是一致的，具体如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e19aab98024?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>在 WebSocket 协议中，数据掩码的作用是增强协议的安全性。但数据掩码并不是为了保护数据本身，因为算法本身是公开的，运算也不复杂。那么为什么还要引入数据掩码呢？引入数据掩码是为了防止早期版本的协议中存在的代理缓存污染攻击等问题。</p><p>了解完 WebSocket 掩码算法和数据掩码的作用之后，我们再来介绍一下数据分片的概念。</p><h5 id="3-3-3-数据分片"><a href="#3-3-3-数据分片" class="headerlink" title="3.3.3 数据分片"></a>3.3.3 数据分片</h5><p>WebSocket 的每条消息可能被切分成多个数据帧。当 WebSocket 的接收方收到一个数据帧时，会根据 FIN 的值来判断，是否已经收到消息的最后一个数据帧。</p><p>利用 FIN 和 Opcode，我们就可以跨帧发送消息。操作码告诉了帧应该做什么。如果是 0x1，有效载荷就是文本。如果是 0x2，有效载荷就是二进制数据。但是，如果是 0x0，则该帧是一个延续帧。这意味着服务器应该将帧的有效负载连接到从该客户机接收到的最后一个帧。</p><p>为了让大家能够更好地理解上述的内容，我们来看一个来自 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API/Writing_WebSocket_servers">MDN</a> 上的示例：</p><pre><code>Client: FIN=1, opcode=0x1, msg="hello"Server: (process complete message immediately) Hi.Client: FIN=0, opcode=0x1, msg="and a"Server: (listening, new message containing text started)Client: FIN=0, opcode=0x0, msg="happy new"Server: (listening, payload concatenated to previous message)Client: FIN=1, opcode=0x0, msg="year!"Server: (process complete message) Happy new year to you too!复制代码</code></pre><p>在以上示例中，客户端向服务器发送了两条消息。第一个消息在单个帧中发送，而第二个消息跨三个帧发送。</p><p>其中第一个消息是一个完整的消息（FIN=1 且 opcode != 0x0)，因此服务器可以根据需要进行处理或响应。而第二个消息是文本消息（opcode=0x1）且 FIN=0，表示消息还没发送完成，还有后续的数据帧。该消息的所有剩余部分都用延续帧（opcode=0x0）发送，消息的最终帧用 FIN=1 标记。</p><p>好的，简单介绍了数据分片的相关内容。接下来，我们来开始实现消息通信功能。</p><h4 id="3-4-实现消息通信功能"><a href="#3-4-实现消息通信功能" class="headerlink" title="3.4 实现消息通信功能"></a>3.4 实现消息通信功能</h4><p>阿宝哥把实现消息通信功能，分解为消息解析与消息响应两个子功能，下面我们分别来介绍如何实现这两个子功能。</p><h5 id="3-4-1-消息解析"><a href="#3-4-1-消息解析" class="headerlink" title="3.4.1 消息解析"></a>3.4.1 消息解析</h5><p>利用消息通信基础环节中介绍的相关知识，阿宝哥实现了一个 parseMessage 函数，用来解析客户端传过来的 WebSocket 数据帧。出于简单考虑，这里只处理文本帧，具体代码如下所示：</p><pre><code>function parseMessage(buffer) &amp;#123;  // 第一个字节，包含了FIN位，opcode, 掩码位  const firstByte = buffer.readUInt8(0);  // [FIN, RSV, RSV, RSV, OPCODE, OPCODE, OPCODE, OPCODE];  // 右移7位取首位，1位，表示是否是最后一帧数据  const isFinalFrame = Boolean((firstByte &gt;&gt;&gt; 7) &amp; 0x01);  console.log("isFIN: ", isFinalFrame);  // 取出操作码，低四位  /**   * %x0：表示一个延续帧。当 Opcode 为 0 时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片；   * %x1：表示这是一个文本帧（text frame）；   * %x2：表示这是一个二进制帧（binary frame）；   * %x3-7：保留的操作代码，用于后续定义的非控制帧；   * %x8：表示连接断开；   * %x9：表示这是一个心跳请求（ping）；   * %xA：表示这是一个心跳响应（pong）；   * %xB-F：保留的操作代码，用于后续定义的控制帧。   */  const opcode = firstByte &amp; 0x0f;  if (opcode === 0x08) &amp;#123;    // 连接关闭    return;  &amp;#125;  if (opcode === 0x02) &amp;#123;    // 二进制帧    return;  &amp;#125;  if (opcode === 0x01) &amp;#123;    // 目前只处理文本帧    let offset = 1;    const secondByte = buffer.readUInt8(offset);    // MASK: 1位，表示是否使用了掩码，在发送给服务端的数据帧里必须使用掩码，而服务端返回时不需要掩码    const useMask = Boolean((secondByte &gt;&gt;&gt; 7) &amp; 0x01);    console.log("use MASK: ", useMask);    const payloadLen = secondByte &amp; 0x7f; // 低7位表示载荷字节长度    offset += 1;    // 四个字节的掩码    let MASK = [];    // 如果这个值在0-125之间，则后面的4个字节（32位）就应该被直接识别成掩码；    if (payloadLen &lt;= 0x7d) &amp;#123;      // 载荷长度小于125      MASK = buffer.slice(offset, 4 + offset);      offset += 4;      console.log("payload length: ", payloadLen);    &amp;#125; else if (payloadLen === 0x7e) &amp;#123;      // 如果这个值是126，则后面两个字节（16位）内容应该，被识别成一个16位的二进制数表示数据内容大小；      console.log("payload length: ", buffer.readInt16BE(offset));      // 长度是126， 则后面两个字节作为payload length，32位的掩码      MASK = buffer.slice(offset + 2, offset + 2 + 4);      offset += 6;    &amp;#125; else &amp;#123;      // 如果这个值是127，则后面的8个字节（64位）内容应该被识别成一个64位的二进制数表示数据内容大小      MASK = buffer.slice(offset + 8, offset + 8 + 4);      offset += 12;    &amp;#125;    // 开始读取后面的payload，与掩码计算，得到原来的字节内容    const newBuffer = [];    const dataBuffer = buffer.slice(offset);    for (let i = 0, j = 0; i &lt; dataBuffer.length; i++, j = i % 4) &amp;#123;      const nextBuf = dataBuffer[i];      newBuffer.push(nextBuf ^ MASK[j]);    &amp;#125;    return Buffer.from(newBuffer).toString();  &amp;#125;  return "";&amp;#125;复制代码</code></pre><p>创建完 parseMessage 函数，我们来更新一下之前创建的 WebSocket 服务器：</p><pre><code>server.on("upgrade", function (req, socket) &amp;#123;  socket.on("data", (buffer) =&gt; &amp;#123;    const message = parseMessage(buffer);    if (message) &amp;#123;      console.log("Message from client:" + message);    &amp;#125; else if (message === null) &amp;#123;      console.log("WebSocket connection closed by the client.");    &amp;#125;  &amp;#125;);  if (req.headers["upgrade"] !== "websocket") &amp;#123;    socket.end("HTTP/1.1 400 Bad Request");    return;  &amp;#125;  // 省略已有代码&amp;#125;);复制代码</code></pre><p>更新完成之后，我们重新启动服务器，然后继续使用 “发送普通文本” 的示例来测试消息解析功能。以下发送 “我是阿宝哥” 文本消息后，WebSocket 服务器输出的信息。</p><pre><code>Server running at http://localhost:8888isFIN:  trueuse MASK:  truepayload length:  15Message from client:我是阿宝哥复制代码</code></pre><p>通过观察以上的输出信息，我们的 WebSocket 服务器已经可以成功解析客户端发送包含普通文本的数据帧，下一步我们来实现消息响应的功能。</p><h5 id="3-4-2-消息响应"><a href="#3-4-2-消息响应" class="headerlink" title="3.4.2 消息响应"></a>3.4.2 消息响应</h5><p>要把数据返回给客户端，我们的 WebSocket 服务器也得按照 WebSocket 数据帧的格式来封装数据。与前面介绍的 parseMessage 函数一样，阿宝哥也封装了一个 constructReply 函数用来封装返回的数据，该函数的具体代码如下：</p><pre><code>function constructReply(data) &amp;#123;  const json = JSON.stringify(data);  const jsonByteLength = Buffer.byteLength(json);  // 目前只支持小于65535字节的负载  const lengthByteCount = jsonByteLength &lt; 126 ? 0 : 2;  const payloadLength = lengthByteCount === 0 ? jsonByteLength : 126;  const buffer = Buffer.alloc(2 + lengthByteCount + jsonByteLength);  // 设置数据帧首字节，设置opcode为1，表示文本帧  buffer.writeUInt8(0b10000001, 0);  buffer.writeUInt8(payloadLength, 1);  // 如果payloadLength为126，则后面两个字节（16位）内容应该，被识别成一个16位的二进制数表示数据内容大小  let payloadOffset = 2;  if (lengthByteCount &gt; 0) &amp;#123;    buffer.writeUInt16BE(jsonByteLength, 2);    payloadOffset += lengthByteCount;  &amp;#125;  // 把JSON数据写入到Buffer缓冲区中  buffer.write(json, payloadOffset);  return buffer;&amp;#125;复制代码</code></pre><p>创建完 constructReply 函数，我们再来更新一下之前创建的 WebSocket 服务器：</p><pre><code>server.on("upgrade", function (req, socket) &amp;#123;  socket.on("data", (buffer) =&gt; &amp;#123;    const message = parseMessage(buffer);    if (message) &amp;#123;      console.log("Message from client:" + message);      // 新增以下👇代码      socket.write(constructReply(&amp;#123; message &amp;#125;));    &amp;#125; else if (message === null) &amp;#123;      console.log("WebSocket connection closed by the client.");    &amp;#125;  &amp;#125;);&amp;#125;);复制代码</code></pre><p>到这里，我们的 WebSocket 服务器已经开发完成了，接下来我们来完整验证一下它的功能。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e19b333840e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>从图中可知，我们的开发的简易版 WebSocket 服务器已经可以正常处理普通文本消息了。最后我们来看一下完整的代码：</p><p><strong>custom-websocket-server.js</strong></p><pre><code>const http = require("http");const port = 8888;const &amp;#123; generateAcceptValue, parseMessage, constructReply &amp;#125; = require("./util");const server = http.createServer((req, res) =&gt; &amp;#123;  res.writeHead(200, &amp;#123; "Content-Type": "text/plain; charset=utf-8" &amp;#125;);  res.end("大家好，我是阿宝哥。感谢你阅读“你不知道的WebSocket”");&amp;#125;);server.on("upgrade", function (req, socket) &amp;#123;  socket.on("data", (buffer) =&gt; &amp;#123;    const message = parseMessage(buffer);    if (message) &amp;#123;      console.log("Message from client:" + message);      socket.write(constructReply(&amp;#123; message &amp;#125;));    &amp;#125; else if (message === null) &amp;#123;      console.log("WebSocket connection closed by the client.");    &amp;#125;  &amp;#125;);  if (req.headers["upgrade"] !== "websocket") &amp;#123;    socket.end("HTTP/1.1 400 Bad Request");    return;  &amp;#125;  // 读取客户端提供的Sec-WebSocket-Key  const secWsKey = req.headers["sec-websocket-key"];  // 使用SHA-1算法生成Sec-WebSocket-Accept  const hash = generateAcceptValue(secWsKey);  // 设置HTTP响应头  const responseHeaders = [    "HTTP/1.1 101 Web Socket Protocol Handshake",    "Upgrade: WebSocket",    "Connection: Upgrade",    `Sec-WebSocket-Accept: $&amp;#123;hash&amp;#125;`,  ];  // 返回握手请求的响应信息  socket.write(responseHeaders.join("\r\n") + "\r\n\r\n");&amp;#125;);server.listen(port, () =&gt;  console.log(`Server running at http://localhost:$&amp;#123;port&amp;#125;`));复制代码</code></pre><p><strong>util.js</strong></p><pre><code>const crypto = require("crypto");const MAGIC_KEY = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";function generateAcceptValue(secWsKey) &amp;#123;  return crypto    .createHash("sha1")    .update(secWsKey + MAGIC_KEY, "utf8")    .digest("base64");&amp;#125;function parseMessage(buffer) &amp;#123;  // 第一个字节，包含了FIN位，opcode, 掩码位  const firstByte = buffer.readUInt8(0);  // [FIN, RSV, RSV, RSV, OPCODE, OPCODE, OPCODE, OPCODE];  // 右移7位取首位，1位，表示是否是最后一帧数据  const isFinalFrame = Boolean((firstByte &gt;&gt;&gt; 7) &amp; 0x01);  console.log("isFIN: ", isFinalFrame);  // 取出操作码，低四位  /**   * %x0：表示一个延续帧。当 Opcode 为 0 时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片；   * %x1：表示这是一个文本帧（text frame）；   * %x2：表示这是一个二进制帧（binary frame）；   * %x3-7：保留的操作代码，用于后续定义的非控制帧；   * %x8：表示连接断开；   * %x9：表示这是一个心跳请求（ping）；   * %xA：表示这是一个心跳响应（pong）；   * %xB-F：保留的操作代码，用于后续定义的控制帧。   */  const opcode = firstByte &amp; 0x0f;  if (opcode === 0x08) &amp;#123;    // 连接关闭    return;  &amp;#125;  if (opcode === 0x02) &amp;#123;    // 二进制帧    return;  &amp;#125;  if (opcode === 0x01) &amp;#123;    // 目前只处理文本帧    let offset = 1;    const secondByte = buffer.readUInt8(offset);    // MASK: 1位，表示是否使用了掩码，在发送给服务端的数据帧里必须使用掩码，而服务端返回时不需要掩码    const useMask = Boolean((secondByte &gt;&gt;&gt; 7) &amp; 0x01);    console.log("use MASK: ", useMask);    const payloadLen = secondByte &amp; 0x7f; // 低7位表示载荷字节长度    offset += 1;    // 四个字节的掩码    let MASK = [];    // 如果这个值在0-125之间，则后面的4个字节（32位）就应该被直接识别成掩码；    if (payloadLen &lt;= 0x7d) &amp;#123;      // 载荷长度小于125      MASK = buffer.slice(offset, 4 + offset);      offset += 4;      console.log("payload length: ", payloadLen);    &amp;#125; else if (payloadLen === 0x7e) &amp;#123;      // 如果这个值是126，则后面两个字节（16位）内容应该，被识别成一个16位的二进制数表示数据内容大小；      console.log("payload length: ", buffer.readInt16BE(offset));      // 长度是126， 则后面两个字节作为payload length，32位的掩码      MASK = buffer.slice(offset + 2, offset + 2 + 4);      offset += 6;    &amp;#125; else &amp;#123;      // 如果这个值是127，则后面的8个字节（64位）内容应该被识别成一个64位的二进制数表示数据内容大小      MASK = buffer.slice(offset + 8, offset + 8 + 4);      offset += 12;    &amp;#125;    // 开始读取后面的payload，与掩码计算，得到原来的字节内容    const newBuffer = [];    const dataBuffer = buffer.slice(offset);    for (let i = 0, j = 0; i &lt; dataBuffer.length; i++, j = i % 4) &amp;#123;      const nextBuf = dataBuffer[i];      newBuffer.push(nextBuf ^ MASK[j]);    &amp;#125;    return Buffer.from(newBuffer).toString();  &amp;#125;  return "";&amp;#125;function constructReply(data) &amp;#123;  const json = JSON.stringify(data);  const jsonByteLength = Buffer.byteLength(json);  // 目前只支持小于65535字节的负载  const lengthByteCount = jsonByteLength &lt; 126 ? 0 : 2;  const payloadLength = lengthByteCount === 0 ? jsonByteLength : 126;  const buffer = Buffer.alloc(2 + lengthByteCount + jsonByteLength);  // 设置数据帧首字节，设置opcode为1，表示文本帧  buffer.writeUInt8(0b10000001, 0);  buffer.writeUInt8(payloadLength, 1);  // 如果payloadLength为126，则后面两个字节（16位）内容应该，被识别成一个16位的二进制数表示数据内容大小  let payloadOffset = 2;  if (lengthByteCount &gt; 0) &amp;#123;    buffer.writeUInt16BE(jsonByteLength, 2);    payloadOffset += lengthByteCount;  &amp;#125;  // 把JSON数据写入到Buffer缓冲区中  buffer.write(json, payloadOffset);  return buffer;&amp;#125;module.exports = &amp;#123;  generateAcceptValue,  parseMessage,  constructReply,&amp;#125;;复制代码</code></pre><p>其实服务器向浏览器推送信息，除了使用 WebSocket 技术之外，还可以使用 SSE（Server-Sent Events）。它让服务器可以向客户端流式发送文本消息，比如服务器上生成的实时消息。为实现这个目标，SSE 设计了两个组件：<strong>浏览器中的 <a href="https://developer.mozilla.org/zh-CN/docs/Server-sent_events/EventSource">EventSource API</a> 和新的 “事件流” 数据格式（text/event-stream）</strong>。其中，EventSource 可以让客户端以 DOM 事件的形式接收到服务器推送的通知，而新数据格式则用于交付每一次数据更新。</p><p>实际上，SSE 提供的是一个高效、跨浏览器的 XHR 流实现，消息交付只使用一个长 HTTP 连接。然而，与我们自己实现 XHR 流不同，浏览器会帮我们管理连接、 解析消息，从而让我们只关注业务逻辑。篇幅有限，关于 SSE 的更多细节，阿宝哥就不展开介绍了，对 SSE 感兴趣的小伙伴可以自行查阅相关资料。</p><h3 id="四、阿宝哥有话说"><a href="#四、阿宝哥有话说" class="headerlink" title="四、阿宝哥有话说"></a>四、阿宝哥有话说</h3><h4 id="4-1-WebSocket-与-HTTP-有什么关系"><a href="#4-1-WebSocket-与-HTTP-有什么关系" class="headerlink" title="4.1 WebSocket 与 HTTP 有什么关系"></a>4.1 WebSocket 与 HTTP 有什么关系</h4><p>WebSocket 是一种与 HTTP 不同的协议。两者都位于 OSI 模型的应用层，并且都依赖于传输层的 TCP 协议。 虽然它们不同，但是 RFC 6455 中规定：WebSocket 被设计为在 HTTP 80 和 443 端口上工作，并支持 HTTP 代理和中介，从而使其与 HTTP 协议兼容。 为了实现兼容性，WebSocket 握手使用 HTTP Upgrade 头，从 HTTP 协议更改为 WebSocket 协议。</p><p>既然已经提到了 <a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI（Open System Interconnection Model）模型</a>，这里阿宝哥来分享一张很生动、很形象描述 OSI 模型的示意图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e19b626b49b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>（图片来源：<a href="https://www.networkingsphere.com/2019/07/what-is-osi-model.html%EF%BC%89">https://www.networkingsphere.com/2019/07/what-is-osi-model.html）</a></p><h4 id="4-2-WebSocket-与长轮询有什么区别"><a href="#4-2-WebSocket-与长轮询有什么区别" class="headerlink" title="4.2 WebSocket 与长轮询有什么区别"></a>4.2 WebSocket 与长轮询有什么区别</h4><p>长轮询就是客户端发起一个请求，服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断请求的数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则等待一定的时间后才返回。</p><p>长轮询的本质还是基于 HTTP 协议，它仍然是一个一问一答（请求 — 响应）的模式。而 WebSocket 在握手成功后，就是全双工的 TCP 通道，数据可以主动从服务端发送到客户端。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/27/17390e19c4b15f3a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h4 id="4-3-什么是-WebSocket-心跳"><a href="#4-3-什么是-WebSocket-心跳" class="headerlink" title="4.3 什么是 WebSocket 心跳"></a>4.3 什么是 WebSocket 心跳</h4><p>网络中的接收和发送数据都是使用 SOCKET 进行实现。但是如果此套接字已经断开，那发送数据和接收数据的时候就一定会有问题。可是如何判断这个套接字是否还可以使用呢？这个就需要在系统中创建心跳机制。所谓 “心跳” 就是定时发送一个自定义的结构体（心跳包或心跳帧），让对方知道自己 “在线”。 以确保链接的有效性。</p><p>而所谓的心跳包就是客户端定时发送简单的信息给服务器端告诉它我还在而已。代码就是每隔几分钟发送一个固定信息给服务端，服务端收到后回复一个固定信息，如果服务端几分钟内没有收到客户端信息则视客户端断开。</p><p>在 WebSocket 协议中定义了 <strong>心跳 Ping</strong> 和 <strong>心跳 Pong</strong> 的控制帧：</p><ul><li>心跳 Ping 帧包含的操作码是 0x9。如果收到了一个心跳 Ping 帧，那么终端必须发送一个心跳 Pong 帧作为回应，除非已经收到了一个关闭帧。否则终端应该尽快回复 Pong 帧。</li><li>心跳 Pong 帧包含的操作码是 0xA。作为回应发送的 Pong 帧必须完整携带 Ping 帧中传递过来的 “应用数据” 字段。如果终端收到一个 Ping 帧但是没有发送 Pong 帧来回应之前的 Ping 帧，那么终端可以选择仅为最近处理的 Ping 帧发送 Pong 帧。此外，可以自动发送一个 Pong 帧，这用作单向心跳。</li></ul><h4 id="4-4-Socket-是什么"><a href="#4-4-Socket-是什么" class="headerlink" title="4.4 Socket 是什么"></a>4.4 Socket 是什么</h4><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个 socket（套接字），因此建立网络通信连接至少要一对端口号。<strong>socket 本质是对 TCP/IP 协议栈的封装，它提供了一个针对 TCP 或者 UDP 编程的接口，并不是另一种协议</strong>。通过 socket，你可以使用 TCP/IP 协议。</p><blockquote><p>Socket 的英文原义是“孔”或“插座”。作为 BSD UNIX 的<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1">进程通信</a>机制，取后一种意思。通常也称作”<a href="https://baike.baidu.com/item/%E5%A5%97%E6%8E%A5%E5%AD%97">套接字</a>“，用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。</p><p>在Internet 上的<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA">主机</a>一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket 正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供 220 伏交流电， 有的提供 110 伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。—— <a href="https://baike.baidu.com/item/socket/281150">百度百科</a></p></blockquote><p>关于 Socket，可以总结以下几点：</p><ul><li>它可以实现底层通信，几乎所有的应用层都是通过 socket 进行通信的。</li><li>对 TCP/IP 协议进行封装，便于应用层协议调用，属于二者之间的中间抽象层。</li><li>TCP/IP 协议族中，传输层存在两种通用协议: TCP、UDP，两种协议不同，因为不同参数的 socket 实现过程也不一样。</li></ul><p>下图说明了面向连接的协议的套接字 API 的客户端/服务器关系。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/26/17389e7e394ad059?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h3 id="五、参考资源"><a href="#五、参考资源" class="headerlink" title="五、参考资源"></a>五、参考资源</h3><ul><li><a href="https://zh.wikipedia.org/wiki/WebSocket">维基百科 - WebSocket</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket">MDN - WebSocket</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Protocol_upgrade_mechanism">MDN - Protocol_upgrade_mechanism</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/WebSockets_API/Writing_WebSocket_servers">MDN - 编写 WebSocket 服务器</a></li><li><a href="https://tools.ietf.org/html/rfc6455">rfc6455</a></li><li>Web 性能权威指南</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/6/22/172dc5bb94585adf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p><a href="https://juejin.im/post/6854573221241421838">转自 【掘金】阿宝哥</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> node </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WebSocket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今天谈谈作用域和作用域链</title>
      <link href="/blog/web/20200725001/"/>
      <url>/blog/web/20200725001/</url>
      
        <content type="html"><![CDATA[<blockquote><p>JavaScript 中有一个被称为作用域(Scope)的特性。虽然对于许多新手开发者来说，作用域的概念并不是很容易理解，本文我会尽我所能用最简单的方式来解释作用域和作用域链，希望大家有所收获！</p></blockquote><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>JavaScript</code> 中有一个被称为作用域(Scope)的特性。虽然对于许多新手开发者来说，作用域的概念并不是很容易理解，本文我会尽我所能用最简单的方式来解释作用域和作用域链，希望大家有所收获！</p><h2 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域(Scope)"></a>作用域(Scope)</h2><h4 id="1-什么是作用域"><a href="#1-什么是作用域" class="headerlink" title="1. 什么是作用域"></a>1. 什么是作用域</h4><p>作用域是在运行时代码中的某些特定部分中变量，函数和对象的可访问性。换句话说，作用域决定了代码区块中变量和其他资源的可见性。可能这两句话并不好理解，我们先来看个例子：</p><pre><code>function outFun2() &amp;#123; var inVariable = "内层变量2";&amp;#125;outFun2();//要先执行这个函数，否则根本不知道里面是啥console.log(inVariable); // Uncaught ReferenceError: inVariable is not defined</code></pre><p>从上面的例子可以体会到作用域的概念，变量 <code>inVariable</code> 在全局作用域没有声明，所以在全局作用域下取值会报错。我们可以这样理解：<strong>作用域就是一个独立的地盘，让变量不会外泄、暴露出去</strong>。也就是说<strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p><p><strong>ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域</strong>。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 <code>let</code> 和 <code>const</code> 来体现。</p><h4 id="2-全局作用域和函数作用域"><a href="#2-全局作用域和函数作用域" class="headerlink" title="2. 全局作用域和函数作用域"></a>2. 全局作用域和函数作用域</h4><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下几种情形拥有全局作用域：</p><ul><li><strong>最外层函数 和在最外层函数外面定义的变量拥有全局作用域</strong></li></ul><pre><code>var outVariable = "我是最外层变量"; //最外层变量function outFun() { //最外层函数 var inVariable = "内层变量"; function innerFun() { //内层函数 console.log(inVariable); } innerFun();}console.log(outVariable); //我是最外层变量outFun(); //内层变量console.log(inVariable); //inVariable is not definedinnerFun(); //innerFun is not defined</code></pre><ul><li><strong>所有末定义直接赋值的变量自动声明为拥有全局作用域</strong></li></ul><pre><code>function outFun2() { variable = "未定义直接赋值的变量"; var inVariable2 = "内层变量2";}outFun2();//要先执行这个函数，否则根本不知道里面是啥console.log(variable); //未定义直接赋值的变量console.log(inVariable2); //inVariable2 is not defined</code></pre><ul><li><strong>所有 window 对象的属性拥有全局作用域</strong></li></ul><p>一般情况下，<code>window</code>对象的内置属性都拥有全局作用域，例如 <code>window.name</code>、<code>window.location</code>、<code>window.top</code> 等等。</p><p>全局作用域有个弊端：如果我们写了很多行 JS 代码，变量定义都没有用函数包括，那么它们就全部都在全局作用域中。这样就会 污染全局命名空间, 容易引起命名冲突。</p><pre><code>// 张三写的代码中var data = {a: 100} // 李四写的代码中var data = {x: true}</code></pre><p>这就是为何 <code>jQuery</code>、<code>Zepto</code>等库的源码，所有的代码都会放在<code>(function()&amp;#123;....&amp;#125;)()</code>中。因为放在里面的所有变量，都不会被外泄和暴露，不会污染到外面，不会对其他的库或者 JS 脚本造成影响。这是函数作用域的一个体现。</p><p>函数作用域,是指声明在函数内部的变量，和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部。</p><pre><code>function doSomething(){ var blogName="浪里行舟"; function innerSay(){ alert(blogName); } innerSay();}alert(blogName); //脚本错误innerSay(); //脚本错误</code></pre><p><strong>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行</strong>。我们看个例子，用泡泡来比喻作用域可能好理解一点：</p><p><img src="https://image.fundebug.com/2019-03-15-WechatIMG465.png" alt="此图像的alt属性为空；文件名为2019-03-15-WechatIMG465.png"></p><p>此图像的alt属性为空；文件名为2019-03-15-WechatIMG465.png</p><p>最后输出的结果为 2, 4, 12</p><ul><li><p>泡泡 1 是全局作用域，有标识符 foo；</p></li><li><p>泡泡 2 是作用域 foo，有标识符 a,bar,b；</p></li><li><p>泡泡 3 是作用域 bar，仅有标识符 c。</p></li></ul><p>值得注意的是：<strong>块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。</p><pre><code>if (true) { // 'if' 条件语句块不会创建一个新的作用域 var name = 'Hammad'; // name 依然在全局作用域中}console.log(name); // logs 'Hammad'</code></pre><p>JS 的初学者经常需要花点时间才能习惯变量提升，而如果不理解这种特有行为，就可能导致<br>bug 。正因为如此， ES6 引入了块级作用域，让变量的生命周期更加可控。</p><h4 id="3-块级作用域"><a href="#3-块级作用域" class="headerlink" title="3. 块级作用域"></a>3. 块级作用域</h4><p>块级作用域可通过新增命令 <code>let</code> 和 <code>const</code> 声明，所声明的变量在指定块的作用域外无法被访问。块级作用域在如下情况被创建：</p><ol><li><p>在一个函数内部</p></li><li><p>在一个代码块（由一对花括号包裹）内部</p></li></ol><p><code>let</code> 声明的语法与 <code>var</code> 的语法一致。你基本上可以用 <code>let</code> 来代替 <code>var</code> 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：</p><ul><li>声明变量不会提升到代码块顶部</li></ul><p><code>let/const</code> 声明并不会被提升到当前代码块的顶部，因此你需要手动将 <code>let/const</code> 声明放置到顶部，以便让变量在整个代码块内部可用。</p><pre><code>function getValue(condition) {if (condition) {let value = "blue";return value;} else {// value 在此处不可用return null;}// value 在此处不可用}</code></pre><ul><li>禁止重复声明</li></ul><p>如果一个标识符已经在代码块内部被定义，那么在此代码块内使用同一个标识符进行 let 声明就会导致抛出错误。例如：</p><pre><code>var count = 30;let count = 40; // Uncaught SyntaxError: Identifier 'count' has already been declared` 在本例中， count 变量被声明了两次：一次使用 var ，另一次使用 let 。因为 let 不能在同一作用域内重复声明一个已有标识符，此处的 let 声明就会抛出错误。但如果在嵌套的作用域内使用 let 声明一个同名的新变量，则不会抛出错误。`var count = 30;// 不会抛出错误if (condition) {let count = 40;// 其他代码}var count = 30;// 不会抛出错误if (condition) {let count = 40;// 其他代码}</code></pre><ul><li>循环中的绑定块作用域的妙用</li></ul><p>开发者可能最希望实现 for 循环的块级作用域了，因为可以把声明的计数器变量限制在循环内，例如，以下代码在 JS 经常见到：</p><pre><code>&lt;button&gt;测试1&lt;/button&gt;&lt;button&gt;测试2&lt;/button&gt;&lt;button&gt;测试3&lt;/button&gt;&lt;script type="text/javascript"&gt; var btns = document.getElementsByTagName('button') for (var i = 0; i &lt; btns.length; i++) { btns[i].onclick = function () { console.log('第' + (i + 1) + '个') } }&lt;/script&gt;</code></pre><p>我们要实现这样的一个需求: 点击某个按钮, 提示”点击的是第 n 个按钮”,此处我们先不考虑事件代理,万万没想到，点击任意一个按钮，后台都是弹出“第四个”,这是因为 i 是全局变量,执行到点击事件时，此时 i 的值为 3。那该如何修改，最简单的是用 let 声明 i</p><pre><code>for (let i = 0; i &lt; btns.length; i++) { btns[i].onclick = function () { console.log('第' + (i + 1) + '个') } }</code></pre><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><h4 id="1-什么是自由变量"><a href="#1-什么是自由变量" class="headerlink" title="1.什么是自由变量"></a>1.什么是自由变量</h4><p>首先认识一下什么叫做 <strong>自由变量</strong> 。如下代码中，<code>console.log(a)</code>要得到 a 变量，但是在当前的作用域中没有定义 a（可对比一下 b）。当前作用域没有定义的变量，这成为 自由变量 。自由变量的值如何得到 —— 向父级作用域寻找（注意：这种说法并不严谨，下文会重点解释）。</p><pre><code>var a = 100function fn() { var b = 200 console.log(a) // 这里的a在这里就是一个自由变量 console.log(b)}fn()</code></pre><h4 id="2-什么是作用域链"><a href="#2-什么是作用域链" class="headerlink" title="2. 什么是作用域链"></a>2. 什么是作用域链</h4><p>如果父级也没呢？再一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。</p><pre><code>var a = 100function F1() { var b = 200 function F2() { var c = 300 console.log(a) // 自由变量，顺作用域链向父作用域找 console.log(b) // 自由变量，顺作用域链向父作用域找 console.log(c) // 本作用域的变量 } F2()}F1()</code></pre><h4 id="3-关于自由变量的取值"><a href="#3-关于自由变量的取值" class="headerlink" title="3. 关于自由变量的取值"></a>3. 关于自由变量的取值</h4><p>关于自由变量的值，上文提到要到父作用域中取，其实有时候这种解释会产生歧义。</p><pre><code>var x = 10function fn() { console.log(x)}function show(f) { var x = 20 (function() { f() //10，而不是20 })()}show(fn)</code></pre><p>在 fn 函数中，取自由变量 x 的值时，要到哪个作用域中取？——要到创建 fn 函数的那个作用域中取，<strong>无论 fn 函数将在哪里调用</strong>。</p><p>所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切:<strong>要到创建这个函数的那个域”。<br>作用域中取值,这里强调的是“创建”，而不是“调用”</strong>，切记切记——其实这就是所谓的”静态作用域”</p><pre><code>var a = 10function fn() { var b = 20 function bar() { console.log(a + b) //30 } return bar}var x = fn(), b = 200x() //bar()</code></pre><p>fn()返回的是 bar 函数，赋值给 x。执行 x()，即执行 bar 函数代码。取 b 的值时，直接在 fn 作用域取出。取 a 的值时，试图在 fn 作用域取，但是取不到，只能转向创建 fn 的那个作用域中去查找，结果找到了,所以最后的结果是 30</p><h3 id="作用域与执行上下文"><a href="#作用域与执行上下文" class="headerlink" title="作用域与执行上下文"></a>作用域与执行上下文</h3><p>许多开发人员经常混淆作用域和执行上下文的概念，误认为它们是相同的概念，但事实并非如此。</p><p>我们知道 JavaScript 属于解释型语言，JavaScript 的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样：</p><h4 id="解释阶段："><a href="#解释阶段：" class="headerlink" title="解释阶段："></a>解释阶段：</h4><ul><li><p>词法分析</p></li><li><p>语法分析</p></li><li><p>作用域规则确定</p></li></ul><h4 id="执行阶段："><a href="#执行阶段：" class="headerlink" title="执行阶段："></a>执行阶段：</h4><ul><li><p>创建执行上下文</p></li><li><p>执行函数代码</p></li><li><p>垃圾回收</p></li></ul><p>JavaScript 解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是 this 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。</p><p>作用域和执行上下文之间最大的区别是：<br><strong>执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变</strong>。</p><p>一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。<strong>同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值</strong>。</p><h3 id="参考文章和书籍"><a href="#参考文章和书籍" class="headerlink" title="参考文章和书籍"></a>参考文章和书籍</h3><ul><li><p><a href="http://www.cnblogs.com/wangfupeng1988/p/4001284.html">深入理解 javascript 原型和闭包系列</a></p></li><li><p><a href="https://juejin.im/book/5a8f9ddcf265da4e9f6fb959/section/5a8f9ed96fb9a0633229bddf">Web 前端面试指南与高频考题解析</a></p></li><li><p><a href="https://github.com/creeperyang/blog/issues/16">深入理解 JS 中声明提升、作用域（链）和<code>this</code>关键字</a></p></li><li><p><a href="http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html">JavaScript 开发进阶：理解 JavaScript 作用域和作用域链</a></p></li><li><p><a href="https://gaohaoyang.github.io/2015/05/20/scope/#top">JavaScript 作用域和作用域链</a></p></li><li><p><a href="https://book.douban.com/subject/27072230/">深入理解 ES6</a></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今天谈一下null和undefined的区别？</title>
      <link href="/blog/web/20200723001/"/>
      <url>/blog/web/20200723001/</url>
      
        <content type="html"><![CDATA[<blockquote><p>今天弄得有点晚了，就写个简单的吧,null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</p></blockquote><p><strong>null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。</strong></p><h2 id="undefined："><a href="#undefined：" class="headerlink" title="undefined："></a>undefined：</h2><ul><li><p>（1）变量被声明了，但没有赋值时，就等于undefined。</p></li><li><p>（2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。</p></li><li><p>（3）对象没有赋值的属性，该属性的值为undefined。</p></li><li><p>（4）函数没有返回值时，默认返回undefined。</p></li></ul><h2 id="null："><a href="#null：" class="headerlink" title="null："></a>null：</h2><ul><li><p>（1） 作为函数的参数，表示该函数的参数不是对象。</p></li><li><p>（2） 作为对象原型链的终点。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>今天聊一聊call、bind、apply</title>
      <link href="/blog/web/20200722001/"/>
      <url>/blog/web/20200722001/</url>
      
        <content type="html"><![CDATA[<p>在JS中，这三者都是用来改变函数的this对象的指向的，他们有什么样的区别呢。<br>在说区别之前还是先总结一下三者的相似之处：</p><ul><li>1、都是用来改变函数的this对象的指向的。</li><li>2、第一个参数都是this要指向的对象。</li><li>3、都可以利用后续参数传参。</li></ul><p><strong>「那么他们的区别在哪里的，先看一个例子。」</strong></p><pre><code>var xw = &amp;#123; name: '小王', gender: '男', age: 24, say: function () &amp;#123; alert(this.name + ' , ' + this.gender + ' ,今年' + this.age); &amp;#125;,&amp;#125;;var xh = &amp;#123; name: '小红', gender: '女', age: 18,&amp;#125;;xw.say();</code></pre><p>本身没什么好说的，显示的肯定是小王 ， 男 ， 今年24。那么如何用xw的say方法来显示xh的数据呢。</p><p><strong>「对于call可以这样：」</strong></p><p><code>xw.say.call\(xh\);</code> </p><p><strong>「对于apply可以这样：」</strong></p><p><code>xw.say.apply\(xh\);</code> </p><p><strong>「而对于bind来说需要这样：」</strong></p><p><code>xw.say.bind\(xh\)\(\);</code> </p><p>如果直接写xw.say.bind(xh)是不会有任何结果的，看到区别了吗？call和apply都是对函数的直接调用，而bind方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。<br>那么call和apply有什么区别呢？我们把例子稍微改写一下。</p><pre><code>var xw = { name: '小王', gender: '男', age: 24, say: function (school, grade) { alert( this.name + ' , ' + this.gender + ' ,今年' + this.age + ' ,在' + school + '上' + grade ); },};var xh = { name: '小红', gender: '女', age: 18,};</code></pre><p>可以看到say方法多了两个参数，我们通过call/apply的参数进行传参。</p><p><strong>「对于call来说是这样的」</strong></p><p><code>xw.say.call\(xh,"实验小学","六年级"\);</code> </p><p><strong>「而对于apply来说是这样的」</strong></p><p><code>xw.say.apply\(xh,\["实验小学","六年级"\]\);</code> </p><p>看到区别了吗，call后面的参数与say方法中是一一对应的，而apply的第二个参数是一个数组，数组中的元素是和say方法中一一对应的，这就是两者最大的区别。<br>那么bind怎么传参呢？它可以像call那样传参。</p><p><code>xw.say.bind\(xh,"实验小学","六年级"\)\(\);</code> </p><p>但是由于bind返回的仍然是一个函数，所以我们还可以在调用的时候再进行传参。</p><p><code>xw.say.bind\(xh\)\("实验小学","六年级"\);</code> </p><h2 id="那要怎么手动去实现这三个函数呢？"><a href="#那要怎么手动去实现这三个函数呢？" class="headerlink" title="那要怎么手动去实现这三个函数呢？"></a>那要怎么手动去实现这三个函数呢？</h2><h4 id="「实现一个call函数」"><a href="#「实现一个call函数」" class="headerlink" title="「实现一个call函数」"></a><strong>「实现一个call函数」</strong></h4><pre><code>Function.prototype.myCall = function (context) { if (typeof this !== 'function') { throw new TypeError('Error'); } if (context === null || context === undefined) { context = window; // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window) } else { context = Object(context); // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象 } context.fn = this; //通过参数伪数组将context后面的参数取出来 let args = [...arguments].slice(1); let result = context.fn(...args); //删除 fn delete context.fn; return result;}; </code></pre><p><strong>「实现思路：」</strong></p><ul><li>首先，判断调用<code>mycall</code>的是不是函数，如果不是，则直接抛出异常；</li><li>接着，判断是否传入了第一个参数<code>context</code>，也就是要指定的<code>this</code>值，如果没有传入，则默认为<code>window</code>全局对象；</li><li>然后，谁将来调用<code>mycall</code>，那么<code>this</code>就是谁，将其赋给<code>context.fn</code>;</li><li>然后，通过参数伪数组将<code>context</code>后面的参数取出来,并传给<code>context.fn</code>获得执行结果<code>result</code>；</li><li>最后，删除掉<code>context.fn</code>，并将<code>result</code>返回；</li></ul><h4 id="「实现一个apply函数」"><a href="#「实现一个apply函数」" class="headerlink" title="「实现一个apply函数」"></a><strong>「实现一个apply函数」</strong></h4><pre><code>Function.prototype.myApply = function (context) { if (typeof this !== 'function') { throw new TypeError('Error'); } if (context === null || context === undefined) { context = window; // 指定为 null 和 undefined 的 this 值会自动指向全局对象(浏览器中为window) } else { context = Object(context); // 值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的实例对象 } context.fn = this; let result; //判断是否存在第二个参数 //如果存在就将第二个参数也展开 if (arguments[1]) { result = context.fn(...arguments[1]); } else { result = context.fn(); } delete context.fn; return result;};</code></pre><p><strong>「实现思路：」</strong></p><ul><li>首先，判断调用<code>myapply</code>的是不是函数，如果不是，则直接抛出异常；</li><li>接着，判断是否传入了第一个参数<code>context</code>，也就是要指定的<code>this</code>值，如果没有传入，则默认为<code>window</code>全局对象；</li><li>然后，谁将来调用<code>myapply</code>，那么<code>this</code>就是谁，将其赋给<code>context.fn</code>;</li><li>然后，判断是否传入了第二个参数，如果传入了则将其使用展开运算符<code>...</code>传给<code>context.fn</code>获得执行结果<code>result</code>，如果没有传入，则直接调用<code>context.fn</code>获得执行结果<code>result</code>；</li><li>最后，删除掉<code>context.fn</code>，并将<code>result</code>返回；</li></ul><h4 id="「实现一个bind函数」"><a href="#「实现一个bind函数」" class="headerlink" title="「实现一个bind函数」"></a><strong>「实现一个bind函数」</strong></h4><pre><code>Function.prototype.mybind = function (context) { if (typeof this !== 'function') { throw new TypeError('Error'); } const _this = this; const args = [...arguments].slice(1); //返回一个函数 return function F() { if (this instanceof F) { // this是否是F的实例 也就是返回的F是否通过new调用 return new _this(...args, ...arguments); } return _this.apply(context, args.concat(...arguments)); };}; </code></pre><p><strong>「实现思路：」</strong></p><ul><li>首先，判断调用<code>mybind</code>的是不是函数，如果不是，则直接抛出异常；</li><li>接着，谁将来调用<code>mybind</code>，那么<code>this</code>就是谁，将其赋给<code>_this</code>，缓存一下;</li><li>然后，通过参数伪数组将<code>context</code>后面的参数(预先添加到绑定函数的参数)取出来，记作<code>args</code>,</li><li>然后，返回一个函数，并判断如果使用<code>new</code>运算符构造绑定函数，则忽略传入的第一个参数<code>context</code>，并将预先添加到绑定函数的参数<code>args</code>和将来传入新函数的参数<code>arguments</code>分别通过展开运算符<code>...</code>依次传入给调用<code>mybind</code>的调用者，并将结果返回。</li><li>最后，如果不是使用<code>new</code>运算符构造绑定函数，则对调用者使用<code>apply</code>方法，将传入的第一个参数以及预先添加到绑定函数的参数<code>args</code>和将来传入新函数的参数<code>arguments</code>分别通过展开运算符<code>...</code>依次传入给调用<code>mybind</code>的调用者，并将结果返回；</li></ul><p>这里只是一个简略版的，但是应付面试已经够了…….</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>说说DOCTYPE</title>
      <link href="/blog/interview/20200702001/"/>
      <url>/blog/interview/20200702001/</url>
      
        <content type="html"><![CDATA[<blockquote><p>DOCTYPE不是 HTML 标签；它是指示 web 浏览器关于页面使用哪个 HTML 版本进行编写的指令，用于声明文档类型和DTD（Document Type Definition）规范，确保不同浏览器以相同的方式解析文档，以及执行相同的渲染模式：</p></blockquote><p><code>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;  /*在上面的声明中，声明了文档的根元素是 html，它在公共标识符被定义为 "-//W3C//DTD XHTML 1.0 Strict//EN" 的 DTD 中进行了定义。浏览器将明白如何寻找匹配此公共标识符的 DTD。如果找不到，浏览器将使用公共标识符后面的 URL 作为寻找 DTD 的位置。*/</code> </p><p><strong>主要分为三种：</strong></p><ul><li><p>1、HTML5</p></li><li><p>2、HTML4.01</p></li><li><p>3、XHTML1.0</p></li></ul><h1 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h1><p><code>&lt;!DOCTYPE html\&gt;</code> </p><p>这个不用多说，告诉浏览器用H5的方式渲染，与HTML4.0.1不同，他不是基于 SGML，不需要使用DTD；</p><h1 id="HTML4-0-1"><a href="#HTML4-0-1" class="headerlink" title="HTML4.0.1"></a>HTML4.0.1</h1><p>HTML4.0.1中的DTD可分为三种：<code>Strict</code>、<code>Transitional</code> 以及 <code>Frameset</code>。具体如下</p><h3 id="1、HTML-Strict-DTD-—严格型"><a href="#1、HTML-Strict-DTD-—严格型" class="headerlink" title="1、HTML Strict DTD —严格型"></a>1、HTML Strict DTD —严格型</h3><p><code>//写法： &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" " http://www.w3.org/TR/html4/strict.dtd"&gt;  /** 特点：包含所有的HTML元素和属性，但不包含已废弃的，如（font，center等）也不包括框架相关的元素（如frame） */</code> </p><h3 id="2、HTML-Transitional-DTD—过渡型"><a href="#2、HTML-Transitional-DTD—过渡型" class="headerlink" title="2、HTML Transitional DTD—过渡型"></a>2、HTML Transitional DTD—过渡型</h3><p><code>//写法 &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" " http://www.w3.org/TR/html4/loose.dtd"&gt; //仅不包含框架相关的元素</code> </p><h3 id="3、Frameset-DTD—框架集"><a href="#3、Frameset-DTD—框架集" class="headerlink" title="3、Frameset DTD—框架集"></a>3、Frameset DTD—框架集</h3><p><code>//写法 &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Frameset//EN" " http://www.w3.org/TR/html4/frameset.dtd"&gt; /*包含所有的HTML元素和属性 除 frameset 元素取代了 body 元素之外，Frameset DTD 等同于 Transitional DTD：*/</code> </p><h1 id="XHTML"><a href="#XHTML" class="headerlink" title="XHTML"></a>XHTML</h1><p>XHTML 1.0 ,与HTML4.0.1一样，同样规定了三种 XML 文档类型：<code>Strict</code>、<code>Transitional</code> 以及 <code>Frameset</code>。写法如下,不赘述</p><p><code>//Strict &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt; //Transitional &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; //Frameset &lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd"&gt;</code> </p><h1 id="拓展：XHTML与HTML的区别："><a href="#拓展：XHTML与HTML的区别：" class="headerlink" title="拓展：XHTML与HTML的区别："></a>拓展：XHTML与HTML的区别：</h1><ul><li><p>1、XHTML文档需要良好的文档结构，元素要合理嵌套，错误的例子</p><p><span>hello world</span></p><p></p></li><li><p>2、XHTML文档区分大小写，并且元素属性和名称要小写</p></li><li><p>3、XHTML必须要有结束标签，就算是空元素，也要有/&gt;结尾</p></li><li><p>4、XHTML可运用各种XML应用，如MathMl，SVG</p></li><li><p>5、注释标签<!-- -->将被忽略</p></li><li><p>6、XHTML中CDATA的内容可被执行，作用是防止解析到非法字符串就中断</p></li><li><p>7、XHTML中，不推荐a、applet、form、img、map、iframe、frame、map等拥有name属性，但加上也不会报错</p></li><li><p>8、HTML用脚本取到的HTML标签名和属性会以大写形式返回</p></li><li><p>9、XHTML元素的属性必须用引号包裹，并且禁止简化</p></li><li><p>10、XHTML中特殊字符必须替换为实体引用，如”&lt;”替换为”&lt;”</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试类相关书籍</title>
      <link href="/blog/other/20200720004/"/>
      <url>/blog/other/20200720004/</url>
      
        <content type="html"><![CDATA[<h4 id="leetcode题解"><a href="#leetcode题解" class="headerlink" title="leetcode题解"></a>leetcode题解</h4><pre><code>链接：https://pan.baidu.com/s/1WEVNDbRYEplbYvUMV7hh9g提取码：dlnb</code></pre><h4 id="百度、淘宝、网易、搜狐前端开发面试题集锦"><a href="#百度、淘宝、网易、搜狐前端开发面试题集锦" class="headerlink" title="百度、淘宝、网易、搜狐前端开发面试题集锦"></a>百度、淘宝、网易、搜狐前端开发面试题集锦</h4><pre><code>链接：https://pan.baidu.com/s/13fdIeEv7RiW\_TbkOPAW3kQ提取码：4ssg</code></pre><h4 id="编程之美——微软技术面试心得"><a href="#编程之美——微软技术面试心得" class="headerlink" title="编程之美——微软技术面试心得"></a>编程之美——微软技术面试心得</h4><p>   链接：<a href="https://pan.baidu.com/s/1BptY/_qhs63D/_dpCQb-0g1w%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9A9hsh">https://pan.baidu.com/s/1BptY\_qhs63D\_dpCQb-0g1w提取码：9hsh</a></p><h4 id="程序员代码面试指南-IT名企算法与数据结构题目最优解"><a href="#程序员代码面试指南-IT名企算法与数据结构题目最优解" class="headerlink" title="程序员代码面试指南 IT名企算法与数据结构题目最优解"></a>程序员代码面试指南 IT名企算法与数据结构题目最优解</h4><pre><code>链接：https://pan.baidu.com/s/1jO0Xgv2vrIHhoM3uQYzcEg提取码：awm7</code></pre><h4 id="程序员面试宝典"><a href="#程序员面试宝典" class="headerlink" title="程序员面试宝典"></a>程序员面试宝典</h4><pre><code>链接：https://pan.baidu.com/s/193\_URH2rrMs91DYnbvqrpg提取码：ds83</code></pre><h4 id="程序员面试笔试宝典"><a href="#程序员面试笔试宝典" class="headerlink" title="程序员面试笔试宝典"></a>程序员面试笔试宝典</h4><pre><code>链接：https://pan.baidu.com/s/1GX5qhE1VgZpw0zZtQ9WL6w提取码：71j9</code></pre><h4 id="程序员面试金典"><a href="#程序员面试金典" class="headerlink" title="程序员面试金典"></a>程序员面试金典</h4><pre><code>链接：https://pan.baidu.com/s/1DqtNoMBvxRd\_jnSypDS\_9Q提取码：v9ro</code></pre><h4 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h4><pre><code>链接：https://pan.baidu.com/s/1fQkf6Deyy\_aNSpiurtehmA提取码：wisg</code></pre><h4 id="金领简历：敲开苹果、微软、谷歌的大门"><a href="#金领简历：敲开苹果、微软、谷歌的大门" class="headerlink" title="金领简历：敲开苹果、微软、谷歌的大门"></a>金领简历：敲开苹果、微软、谷歌的大门</h4><pre><code>链接：https://pan.baidu.com/s/1RQL7Z50uE8pqGmvH0OkdCw提取码：ne6b</code></pre><h4 id="你也能拿高薪-名企面试自助手册-名企面试研究小组"><a href="#你也能拿高薪-名企面试自助手册-名企面试研究小组" class="headerlink" title="你也能拿高薪-名企面试自助手册].名企面试研究小组"></a>你也能拿高薪-名企面试自助手册].名企面试研究小组</h4><pre><code>链接：https://pan.baidu.com/s/1yPz\_WzX6AjIFe0J\_5l9WLg提取码：l9x2</code></pre><h4 id="前端程序员面试宝典"><a href="#前端程序员面试宝典" class="headerlink" title="前端程序员面试宝典"></a>前端程序员面试宝典</h4><pre><code>链接：https://pan.baidu.com/s/1j144MYMszZAZJ11Y94ZIUg提取码：fr2r</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程化相关书籍</title>
      <link href="/blog/other/20200720001/"/>
      <url>/blog/other/20200720001/</url>
      
        <content type="html"><![CDATA[<h2 id="GitHub入门与实践"><a href="#GitHub入门与实践" class="headerlink" title="GitHub入门与实践"></a>GitHub入门与实践</h2><p>链接：<a href="https://pan.baidu.com/s/1GGDGrsAM9gq4oQ3kH3pRbA%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9A9grz">https://pan.baidu.com/s/1GGDGrsAM9gq4oQ3kH3pRbA提取码：9grz</a></p><h2 id="Git版本控制管理"><a href="#Git版本控制管理" class="headerlink" title="Git版本控制管理"></a>Git版本控制管理</h2><p>链接：<a href="https://pan.baidu.com/s/1amRKEGJEGnpRGWl-juV1kQ%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Afqxj">https://pan.baidu.com/s/1amRKEGJEGnpRGWl-juV1kQ提取码：fqxj</a></p><h2 id="Jenkins权威指南"><a href="#Jenkins权威指南" class="headerlink" title="Jenkins权威指南"></a>Jenkins权威指南</h2><p>链接：<a href="https://pan.baidu.com/s/1mSlxwBZlGdXs-XnJZ5wy-A%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Ai2cn">https://pan.baidu.com/s/1mSlxwBZlGdXs-XnJZ5wy-A提取码：i2cn</a></p><h2 id="jenkins入门手册"><a href="#jenkins入门手册" class="headerlink" title="jenkins入门手册"></a>jenkins入门手册</h2><p>链接：<a href="https://pan.baidu.com/s/1xtmeI0i0juWDPcOr05zHqQ%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Adhm2">https://pan.baidu.com/s/1xtmeI0i0juWDPcOr05zHqQ提取码：dhm2</a></p><h2 id="Linux-Shell脚本攻略"><a href="#Linux-Shell脚本攻略" class="headerlink" title="Linux Shell脚本攻略"></a>Linux Shell脚本攻略</h2><p>链接：<a href="https://pan.baidu.com/s/1T4pWkwHRjtML5k3c0q2n6Q%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9At0ud">https://pan.baidu.com/s/1T4pWkwHRjtML5k3c0q2n6Q提取码：t0ud</a></p><h2 id="Linux-命令行"><a href="#Linux-命令行" class="headerlink" title="Linux 命令行"></a>Linux 命令行</h2><p>链接：<a href="https://pan.baidu.com/s/1k5JR17ku-KV1vNB5B2lIAQ%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9A2jpx">https://pan.baidu.com/s/1k5JR17ku-KV1vNB5B2lIAQ提取码：2jpx</a></p><h2 id="Linux运维之道"><a href="#Linux运维之道" class="headerlink" title="Linux运维之道"></a>Linux运维之道</h2><p>链接：<a href="https://pan.baidu.com/s/1tpn-WkVuuvIaacomYZ1Ibw%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Atvqq">https://pan.baidu.com/s/1tpn-WkVuuvIaacomYZ1Ibw提取码：tvqq</a></p><h2 id="Nginx-入门指南"><a href="#Nginx-入门指南" class="headerlink" title="Nginx 入门指南"></a>Nginx 入门指南</h2><p>链接：<a href="https://pan.baidu.com/s/1QkTQytubbbdf8a6Pjkh2Bg%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Assx8">https://pan.baidu.com/s/1QkTQytubbbdf8a6Pjkh2Bg提取码：ssx8</a></p><h2 id="Nginx高性能Web服务器详解"><a href="#Nginx高性能Web服务器详解" class="headerlink" title="Nginx高性能Web服务器详解"></a>Nginx高性能Web服务器详解</h2><p>链接：<a href="https://pan.baidu.com/s/12LpJmTwwlv48UOX6hIULJQ%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Ap23d">https://pan.baidu.com/s/12LpJmTwwlv48UOX6hIULJQ提取码：p23d</a></p><h2 id="Web前端自动化构建：Gulp、Bower和Yeoman开发指南"><a href="#Web前端自动化构建：Gulp、Bower和Yeoman开发指南" class="headerlink" title="Web前端自动化构建：Gulp、Bower和Yeoman开发指南"></a>Web前端自动化构建：Gulp、Bower和Yeoman开发指南</h2><p>链接：<a href="https://pan.baidu.com/s/1-hZmG9kXc6u71mpiKzsC/_Q%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Aq9ha">https://pan.baidu.com/s/1-hZmG9kXc6u71mpiKzsC\_Q提取码：q9ha</a></p><h2 id="复杂业务前端团队的进化之路"><a href="#复杂业务前端团队的进化之路" class="headerlink" title="复杂业务前端团队的进化之路"></a>复杂业务前端团队的进化之路</h2><p>链接：<a href="https://pan.baidu.com/s/1hbBxyR6aAvIBr6QcJ-qZYQ%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Acz33">https://pan.baidu.com/s/1hbBxyR6aAvIBr6QcJ-qZYQ提取码：cz33</a></p><h2 id="精通Git-第二版"><a href="#精通Git-第二版" class="headerlink" title="精通Git 第二版"></a>精通Git 第二版</h2><p>链接：<a href="https://pan.baidu.com/s/1D0qqvRu65eWIaph5VFlRwQ%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Aiuxl">https://pan.baidu.com/s/1D0qqvRu65eWIaph5VFlRwQ提取码：iuxl</a></p><h2 id="精通Nginx"><a href="#精通Nginx" class="headerlink" title="精通Nginx"></a>精通Nginx</h2><p>链接：<a href="https://pan.baidu.com/s/1LVgAD3mdIhaCL22Re5aIUA%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9A3h19">https://pan.baidu.com/s/1LVgAD3mdIhaCL22Re5aIUA提取码：3h19</a></p><h2 id="鸟哥的Linux私房菜-基础学习篇"><a href="#鸟哥的Linux私房菜-基础学习篇" class="headerlink" title="鸟哥的Linux私房菜_基础学习篇"></a>鸟哥的Linux私房菜_基础学习篇</h2><p>链接：<a href="https://pan.baidu.com/s/1fv80i/_Qml4BUhAjDF/_a7IA%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Acokf">https://pan.baidu.com/s/1fv80i\_Qml4BUhAjDF\_a7IA提取码：cokf</a></p><h2 id="前端工程化-体系设计与实践"><a href="#前端工程化-体系设计与实践" class="headerlink" title="前端工程化 体系设计与实践"></a>前端工程化 体系设计与实践</h2><p>链接：<a href="https://pan.baidu.com/s/192EgUu2ZrLA7RGeDTZjsmw%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9A4mvx">https://pan.baidu.com/s/192EgUu2ZrLA7RGeDTZjsmw提取码：4mvx</a></p><h2 id="如何构建后现代前端工程化开发体系"><a href="#如何构建后现代前端工程化开发体系" class="headerlink" title="如何构建后现代前端工程化开发体系"></a>如何构建后现代前端工程化开发体系</h2><p>链接：<a href="https://pan.baidu.com/s/1tkkbr-h-1LH8lFEtO9uMKg%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Ag4yn">https://pan.baidu.com/s/1tkkbr-h-1LH8lFEtO9uMKg提取码：g4yn</a></p><h2 id="深入浅出Webpack链接：https-pan-baidu-com-s-1TvlaeXO7MHBrwjstkd-mXQ提取码：bx8a"><a href="#深入浅出Webpack链接：https-pan-baidu-com-s-1TvlaeXO7MHBrwjstkd-mXQ提取码：bx8a" class="headerlink" title="深入浅出Webpack链接：https://pan.baidu.com/s/1TvlaeXO7MHBrwjstkd-mXQ提取码：bx8a"></a>深入浅出Webpack链接：<a href="https://pan.baidu.com/s/1TvlaeXO7MHBrwjstkd-mXQ%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Abx8a">https://pan.baidu.com/s/1TvlaeXO7MHBrwjstkd-mXQ提取码：bx8a</a></h2><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>框架类书籍</title>
      <link href="/blog/other/20200720002/"/>
      <url>/blog/other/20200720002/</url>
      
        <content type="html"><![CDATA[<h4 id="Angular权威教程"><a href="#Angular权威教程" class="headerlink" title="Angular权威教程"></a>Angular权威教程</h4><p>   链接：<a href="https://pan.baidu.com/s/1/_40vBlTUA1rDVHnnNIsVpA%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Afk1s">https://pan.baidu.com/s/1\_40vBlTUA1rDVHnnNIsVpA提取码：fk1s</a></p><h4 id="BOOTSTRAP入门经典"><a href="#BOOTSTRAP入门经典" class="headerlink" title="BOOTSTRAP入门经典"></a>BOOTSTRAP入门经典</h4><p>   链接：<a href="https://pan.baidu.com/s/1e5WD50B954/_vIabYI69RXg%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Ah8s1">https://pan.baidu.com/s/1e5WD50B954\_vIabYI69RXg提取码：h8s1</a></p><h4 id="Bootstrap实战"><a href="#Bootstrap实战" class="headerlink" title="Bootstrap实战"></a>Bootstrap实战</h4><p>   链接：<a href="https://pan.baidu.com/s/1lHNdsPBAz34Lv6E6pau-cg%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Adc6m">https://pan.baidu.com/s/1lHNdsPBAz34Lv6E6pau-cg提取码：dc6m</a></p><h4 id="Bootstrap用户手册"><a href="#Bootstrap用户手册" class="headerlink" title="Bootstrap用户手册"></a>Bootstrap用户手册</h4><p>   链接：<a href="https://pan.baidu.com/s/10DYVbfd69bQ7c0vgB47rNA%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9At3a0">https://pan.baidu.com/s/10DYVbfd69bQ7c0vgB47rNA提取码：t3a0</a></p><h4 id="DOJO权威指南"><a href="#DOJO权威指南" class="headerlink" title="DOJO权威指南"></a>DOJO权威指南</h4><p>   链接：<a href="https://pan.baidu.com/s/1U5jHmS5YibI8tX31QWNU0Q%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9A4na5">https://pan.baidu.com/s/1U5jHmS5YibI8tX31QWNU0Q提取码：4na5</a></p><h4 id="Mastering-Web-Application-Development-with-Angular"><a href="#Mastering-Web-Application-Development-with-Angular" class="headerlink" title="Mastering Web Application Development with Angular"></a>Mastering Web Application Development with Angular</h4><p>   链接：<a href="https://pan.baidu.com/s/1Gt/_GEEsXBr48ITQnmDQD2g%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Adyrv">https://pan.baidu.com/s/1Gt\_GEEsXBr48ITQnmDQD2g提取码：dyrv</a></p><h4 id="Node-js-MongoDB-AngularJS-Web开发"><a href="#Node-js-MongoDB-AngularJS-Web开发" class="headerlink" title="Node.js+MongoDB+AngularJS Web开发"></a>Node.js+MongoDB+AngularJS Web开发</h4><p>   链接：<a href="https://pan.baidu.com/s/1OY4h8A9EK0Tymr-3AFkO1w%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Atpdu">https://pan.baidu.com/s/1OY4h8A9EK0Tymr-3AFkO1w提取码：tpdu</a></p><h4 id="React精髓"><a href="#React精髓" class="headerlink" title="React精髓"></a>React精髓</h4><p>   链接：<a href="https://pan.baidu.com/s/12Paya0X4oe93lN8eZgbkOA%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Ackoc">https://pan.baidu.com/s/12Paya0X4oe93lN8eZgbkOA提取码：ckoc</a></p><h4 id="React开发实战"><a href="#React开发实战" class="headerlink" title="React开发实战"></a>React开发实战</h4><p>   链接：<a href="https://pan.baidu.com/s/1HjyNVRZOVUYs0d1HpiMrNw%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9A5oyw">https://pan.baidu.com/s/1HjyNVRZOVUYs0d1HpiMrNw提取码：5oyw</a></p><h4 id="react快速上手开发完整版"><a href="#react快速上手开发完整版" class="headerlink" title="react快速上手开发完整版"></a>react快速上手开发完整版</h4><p>   链接：<a href="https://pan.baidu.com/s/1BnNtbXiXBr69ALFaCqdfVQ%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9A9onn">https://pan.baidu.com/s/1BnNtbXiXBr69ALFaCqdfVQ提取码：9onn</a></p><h4 id="React全栈-Redux-Flux-webpack-Babel整合开发"><a href="#React全栈-Redux-Flux-webpack-Babel整合开发" class="headerlink" title="React全栈 Redux Flux webpack Babel整合开发"></a>React全栈 Redux Flux webpack Babel整合开发</h4><p>   链接：<a href="https://pan.baidu.com/s/1p8aIYN6DMt2uc3JC7ygrlQ%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Arvl7">https://pan.baidu.com/s/1p8aIYN6DMt2uc3JC7ygrlQ提取码：rvl7</a></p><h4 id="react设计模式和最佳实践"><a href="#react设计模式和最佳实践" class="headerlink" title="react设计模式和最佳实践"></a>react设计模式和最佳实践</h4><p>   链接：<a href="https://pan.baidu.com/s/1X6ZOR9E72ENtnoppvNbdRw%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Aie85">https://pan.baidu.com/s/1X6ZOR9E72ENtnoppvNbdRw提取码：ie85</a></p><h4 id="react中文入门教程"><a href="#react中文入门教程" class="headerlink" title="react中文入门教程"></a>react中文入门教程</h4><p>   链接：<a href="https://pan.baidu.com/s/1KeoExUpFGHd6c-90Ty8tsA%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9A69tk">https://pan.baidu.com/s/1KeoExUpFGHd6c-90Ty8tsA提取码：69tk</a></p><h4 id="RequiresJS-2-0-API中文"><a href="#RequiresJS-2-0-API中文" class="headerlink" title="RequiresJS-2.0-API中文"></a>RequiresJS-2.0-API中文</h4><p>   链接：<a href="https://pan.baidu.com/s/1LtTfPHt2azKk3M1qjflImg%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Ay0j0">https://pan.baidu.com/s/1LtTfPHt2azKk3M1qjflImg提取码：y0j0</a></p><h4 id="THREE-JS开发指南"><a href="#THREE-JS开发指南" class="headerlink" title="THREE.JS开发指南"></a>THREE.JS开发指南</h4><p>   链接：<a href="https://pan.baidu.com/s/1yD4b2uGDYlCLkc0Bk5O26Q%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Aoh14">https://pan.baidu.com/s/1yD4b2uGDYlCLkc0Bk5O26Q提取码：oh14</a></p><h4 id="Vue-js-前端开发-快速入门与专业应用"><a href="#Vue-js-前端开发-快速入门与专业应用" class="headerlink" title="Vue.js 前端开发 快速入门与专业应用"></a>Vue.js 前端开发 快速入门与专业应用</h4><p>   链接：<a href="https://pan.baidu.com/s/1NeQ8kKPH37OrhTWYwm239g%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Ajdzt">https://pan.baidu.com/s/1NeQ8kKPH37OrhTWYwm239g提取码：jdzt</a></p><h4 id="Vue-js权威指南"><a href="#Vue-js权威指南" class="headerlink" title="Vue.js权威指南"></a>Vue.js权威指南</h4><p>   链接：<a href="https://pan.baidu.com/s/15FpvlSwKz-LfoHDfvrBPrQ%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9A35d2">https://pan.baidu.com/s/15FpvlSwKz-LfoHDfvrBPrQ提取码：35d2</a></p><h4 id="Vue-js实战"><a href="#Vue-js实战" class="headerlink" title="Vue.js实战"></a>Vue.js实战</h4><p>   链接：<a href="https://pan.baidu.com/s/1udmBSozeTRsaHkgZC3nnHw%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Alu3w">https://pan.baidu.com/s/1udmBSozeTRsaHkgZC3nnHw提取码：lu3w</a></p><h4 id="WebGL入门指南"><a href="#WebGL入门指南" class="headerlink" title="WebGL入门指南"></a>WebGL入门指南</h4><p>   链接：<a href="https://pan.baidu.com/s/1VAqro9iIuWl50n1U54f0fg%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Apea3">https://pan.baidu.com/s/1VAqro9iIuWl50n1U54f0fg提取码：pea3</a></p><h4 id="常用JS框架比较"><a href="#常用JS框架比较" class="headerlink" title="常用JS框架比较"></a>常用JS框架比较</h4><p>   链接：<a href="https://pan.baidu.com/s/1LGhed9z3VhQwbN1nGfuuCg%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9A1rgk">https://pan.baidu.com/s/1LGhed9z3VhQwbN1nGfuuCg提取码：1rgk</a></p><h4 id="大型网站技术架构：核心原理与案例分析"><a href="#大型网站技术架构：核心原理与案例分析" class="headerlink" title="大型网站技术架构：核心原理与案例分析"></a>大型网站技术架构：核心原理与案例分析</h4><p>   链接：<a href="https://pan.baidu.com/s/1k/_h253cen7Icn2VUadKGkg%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Ah6hh">https://pan.baidu.com/s/1k\_h253cen7Icn2VUadKGkg提取码：h6hh</a></p><h4 id="疯狂前端开发讲义-jQuery-AngularJS-Bootstrap前端开发实战"><a href="#疯狂前端开发讲义-jQuery-AngularJS-Bootstrap前端开发实战" class="headerlink" title="疯狂前端开发讲义 jQuery AngularJS Bootstrap前端开发实战"></a>疯狂前端开发讲义 jQuery AngularJS Bootstrap前端开发实战</h4><p>   链接：<a href="https://pan.baidu.com/s/1eN5VvAlaZE19sn5wbzvJYA%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Apc2q">https://pan.baidu.com/s/1eN5VvAlaZE19sn5wbzvJYA提取码：pc2q</a></p><h4 id="揭秘Angular2"><a href="#揭秘Angular2" class="headerlink" title="揭秘Angular2"></a>揭秘Angular2</h4><p>   链接：<a href="https://pan.baidu.com/s/1E4Ll-GGHf1pb03oML/_NS3w%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Axg57">https://pan.baidu.com/s/1E4Ll-GGHf1pb03oML\_NS3w提取码：xg57</a></p><h4 id="精通Dojo"><a href="#精通Dojo" class="headerlink" title="精通Dojo"></a>精通Dojo</h4><p>   链接：<a href="https://pan.baidu.com/s/1le/_R0h9yXXQ-GtOS7cpaaA%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Arwpy">https://pan.baidu.com/s/1le\_R0h9yXXQ-GtOS7cpaaA提取码：rwpy</a></p><h4 id="迈向Angular-2：基于TypeScript的高性能SPA框架"><a href="#迈向Angular-2：基于TypeScript的高性能SPA框架" class="headerlink" title="迈向Angular 2：基于TypeScript的高性能SPA框架"></a>迈向Angular 2：基于TypeScript的高性能SPA框架</h4><p>   链接：<a href="https://pan.baidu.com/s/138k2juPgv3HtufIVM3G5uQ%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Atghb">https://pan.baidu.com/s/138k2juPgv3HtufIVM3G5uQ提取码：tghb</a></p><h4 id="前端架构设计"><a href="#前端架构设计" class="headerlink" title="前端架构设计"></a>前端架构设计</h4><p>   链接：<a href="https://pan.baidu.com/s/1XkU6hQfXlf6DY4o1HhqVXA%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Aaqw2">https://pan.baidu.com/s/1XkU6hQfXlf6DY4o1HhqVXA提取码：aqw2</a></p><h4 id="权威指南Vue-js"><a href="#权威指南Vue-js" class="headerlink" title="权威指南Vue.js"></a>权威指南Vue.js</h4><p>   链接：<a href="https://pan.baidu.com/s/1cNMohmcyf/_AkmLUxab6hvQ%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Au26j">https://pan.baidu.com/s/1cNMohmcyf\_AkmLUxab6hvQ提取码：u26j</a></p><h4 id="全栈开发之道：MongoDB-Express-AngularJS-Node-js"><a href="#全栈开发之道：MongoDB-Express-AngularJS-Node-js" class="headerlink" title="全栈开发之道：MongoDB+Express+AngularJS+Node.js"></a>全栈开发之道：MongoDB+Express+AngularJS+Node.js</h4><p>   链接：<a href="https://pan.baidu.com/s/1GAPKKvK5h/_iJUG1jGno0bg%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Ans4k">https://pan.baidu.com/s/1GAPKKvK5h\_iJUG1jGno0bg提取码：ns4k</a></p><h4 id="深入REACT技术栈"><a href="#深入REACT技术栈" class="headerlink" title="深入REACT技术栈"></a>深入REACT技术栈</h4><p>   链接：<a href="https://pan.baidu.com/s/1Az5uxb-JZwz/_YfB8zvjb-w%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Aaxwn">https://pan.baidu.com/s/1Az5uxb-JZwz\_YfB8zvjb-w提取码：axwn</a></p><h4 id="深入理解Bootstrap"><a href="#深入理解Bootstrap" class="headerlink" title="深入理解Bootstrap"></a>深入理解Bootstrap</h4><p>   链接：<a href="https://pan.baidu.com/s/1cWnnnTxOr97XFZqHiNU-Qw%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Ab366">https://pan.baidu.com/s/1cWnnnTxOr97XFZqHiNU-Qw提取码：b366</a></p><h4 id="深入浅出Ext-JS"><a href="#深入浅出Ext-JS" class="headerlink" title="深入浅出Ext.JS"></a>深入浅出Ext.JS</h4><p>   链接：<a href="https://pan.baidu.com/s/1Df2uc1FIODZ0PHo1foaGiA%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9A5qmh">https://pan.baidu.com/s/1Df2uc1FIODZ0PHo1foaGiA提取码：5qmh</a></p><h4 id="深入浅出React和Redux"><a href="#深入浅出React和Redux" class="headerlink" title="深入浅出React和Redux"></a>深入浅出React和Redux</h4><p>   链接：<a href="https://pan.baidu.com/s/1x7dNPxfr9IwQM/_ehs3Cojg%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Ar0xe">https://pan.baidu.com/s/1x7dNPxfr9IwQM\_ehs3Cojg提取码：r0xe</a></p><h4 id="React与Redux开发实例精解"><a href="#React与Redux开发实例精解" class="headerlink" title="React与Redux开发实例精解"></a>React与Redux开发实例精解</h4><p>   链接：<a href="https://pan.baidu.com/s/1ngIvi1nSQUnHNzAzaIMdbg%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Aemqx">https://pan.baidu.com/s/1ngIvi1nSQUnHNzAzaIMdbg提取码：emqx</a></p><h4 id="React状态管理与同构实战"><a href="#React状态管理与同构实战" class="headerlink" title="React状态管理与同构实战"></a>React状态管理与同构实战</h4><p>   链接：<a href="https://pan.baidu.com/s/1-gMRPfWlCkDc7ZEcoSdfOw%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Ainwp">https://pan.baidu.com/s/1-gMRPfWlCkDc7ZEcoSdfOw提取码：inwp</a></p><h4 id="快速上手React编程"><a href="#快速上手React编程" class="headerlink" title="快速上手React编程"></a>快速上手React编程</h4><p>   链接：<a href="https://pan.baidu.com/s/1GX0QUyWzfV4PVJQNpLZLeA%E6%8F%90%E5%8F%96%E7%A0%81%EF%BC%9Augss">https://pan.baidu.com/s/1GX0QUyWzfV4PVJQNpLZLeA提取码：ugss</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ebook </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Webpack常用插件总结</title>
      <link href="/blog/other/20200718001/"/>
      <url>/blog/other/20200718001/</url>
      
        <content type="html"><![CDATA[<p>刚完成一个基于React+Webpack的项目，渐渐地熟悉了Webpack的一些配置，开发过程中用到了不少Webpack插件，现在把觉得有用的Webpack插件总结一下当巩固学习啦，主要涉及热模块替换[Hot Module Replacement]、ProvidePlugin、CommonsChunkPlugin、UglifyJsPlugin 、ExtractTextWebpackPlugin、DefinePlugin、DllPlugin等。</p><h2 id="1、热模块替换Hot-Module-Replacement"><a href="#1、热模块替换Hot-Module-Replacement" class="headerlink" title="1、热模块替换Hot Module Replacement"></a>1、热模块替换Hot Module Replacement</h2><p>热模块替换（HMR）是webpack提供的最有用的特性之一，热模块替换可以让模块在没有页面刷新的情况下实时更新代码改动结果；</p><h4 id="安装webpack-dev-server"><a href="#安装webpack-dev-server" class="headerlink" title="安装webpack-dev-server"></a>安装webpack-dev-server</h4><p>webpack-dev-server 是一个小型的Node.js Express服务器，它通过使用webpack-dev-middleware来为webpack打包的资源文件提供服务。可以认为webpack-dev-server就是一个拥有实时重载能力的静态资源服务器（建议只在开发环境使用）<br>通过npm安装：</p><pre><code>npm install webpack-dev-server --save-dev</code></pre><p>运行</p><pre><code>webpack-dev-server \--open</code></pre><p>/*<br> 热更新授权<br>一个简单webpackHMR实例，这里感觉官方代码比较简单明了，直接复制过来啦<br>*/<br>const path = require(‘path’);<br>const webpack = require(‘webpack’);</p><p>module.exports = {<br>  entry: ‘./index.js’,</p><p>  plugins: [<br>    new webpack.HotModuleReplacementPlugin() // Enable HMR<br>  ],</p><p>  output: {<br>    filename: ‘main.js’,<br>    path: path.resolve(__dirname, ‘dist’),<br>    publicPath: ‘/‘<br>  },</p><p>  devServer: {<br>    hot: true, // Tell the dev-server we’re using HMR<br>    contentBase: resolve(__dirname, ‘dist’),<br>    publicPath: ‘/‘<br>  }<br>};</p><pre><code>上述代码配置中需要注意两个地方：  （1）plugins：添加webpack.HotModuleReplacementPlugin模块热更新插件  （2）devServer配置hot:true 开启模块热更新配置，更多配置详见devServer  同时还需注意的几个devServer配置属性</code></pre><p>inline: true|false</p><pre><code>inline属性用于切换webpack-der-server编译并刷新浏览器的两种不同模式：  （1）第一种也是默认的inline模式，这种模式是将脚本插入打包资源文件中复制热更新，并在浏览器控制台中输出过程信息，访问格式访问格式是http://:/；  （2）iframe 模式：使用iframe加载页面，访问格式http://:/webpack-dev-server/  可以通过配置</code></pre><p>inline: false//启用iframe</p><pre><code>![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/280923-e36e18e6ebe08e87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)  官方还是推荐使用inline模式在你的代码中插入热替换代码  index.js 在入口文件结尾处插入</code></pre><p>if (module.hot) {<br>    module.hot.accept();<br>}</p><pre><code>只有被 "accept"的代码模块才会被热更新，所以你需要在父节点或者父节点的父节点… module.hot.accept 调用模块。如以上代码所示，在入口文件加入 module.hot.accept之后在入口文件引用的任何子模块更新都会触发热更新。模块更新完成，浏览器会输出类型以下信息![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/280923-9ab2ffb00c080f14.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)  也可以像官方提供的实例一样accept特定的模块，如下实例，当’./library’有任何更新是都会触发热模块更新  import Lib from ‘./library’;</code></pre><p>if (module.hot) {<br>  module.hot.accept(‘./library’, function() {<br>    console.log(‘Accepting the updated library module!’);<br>    Library.log();<br>  })<br>}</p><pre><code>###### 更多Hot Module Replacement资料参考[Hot Module Replacement](https://link.jianshu.com/?t=https://webpack.js.org/guides/hot-module-replacement/)  [hot module replacement with webpack](https://link.jianshu.com/?t=https://github.com/webpack/docs/wiki/hot-module-replacement-with-webpack)  [webpack 热加载你站住，我对你好奇很久了](https://link.jianshu.com/?t=https://sanwen.net/a/wflzwqo.html)## 2、ProvidePluginProvidePlugin 可以在任何地方自动加载模块而不需要import 或 require 方法:  例如：通过如下定义，在任何代码中使用identifier变量，'module1’模块都会被加载，identifier所代表的正式‘module1’模块export的内容</code></pre><p>new webpack.ProvidePlugin({<br>  identifier: ‘module1’,<br>  // …<br>})</p><pre><code>#### 用途#### \(1）全局变量如果你的项目里需要使用jQuery，如果每次使用的时候都需要通过import 或 require 去引入jQuery的话未免也太麻烦。这时候ProvidePlugin就可以帮上大忙了</code></pre><p>//Webpack plugins定义<br>new webpack.ProvidePlugin({<br>  $: ‘jquery’,<br>  jQuery: ‘jquery’<br>})</p><p>// 代码模块中调用<br>$(‘#item’); // &lt;= 生效<br>jQuery(‘#item’); // &lt;= just works<br>// $ is automatically set to the exports of module “jquery”</p><pre><code>上述代码可以看出通过ProvidePlugin定义的‘’被调用时是直接生效的，webpack会自动把\&amp;quot;jquery\&amp;quot;给注入进模块，而‘’被调用时是直接生效的，webpack会自动把\&amp;quot;jquery\&amp;quot;给注入进模块，而‘ ’被调用时是直接生效的，webpack会自动把\&amp;quot;jquery\&amp;quot;给注入进模块，而‘\&lt;math&gt;\&lt;semantics&gt;\&lt;mrow&gt;\&lt;mi mathvariant="normal"&gt;’\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;被\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;调\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;用\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;时\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;是\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;直\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;接\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;生\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;效\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;的\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;，\&lt;/mi&gt;\&lt;mi&gt;w\&lt;/mi&gt;\&lt;mi&gt;e\&lt;/mi&gt;\&lt;mi&gt;b\&lt;/mi&gt;\&lt;mi&gt;p\&lt;/mi&gt;\&lt;mi&gt;a\&lt;/mi&gt;\&lt;mi&gt;c\&lt;/mi&gt;\&lt;mi&gt;k\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;会\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;自\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;动\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;把\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;\&amp;#x26;quot;\&lt;/mi&gt;\&lt;mi&gt;j\&lt;/mi&gt;\&lt;mi&gt;q\&lt;/mi&gt;\&lt;mi&gt;u\&lt;/mi&gt;\&lt;mi&gt;e\&lt;/mi&gt;\&lt;mi&gt;r\&lt;/mi&gt;\&lt;mi&gt;y\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;\&amp;#x26;quot;\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;给\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;注\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;入\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;进\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;模\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;块\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;，\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;而\&lt;/mi&gt;\&lt;mi mathvariant="normal"&gt;‘\&lt;/mi&gt;\&lt;/mrow&gt;\&lt;annotation encoding="application/x-tex"&gt;’被调用时是直接生效的，webpack会自动把\&amp;#x26;quot;jquery\&amp;#x26;quot;给注入进模块，而‘\&lt;/annotation&gt;\&lt;/semantics&gt;\&lt;/math&gt;’被调用时是直接生效的，webpack会自动把"jquery"给注入进模块，而‘’在模块中则代表了‘jquery’ export的内容。这样就不需要先let \$=require\(‘jquery’\)再调用啦。#### （2）ProvidePlugin还可以根据不同环境使用不同配置在实际的项目开发中我们通常会根据不同环境采用不同的webpack配置文件，如下代码使用了三个不同文件代表了不同环境的配置，development.js、test.js、production.js分别代表了开发、测试、线上环境它们都输出了一个包含name属性的对象：</code></pre><p>//development.js开发<br>module.exports = {<br>    name:’development’<br>};<br>//test.js测试<br>module.exports = {<br>    name:’test’<br>};</p><p>//production.js线上<br>module.exports = {<br>    name:’production’<br>};</p><p>//webpack.dev.config.js 开发环境<br>    new webpack.ProvidePlugin({<br>            ENV: ‘development’<br>        })<br>//webpack.test.config.js 测试环境<br>new webpack.ProvidePlugin({<br>            ENV: “test”<br>        })<br>//webpack.pub.config.js 线上环境<br>    new webpack.ProvidePlugin({<br>            ENV: “production”<br>        })</p><pre><code>假如在代码模块中这么调用</code></pre><p>if (<a href="http://env.name/">ENV.name</a> == ‘development’) {<br>console.log(‘做一些开发环境的事情’)<br>} else if (<a href="http://env.name/">ENV.name</a> == ‘test’) {<br>console.log(‘做一些测试环境的事情’)<br>} else if (<a href="http://env.name/">ENV.name</a> == ‘production’) {<br>console.log(‘有些事情必须留到线上环境做’)<br>}</p><pre><code>如上ProvidePlugin中定义的ENV在不同环境中就代表了不同模块，这样就可以区别的做一些开发、测试、生产环境不同的事情啦。###### 更多ProvidePlugin资料参考[ProvidePlugin](https://link.jianshu.com/?t=https://webpack.js.org/plugins/provide-plugin/)  [webpack 巧解环境配置问题](https://link.jianshu.com/?t=https://segmentfault.com/a/1190000004053607?utm_source=tuicool&amp;utm_medium=referral)## 3、CommonsChunkPluginCommonsChunkPlugin是一个可以用来提取公共模块的插件，配置：</code></pre><p>{<br>  name: string, // or<br>  names: string[],<br>  // 这是 common chunk 的名称。已经存在的 chunk 可以通过传入一个已存在的 chunk 名称而被选择。<br>  // 如果一个字符串数组被传入，这相当于插件针对每个 chunk 名被多次调用<br>  // 如果该选项被忽略，同时 <code>options.async</code> 或者 <code>options.children</code> 被设置，所有的 chunk 都会被使用，否则 <code>options.filename</code> 会用于作为 chunk 名。</p><p>  filename: string,<br>  // common chunk 的文件名模板。可以包含与 <code>output.filename</code> 相同的占位符。<br>  // 如果被忽略，原本的文件名不会被修改(通常是 <code>output.filename</code> 或者 <code>output.chunkFilename</code>)</p><p>  minChunks: number|Infinity|function(module, count) -&gt; boolean,<br>  // 在传入  公共chunk(commons chunk) 之前所需要包含的最少数量的 chunks 。<br>  // 数量必须大于等于2，或者少于等于 chunks的数量<br>  // 传入 <code>Infinity</code> 会马上生成 公共chunk，但里面没有模块。<br>  // 你可以传入一个 <code>function</code> ，以添加定制的逻辑（默认是 chunk 的数量）</p><p>  chunks: string[],<br>  // 通过 chunk name 去选择 chunks 的来源。chunk 必须是  公共chunk 的子模块。<br>  // 如果被忽略，所有的，所有的 入口chunk (entry chunk) 都会被选择。</p><p>  children: boolean,<br>  // 如果设置为 <code>true</code>，所有  公共chunk 的子模块都会被选择</p><p>  async: boolean|string,<br>  // 如果设置为 <code>true</code>，一个异步的  公共chunk 会作为 <code>options.name</code> 的子模块，和 <code>options.chunks</code> 的兄弟模块被创建。<br>  // 它会与 <code>options.chunks</code> 并行被加载。可以通过提供想要的字符串，而不是 <code>true</code> 来对输出的文件进行更换名称。</p><p>  minSize: number,<br>  // 在 公共chunk 被创建立之前，所有 公共模块 (common module) 的最少大小。<br>}</p><pre><code>webpack用插件CommonsChunkPlugin进行打包的时候，将符合引用次数\(minChunks\)的模块打包到name参数的数组的第一个块里（chunk）,然后数组后面的块依次打包\(查找entry里的key,没有找到相关的key就生成一个空的块\)，最后一个块包含webpack生成的在浏览器上使用各个块的加载代码，所以页面上使用的时候最后一个块必须最先加载。  打包公共文件</code></pre><p>new webpack.optimize.CommonsChunkPlugin({<br>  name: “commons”,<br>  // ( 公共chunk(commnons chunk) 的名称)</p><p>  filename: “commons.js”,<br>  // ( 公共chunk 的文件名)</p><p>  // minChunks: 3,<br>  // (模块必须被3个 入口chunk 共享)</p><p>  // chunks: [“pageA”, “pageB”],<br>  // (只使用这些 入口chunk)<br>})</p><pre><code>配置例子：  文件目录结构  ![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/280923-37515c561433b583.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/408/format/webp)</code></pre><p>//main.js<br>import A from ‘./a’</p><p>//main1.js<br>import A from ‘./a’<br>import B from ‘./b’</p><p>//a.js<br>var A = 1;<br>exports.A = A;</p><p>//b.js<br>var B = 1;<br>exports.B = B;</p><p>//lib/jquery.js<br>var Jquery = ‘fake jquery’;<br>exports.$ = Jquery;</p><p>//lib/vue.js<br>var Vue = ‘Fake Vue’;<br>exports.Vue = Vue;</p><p>//package.json<br>{<br>  “name”: “CommonsChunkPluginExample”,<br>  “version”: “1.0.0”,<br>  “main”: “main.js”,<br>  “license”: “MIT”,<br>  “scripts”: {<br>    “start”: “webpack  –config webpack.dev.config.js “<br>  },<br>  “dependencies”: {<br>    “webpack”: “^2.6.1”<br>  }<br>}</p><pre><code>实例代码，以上main.js、main1.js为入口文件；a.js、b.js为代码模块文件；lib/jquery.js、lib/vue.js模拟代码库文件#### 打包main.js、main1.js的的公共模块</code></pre><p>var path = require(‘path’)<br>var webpack = require(‘webpack’)</p><p>module.exports = {<br>  entry: {<br>    main: ‘./main.js’,<br>    main1: ‘./main1.js’,<br> },<br>  output: {<br>    path: path.join(__dirname, ‘dist’),<br>    filename: ‘[name].js’,<br>    chunkFilename: ‘[name].js’,<br>  },<br>  resolve: {<br>    extensions: [‘ ‘, ‘*’, ‘.js’, ‘.jsx’],<br>  },<br>  plugins: [<br>    new webpack.optimize.CommonsChunkPlugin({<br>      name: ‘commons’<br>    }),<br>    new webpack.optimize.CommonsChunkPlugin({<br>      name: ‘load’<br>    })</p><p>  ],<br>}</p><pre><code>按照预期  main.js、main1.js都引用了a.js，所以a.js被打包进commons.js中；b.js只被main1.js引用，将会被打包进main1.js中；打包生成的/dist/load.js包含了Webpack的加载代码：![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/280923-5dbf39acfa7a8089.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp)</code></pre><p>///dist/commons.js<br>webpackJsonp([2],[<br>/* 0 <em>/<br>/**</em>/ (function(module, exports) {</p><p>/**</p><ul><li>Created by thea on 2017/6/9.</li><li>/<br>var A = 1;<br>exports.A = A;</li></ul><p>/***/ })<br>]);</p><p>//dist/main1.js</p><p>webpackJsonp([0],[<br>/* 0 <em>/,<br>/</em> 1 <em>/<br>/**</em>/ (function(module, exports) {</p><p>var B = 1;<br>exports.B = B;</p><p>/<strong><em>/ }),<br>/</em> 2 <em>/,<br>/</em> 3 <em>/<br>/</em></strong>/ (function(module, <strong>webpack_exports__, __webpack_require</strong>) {</p><p>“use strict”;<br>Object.defineProperty(<strong>webpack_exports__, “__esModule”, { value: true });<br>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__a</strong> = <strong>webpack_require__(0);<br>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__a___default = __webpack_require</strong>.n(<strong>WEBPACK_IMPORTED_MODULE_0__a__);<br>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__b</strong> = <strong>webpack_require__(1);<br>/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__b___default = __webpack_require</strong>.n(__WEBPACK_IMPORTED_MODULE_1__b__);</p><p>/***/ })<br>],[3]);</p><pre><code>#### 提取第三方库在通常的项目开发中我们通常会引入一些第三方库，在打包的时候我们通常也会希望将代码拆分成公共代码和应用代码。将webpack.dev.config.js文件配置变化如下：</code></pre><p>//webpack.dev.config.js<br>var path = require(‘path’)<br>var webpack = require(‘webpack’)</p><p>module.exports = {<br>  entry: {<br>    main: ‘./main.js’,<br>    main1: ‘./main1.js’,<br>    lib:[‘./lib/jquery.js’,’./lib/vue.js’]//第三方库<br>  },<br>  output: {<br>    path: path.join(__dirname, ‘dist’),<br>    filename: ‘[name].js’,<br>    chunkFilename: ‘[name].js’,<br>  },<br>  resolve: {<br>    extensions: [‘ ‘, ‘*’, ‘.js’, ‘.jsx’],<br>  },<br>  plugins: [<br>    new webpack.optimize.CommonsChunkPlugin({<br>      names:[‘commons’,’lib’]//‘lib’提取入口entry key ‘lib’代表的文件单独打包<br>    }),<br>    new webpack.optimize.CommonsChunkPlugin({<br>      name: ‘load’<br>    })<br>  ],<br>}</p><pre><code>预期/lib/jquery.js、/lib/vue.js共同打包成为/dist/lib.js![在这里插入图片描述](https://upload-images.jianshu.io/upload_images/280923-64f11075587a9406.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/478/format/webp)</code></pre><p>///dist/lib.js<br>webpackJsonp([0],[<br>/* 0 <em>/,<br>/</em> 1 <em>/,<br>/</em> 2 <em>/<br>/**</em>/ (function(module, exports) {</p><p>var Jquery = ‘fake jquery’;<br>exports.$ = Jquery;</p><p>/<strong><em>/ }),<br>/</em> 3 <em>/<br>/</em></strong>/ (function(module, exports) {</p><p>var Vue = ‘Fake Vue’;<br>exports.Vue = Vue;</p><p>/<strong><em>/ }),<br>/</em> 4 <em>/,<br>/</em> 5 <em>/,<br>/</em> 6 <em>/<br>/</em></strong>/ (function(module, exports, __webpack_require__) {</p><p><strong>webpack_require__(2);<br>module.exports = __webpack_require</strong>(3);</p><p>/***/ })<br>],[6]);</p><pre><code>#### CommonsChunkPlugin更多资料参考[CommonsChunkPlugin](https://link.jianshu.com/?t=https://webpack.js.org/plugins/commons-chunk-plugin/)  [webpack CommonsChunkPlugin详细教程](https://segmentfault.com/a/1190000006808865)## 4、ExtractTextWebpackPlugin 分离 CSSWebpack打包默认会把css和js打包在一块，然而我们通常习惯将css代码中放在标签中，而将js引用放在页面底部；将css代码放在页面头部可以避免 FOUC 问题\(表现为页面内容已经加载出来，但是没有样式，过了一会儿样式文件加载出来之后页面回复正常\)；同时如果css和js分离也有利于这加强样式的可缓存性；这是我们需要ExtractTextWebpackPlugin来分离js与css使得样式文件单独打包。#### webpack处理css在代码中想JavaScript模块一样引入css文件  import styles from ‘./style.css’需要借助css-loader  和 style-loader  ：</code></pre><p>npm install –save-dev css-loader style-loader</p><pre><code>在 webpack.config.js 中配置如下：</code></pre><p>module.exports = {<br>    module: {<br>        rules: [{<br>            test: /.css$/,<br>            use: [ ‘style-loader’, ‘css-loader’ ]<br>        }]<br>    }<br>}</p><pre><code>这样，CSS 会跟你的 JavaScript 打包在一起，并且在初始加载后，通过一个#### 使用 ExtractTextWebpackPlugin安装</code></pre><p>npm install –save-dev extract-text-webpack-plugin</p><pre><code>为了使用这个插件，它需要通过三步被配置到 webpack.config.js 文件中。</code></pre><p>var ExtractTextPlugin = require(‘extract-text-webpack-plugin’);<br>module.exports = {<br>    module: {<br>         rules: [{<br>             test: /.css$/,<br>            use: ExtractTextPlugin.extract({<br>                     fallback: ‘style-loader’,<br>                    use: [<br>                        {<br>                            loader: ‘css-loader’,<br>                            options: {<br>                                sourceMap: true,<br>                                importLoaders: 1,<br>                                modules: true,<br>                                localIdentName: “[local]—[hash:base64:5]”,<br>                                camelCase: true<br>                            }<br>                        }]<br>            })<br>         }]<br>     },<br>    plugins: [<br>        new ExtractTextPlugin( ({<br>            filename: ‘[name].css’,//使用模块名命名<br>            allChunks: true<br>        })<br>    ]<br>}</p><pre><code>通过加入ExtractTextWebpackPlugin，每个模块的css都会生成一个新文件，此时你可以作为一个单独标签添加到html文件中。#### 更多ExtractTextWebpackPlugin资料参考[webpack-contrib/extract-text-webpack-plugin](https://github.com/webpack-contrib/extract-text-webpack-plugin)  [webpack ExtractTextWebpackPlugin](https://link.jianshu.com/?t=https://webpack.js.org/plugins/extract-text-webpack-plugin/)## 5、UglifyJsPlugin代码压缩输出代码压缩插件UglifyJsPlugin通过UglifyJS2来完成代码压缩，配置参考UglifyJS2，  调用例子：</code></pre><p> new webpack.optimize.UglifyJsPlugin({<br>      compress: {<br>        warnings: false<br>      }<br>    })</p><pre><code>##6、设置全局变量插件  [DefinePlugin](https://webpack.js.org/plugins/define-plugin)</code></pre><p>// webpack.config.js<br>const webpack = require(‘webpack’);</p><p>module.exports = {<br>  /<em>…</em>/<br>  plugins:[<br>    new webpack.DefinePlugin({<br>      ‘process.env.NODE_ENV’: JSON.stringify(‘production’)<br>    })<br>  ]<br>};</p><pre><code>通过DefinePlugin定义的变量可在全局代码中使用，例如Webpack配置文件定义了process.env.NODE\_ENV=‘production’，如果代码中存在如下调用：</code></pre><p>if (process.env.NODE_ENV !== ‘production’) console.log(‘…’) </p><pre><code>即等同于</code></pre><p>if (false) console.log(‘…’)</p><pre><code>原理：DefinePlugin做的工作是在源代码基础上执行的全局查找替换工作，将DefinePlugin插件中定义的变量替换为插件中定义的变量值。  参考  [DefinePlugin](https://webpack.js.org/plugins/define-plugin)## DllPlugin\&amp; DllReferencePlugin在前端项目构建中，为了提高打包效率，往往会将业务代码合第三方库打包。  之前有将将到过CommonsChunkPlugin可提供第三方库单独打包方法。但是由于每次运行Webpack，即使没有代码更新，也会重新打包，Webpack打包慢也是一直被诟病的问题，竟然减少打包内容才是王道；  其实Webpack还提供了一个提供了另外一个配置项Externals，提供了「从输出的 bundle 中排除依赖」的方法：  如</code></pre><p>index.html<br>…</p><script src="https://code.jquery.com/jquery-3.1.0.js" integrity="sha256-slogkvB1K3VOkzAI8QITxV3VzpOnkeNVsKvtkYLMjfk=" crossorigin="anonymous"></script><p>…</p><p>webpack.config.js<br>externals: {<br>  jquery: ‘jQuery’<br>}</p><pre><code>这样就剥离了那些不需要改动的依赖模块，换句话，下面展示的代码还可以正常运行：</code></pre><p>import $ from ‘jquery’;</p><p>$(‘.my-element’).animate(…);</p><pre><code>不过externals虽然解决了外部引用问题，但如果遇到像react模块本身引入react入口文件，但是 Webpack 不知道这个入口文件等效于 react 模块本身时，会出现重复打包现象，详见彻底解决 Webpack 打包性能问题。  Webpack提供了DllPlugin、DllReferencePlugin两个插件，既能解决第三方库代码无变化仍然要打包增加打包时间问题，也能解决通过外链引用但可能第三方库还是被打包进来的问题。  DllPlugin插件用来把需要独立打包的第三方库分离出来单独打包最后会输出两个文件，一个是打包好的第三方库bundle还有一个是用来给 DllReferencePlugin  映射依赖的manifest.json  使用方法：  （1）新建一个专门用来打包第三方库的Webpack配置文件</code></pre><p>//webpack.dll.config.js<br>const webpack = require(‘webpack’);<br>module.exports = {<br>    entry: {<br>        react: [‘./res/polyfill.js’, ‘react’, ‘react-dom’, ‘redux’, ‘react-redux’, ‘react-router’]<br>    },<br>    output: {<br>          filename: ‘[name].bundle.js’,<br>        path: path.join(__dirname, ‘res’),<br>        library: ‘[name]_lib’<br>    },<br>    plugins: [<br>        new webpack.DllPlugin({<br>            path: ‘.res/[name]-manifest.json’,//manifest.json输出路径，DllReferencePlugin需要用到</p><pre><code>        name: '[name]_library',//打包库文件名       context：__dirname//可选，引用manifest.json的上下文,默认为Webpack配置文件上下文    })]</code></pre><p>};</p><pre><code>运行webpack.dll.config.js</code></pre><p>webpack –config webpack.dll.config.js</p><pre><code>生成打包好的库bundle，和manifest.json文件 ‘bundle.manifest.json’，大致内容如下：</code></pre><p>{<br> “name”: “react_lib”,<br>  “content”: {<br>    “./node_modules/core-js/modules/_export.js”: {<br>      “id”: 0,<br>      “meta”: {}<br>    },<br>    “./node_modules/core-js/modules/_global.js”: {<br>      “id”: 1,<br>      “meta”: {}<br>    },<br>    “./node_modules/preact-compat/dist/preact-compat.es.js”: {<br>      “id”: 2,<br>      “meta”: {<br>        “harmonyModule”: true<br>      },<br>//其他引用<br>}</p><pre><code>2、配置webpack.config.js中的插件DllReferencePlugin</code></pre><p> plugins: [<br>        new webpack.DllReferencePlugin({<br>            context: ‘.’,//需要与webpack.dll.config.js中DllPlugin上下文一致<br>            manifest: require(‘./res/react-manifest.json’)//DllPlugin输出的manifest.json文件<br>        })]</p><p>```</p><p>通过两步完美分离第三方库~~~~</p><h6 id="DllPlugin-amp-DllReferencePlugin资料"><a href="#DllPlugin-amp-DllReferencePlugin资料" class="headerlink" title="DllPlugin&amp;DllReferencePlugin资料"></a>DllPlugin&amp;DllReferencePlugin资料</h6><p><a href="https://link.jianshu.com/?t=https://webpack.js.org/plugins/dll-plugin/#components/sidebar/sidebar.jsx">DllPlugin</a><br><a href="https://link.jianshu.com/?t=https://juejin.im/entry/57996222128fe1005411c649">彻底解决 Webpack 打包性能问题</a><br><a href="https://link.jianshu.com/?t=https://github.com/chenchunyong/webpack-dllPlugin">webpack dllPlugin 使用</a></p><p><a href="https://link.jianshu.com/?t=https://github.com/chenchunyong/webpack-dllPlugin">转自：清晓凝露 链接：https://www.jianshu.com/p/08859e5651fc 来源：简书</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
