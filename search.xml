<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webpack性能优化</title>
      <link href="/blog/other/20200730003/"/>
      <url>/blog/other/20200730003/</url>
      
        <content type="html"><![CDATA[<h1 id="1-剔除不必要的代码"><a href="#1-剔除不必要的代码" class="headerlink" title="1. 剔除不必要的代码"></a>1. 剔除不必要的代码</h1><h2 id="1-1-引入未使用"><a href="#1-1-引入未使用" class="headerlink" title="1.1 引入未使用"></a>1.1 引入未使用</h2><p>对于js，tree-shaking 贯穿整个依赖树，检查被使用的依赖，移除无用的依赖。 对于css,purifycss-webpack未使用的css不会被打包进来</p><h2 id="1-2-避免重复引入"><a href="#1-2-避免重复引入" class="headerlink" title="1.2 避免重复引入"></a>1.2 避免重复引入</h2><h3 id="1-2-1-externals"><a href="#1-2-1-externals" class="headerlink" title="1.2.1 externals"></a>1.2.1 externals</h3><p>(1)使用变量或外部引用来引入模块，如果两个模块有公共部分，比如jquery，可以避免重复下载。只需在入口.html文件中，使用script引入即可。</p><p>(2)将模块挂载到window上，减少重复的请求模块。配置：</p><pre><code>module.exports = &amp;#123;    externals: &amp;#123;    'react': 'React',    'react-dom': 'ReactDOM',    &amp;#125;,&amp;#125;;复制代码</code></pre><h3 id="1-2-2-CommonsChunkPlugin"><a href="#1-2-2-CommonsChunkPlugin" class="headerlink" title="1.2.2 CommonsChunkPlugin"></a>1.2.2 CommonsChunkPlugin</h3><p>提取公共部分。webpack4之后使用optimization.splitChunks代替。</p><h2 id="1-3-避免执行依赖模块的无用代码"><a href="#1-3-避免执行依赖模块的无用代码" class="headerlink" title="1.3 避免执行依赖模块的无用代码"></a>1.3 避免执行依赖模块的无用代码</h2><p>很多模块在生产production模式都会有一些警示性代码，如下图，而这类代码在实际环境中，并没什么用，却占用着资源。使用webpack的DefinePlugin可以解决这个问题。或者使用webpack.EnvironmentPlugin起到类似作用。参考：<a href="https://webpack.js.org/plugins/environment-plugin/">webpack.js.org/plugins/env…</a></p><pre><code>//将process.env.NODE_ENV替换成production。new webpack.DefinePlugin(&amp;#123;'process.env.NODE_ENV': '"production"',&amp;#125;),//上图里面的代码会变成：if("production" !== 'production')&amp;#123;//永远为false，不会进入分支    .......&amp;#125;复制代码</code></pre><h2 id="1-4-避免构建不必要的代码"><a href="#1-4-避免构建不必要的代码" class="headerlink" title="1.4 避免构建不必要的代码"></a>1.4 避免构建不必要的代码</h2><p>loader时，使用exclude将不必要的文件去除，或者include将需要的文件加进来。</p><h1 id="2-资源压缩"><a href="#2-资源压缩" class="headerlink" title="2. 资源压缩"></a>2. 资源压缩</h1><h2 id="2-1-js压缩"><a href="#2-1-js压缩" class="headerlink" title="2.1 js压缩"></a>2.1 js压缩</h2><h3 id="2-1-1-babel-minify-webpack-plugin"><a href="#2-1-1-babel-minify-webpack-plugin" class="headerlink" title="2.1.1 babel-minify-webpack-plugin"></a>2.1.1 babel-minify-webpack-plugin</h3><p>loader的时候由于文件大小通常非常大，所以会慢很多，所以这个插件有个作用，就是可以在loader的时候进行优化，减少一定的文件体积。</p><h3 id="2-1-2-uglifyjs-webpack-plugin"><a href="#2-1-2-uglifyjs-webpack-plugin" class="headerlink" title="2.1.2 uglifyjs-webpack-plugin"></a>2.1.2 uglifyjs-webpack-plugin</h3><p>js后处理，具有剔除注释、代码压缩等功能。</p><h2 id="2-2-css压缩"><a href="#2-2-css压缩" class="headerlink" title="2.2 css压缩"></a>2.2 css压缩</h2><h3 id="2-2-1-optimize-css-assets-webpack-plugin"><a href="#2-2-1-optimize-css-assets-webpack-plugin" class="headerlink" title="2.2.1 optimize-css-assets-webpack-plugin"></a>2.2.1 optimize-css-assets-webpack-plugin</h3><p>css后处理，可以将注释剔除、css代码压缩等。</p><h2 id="2-3-图片资源压缩"><a href="#2-3-图片资源压缩" class="headerlink" title="2.3 图片资源压缩"></a>2.3 图片资源压缩</h2><h3 id="2-3-1-image-webpack-loader"><a href="#2-3-1-image-webpack-loader" class="headerlink" title="2.3.1 image-webpack-loader"></a>2.3.1 image-webpack-loader</h3><p>压缩图片的作用。配合url-loader/svg-url-loader使用。</p><h2 id="2-4-gzip压缩"><a href="#2-4-gzip压缩" class="headerlink" title="2.4 gzip压缩"></a>2.4 gzip压缩</h2><p>CompressionWebpackPlugin将最后的资源进行gzip压缩，减少体积。</p><h1 id="3-减少网络请求"><a href="#3-减少网络请求" class="headerlink" title="3. 减少网络请求"></a>3. 减少网络请求</h1><h2 id="3-1-图片资源压缩和内联"><a href="#3-1-图片资源压缩和内联" class="headerlink" title="3.1 图片资源压缩和内联"></a>3.1 图片资源压缩和内联</h2><p>url-loader/svg-url-loader/image-webpack-loader url-loader/svg-url-loader设置一定大小内，图片使用内联方式插入html代码中，内联减少了http请求的数量。 image-webpack-loader有压缩图片的作用。</p><h1 id="4-懒加载"><a href="#4-懒加载" class="headerlink" title="4. 懒加载"></a>4. 懒加载</h1><h2 id="4-1-模块按需引入"><a href="#4-1-模块按需引入" class="headerlink" title="4.1 模块按需引入"></a>4.1 模块按需引入</h2><p>比如点击事情，需要用到两一个模块中的Function，只在点击的时候引入这个模块中的Function</p><h2 id="4-2-组件按需引入"><a href="#4-2-组件按需引入" class="headerlink" title="4.2 组件按需引入"></a>4.2 组件按需引入</h2><p>只在页面跳转后，将路由所需的组件加载进来，而不是在第一次刷新的时候，将所有组件都加载到一个文件中，避免文件体积过于庞大，且未使用的时候都算暂时无用的代码。</p><h1 id="5-提高构建速度"><a href="#5-提高构建速度" class="headerlink" title="5. 提高构建速度"></a>5. 提高构建速度</h1><h2 id="5-1-预编译"><a href="#5-1-预编译" class="headerlink" title="5.1 预编译"></a>5.1 预编译</h2><h3 id="5-1-1-dllplugin-amp-DllRefrencePlugin"><a href="#5-1-1-dllplugin-amp-DllRefrencePlugin" class="headerlink" title="5.1.1 dllplugin&amp;DllRefrencePlugin"></a>5.1.1 dllplugin&amp;DllRefrencePlugin</h3><p>DllPlugin结合DllRefrencePlugin插件的运用，对将要产出的bundle文件进行拆解 打包，将公共静态资源拆分打包，可以彻底地加快webpack的打包速度，从而在开发过程中极大地缩减构建时间。之后不管是dev还是production不会重复打包这部分静态资源，大大缩减了构建时间。</p><h3 id="5-1-2-ModuleConcatenationPlugin"><a href="#5-1-2-ModuleConcatenationPlugin" class="headerlink" title="5.1.2 ModuleConcatenationPlugin"></a>5.1.2 ModuleConcatenationPlugin</h3><p>打包的时候，它将一些有联系的模块，放到一个闭包函数里面去，通过减少闭包函数数量从而加快JS的执行速度。</p><h2 id="5-2-多核并行"><a href="#5-2-多核并行" class="headerlink" title="5.2 多核并行"></a>5.2 多核并行</h2><p>在多核电脑上，HappyPack能将任务拆分成多个子进程并发的执行，提高构建速度。 webpack-uglify-parallel也是并行的方式，提升uslifyPlugin的构建速度。</p><h2 id="5-3-减少搜索"><a href="#5-3-减少搜索" class="headerlink" title="5.3 减少搜索"></a>5.3 减少搜索</h2><h3 id="5-3-1-Resolve-module-amp-resolve-alias"><a href="#5-3-1-Resolve-module-amp-resolve-alias" class="headerlink" title="5.3.1 Resolve.module&amp;resolve.alias"></a>5.3.1 Resolve.module&amp;resolve.alias</h3><p>配置webpack去哪里寻找第三方，减少搜索遍历时间损耗。 resolve.alias设置别名，减少搜索路径的时间损耗。</p><h2 id="5-4-devtool"><a href="#5-4-devtool" class="headerlink" title="5.4 devtool"></a>5.4 devtool</h2><p>配置souce-map为合适的值，有的会比较耗时。</p><h1 id="6-自动化监控工具"><a href="#6-自动化监控工具" class="headerlink" title="6. 自动化监控工具"></a>6. 自动化监控工具</h1><h2 id="6-1-webpack-bundle-analyzer"><a href="#6-1-webpack-bundle-analyzer" class="headerlink" title="6.1 webpack-bundle-analyzer"></a>6.1 webpack-bundle-analyzer</h2><p>一个项目，大部分代码来自于依赖的模块，依赖的大小严重影响着项目构建包的大小。webpack-bundle-analyzer分析依赖之间的关系，能清晰看到使用到哪些依赖及对应的大小。可以帮助我们有针对性的去优化使用那些体积大的依赖。该工具会在浏览器中打开一个窗口，展示依赖图。</p><h2 id="6-2-webpack-dashboard"><a href="#6-2-webpack-dashboard" class="headerlink" title="6.2 webpack-dashboard"></a>6.2 webpack-dashboard</h2><p>是增强控制台用户体验的一款工具。dashboard里面按日志(Log)、状态(Status)、运行(Operation)、过程(Progess)、模块(Modules)、产出(Assets)这6个部分将信息按区展示。</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/12/16c83c50b451875e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h2 id="6-3-bundlesize"><a href="#6-3-bundlesize" class="headerlink" title="6.3 bundlesize"></a>6.3 bundlesize</h2><p>设置类型文件的最大大小，当超出范围，会给与警告和提示，帮助分析那些模块体积过大。</p><p><a href="https://juejin.im/post/6844903910973374478">转自 【掘金**~cyndarila**】</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文搞定Node.js流 （Stream）</title>
      <link href="/blog/backend/20200730004/"/>
      <url>/blog/backend/20200730004/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一直不太理解 Node.js 中 Stream 的概念，最近深入学习了一下，争取一篇文章说清楚。 文章中的代码地址：<a href="https://github.com/Maricaya/node-stream">github.com/Maricaya/no…</a></p></blockquote><h1 id="Stream-流是什么？"><a href="#Stream-流是什么？" class="headerlink" title="Stream 流是什么？"></a>Stream 流是什么？</h1><p>stream（流）是一种抽象的数据结构。就像数组或字符串一样，流是数据的集合。</p><p>不同的是，流可以每次输出少量数据，而且它不用存在内存中。</p><p>比如，对服务器发起 http 请求的 <code>request/response</code> 对象就是 Stream。</p><h2 id="图解-Stream"><a href="#图解-Stream" class="headerlink" title="图解 Stream"></a>图解 Stream</h2><p>stream 就像是水流，但默认是没有水的。 stream.write 可以让水流中有水，也就是写入数据。</p><p>左上角是产生数据的一段，称为 source（源头）。 最下面是得到数据的一段 sink（水池）。 从上向下流动的小圆点是每次写的小数据，称为 chunk（块）。</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/173869cb08686702?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><h2 id="为什么需要-Stream"><a href="#为什么需要-Stream" class="headerlink" title="为什么需要 Stream"></a>为什么需要 Stream</h2><p>同学们可能有这样的疑问，流的作用不就是传递数据吗，不用流 node 也可以实现读写操作啊。</p><p>是的，但是读写方式是把文件内容全部读入内存，然后再写入文件，小型文件这么处理问题不大。</p><p>但是遇到较大的文件，实在承受不住。</p><p>而流可以把文件资源拆分成小块，一块一块的运输，资源就像水流一样进行传输，减轻服务器压力。</p><h1 id="Stream-实例"><a href="#Stream-实例" class="headerlink" title="Stream 实例"></a>Stream 实例</h1><p>可能这么描述并不能让大家信服， 我们来做一个试验，看看在读写大文件时有没有必要使用流。</p><p>首先创建一个大文件：</p><h2 id="用-Stream-创建大文件"><a href="#用-Stream-创建大文件" class="headerlink" title="用 Stream 创建大文件"></a>用 Stream 创建大文件</h2><p>我们首先创建一个可写流，向文件里多次写入内容。 最后记得关闭流，得到一个大文件。</p><pre><code>// 引入文件模块const fs = require('fs');const stream = fs.createWriteStream('./../big_file.txt');for (let i = 0; i &lt; 1000000; i++) &amp;#123;  stream.write(`这是第$&amp;#123;i&amp;#125;行内容\n`);&amp;#125;stream.end()console.log('done')复制代码</code></pre><h2 id="使用-readFile"><a href="#使用-readFile" class="headerlink" title="使用 readFile"></a>使用 readFile</h2><p>我们先使用 fs.readFile 来读取文件内容，看看会发生什么。</p><pre><code>const fs = require('fs')const http = require('http')const server = http.createServer()server.on('request', (request, response) =&gt; &amp;#123;  fs.readFile('./../big_file.txt', (error, data) =&gt; &amp;#123;    if (error) throw error    response.end(data)    console.log('done')  &amp;#125;)&amp;#125;)server.listen(8889)console.log(8889)复制代码</code></pre><p>当我们访问 <code>http://localhost:8889</code> 的时候，服务器会异步读取这个大文件。</p><p>看起来一切正常，没什么毛病。</p><p>但是，我们用任务管理器查看 Node.js 的内存，大概占用 130Mb。</p><p>服务器接收 1 次请求，占用 130 Mb；那如果接受 10 次请求，就是占用 1G。 对服务器的内存消耗是很大的。</p><p>怎么解决这个问题呢？使用 Stream。</p><h2 id="使用-Stream"><a href="#使用-Stream" class="headerlink" title="使用 Stream"></a>使用 Stream</h2><p>我们来试试用 Stream 改写上面的例子。</p><p>创建一个可读流 <code>createReadStream</code>， 再把文件 <code>stream</code> 和 <code>response stream</code> 通过管道 <code>pipe</code> 相连。</p><pre><code>const fs = require('fs')const http = require('http')const server = http.createServer()server.on('request', (request, response) =&gt; &amp;#123;    const stream = fs.createReadStream('./big_file.txt')    stream.pipe(response)&amp;#125;)server.listen(8888)复制代码</code></pre><p>我们再次查看 node.js 内存占用，基本不会高于 30Mb。</p><p>因为每次只传递一小段数据，不会占用很大内存。</p><h1 id="管道-pipe"><a href="#管道-pipe" class="headerlink" title="管道 pipe"></a>管道 pipe</h1><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/173869d998e4c5cf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>两个流可以用一个管道相连，stream1 的末尾连接上 stream2 的开端。</p><p>只要 stream1 有数据，就会流到 stream2。</p><p>比如上面的代码：</p><pre><code>const stream = fs.createReadStream('./big_file.txt')stream.pipe(response)复制代码</code></pre><p><code>stream</code> 就是一个文件流，下面的 stream 就是我们的 http 流 response。 本来这两个流是没有关系的，现在我们想把文件流的数据传递给 http 流。 很简单，用 pipe 连接就行啦。</p><h2 id="常用代码"><a href="#常用代码" class="headerlink" title="常用代码"></a>常用代码</h2><p><code>stream1.pipe(stream2)</code></p><ul><li>stream1 是发出数据的流，一个可读流。</li><li>stream2 是写入数据的流，一个可写流。</li></ul><h2 id="链式操作"><a href="#链式操作" class="headerlink" title="链式操作"></a>链式操作</h2><p>一个水流可以经过无限个管道，数据流也一样。</p><p>有两种写法：</p><pre><code>a.pipe(b).pipe(c)// 等价于a.pipe(b)b.pipe(c)复制代码</code></pre><h2 id="管道原理"><a href="#管道原理" class="headerlink" title="管道原理"></a>管道原理</h2><p>管道也可以认为是两个事件的封装</p><ul><li>监听 data 事件，stream1 一有数据就塞给 stream2</li><li>监听 end 事件，当 stream1 停了，就停掉 stream2</li></ul><pre><code>stream1.on('data', (chunk) =&gt; &amp;#123;    stream2.write(chunk)&amp;#125;)stream1.on('end', () =&gt; &amp;#123;    stream2.end()&amp;#125;)复制代码</code></pre><h1 id="Stream-对象的原型链"><a href="#Stream-对象的原型链" class="headerlink" title="Stream 对象的原型链"></a>Stream 对象的原型链</h1><p>了解 Stream 的原型链，可以更容易地记忆 Stream 的 API。</p><h2 id="fs-createReadStream-path"><a href="#fs-createReadStream-path" class="headerlink" title="fs.createReadStream(path)"></a>fs.createReadStream(path)</h2><p>如果 <code>s = fs.createReadStream(path)</code> ，那么<code>s</code>的对象层级为：</p><ol><li>自身的属性，由 <code>fs.ReadStream</code> 构造函数构造的</li><li>原型: <code>stream.Readable.prototype</code></li><li>二级原型: <code>stream.Stream.prototype</code></li><li>三级原型: <code>events.EventEmitter.prototype</code> 这是所有 Stream 都继承的原型</li><li>四级原型: <code>Object.prototype</code> 也就是所有对象都继承的原型</li></ol><h1 id="Stream-支持的事件和方法"><a href="#Stream-支持的事件和方法" class="headerlink" title="Stream 支持的事件和方法"></a>Stream 支持的事件和方法</h1><p>了解了原型链之，我们来看看 Stream 支持的事件和方法。</p><p>大概有个印象就好，用到的时候再去查。</p><table><thead><tr><th></th><th>Readable Stream</th><th>Writable Stream</th></tr></thead><tbody><tr><td>事件</td><td>data, end, error,close,readable</td><td>drain(这一次写完),finish(整个写完),error,close,pipe,unpipe</td></tr><tr><td>方法</td><td>pipe() unpipe() read()…</td><td>write() destroy() …</td></tr></tbody></table><h1 id="Stream-分类"><a href="#Stream-分类" class="headerlink" title="Stream 分类"></a>Stream 分类</h1><p>一共分为四类</p><table><thead><tr><th>名称</th><th>特点</th></tr></thead><tbody><tr><td>Readable</td><td>可读</td></tr><tr><td>Writable</td><td>可写</td></tr><tr><td>Duplex</td><td>可读可写（双向）</td></tr><tr><td>Transform</td><td>可读可写（变化）</td></tr></tbody></table><p>Readable、Writable 都是单向的，其他两个是双向的。</p><p>可读、可写好理解，剩下两个有什么区别呢？</p><p><img src="https://user-gold-cdn.xitu.io/2020/7/25/173869e8a42d0879?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></p><p>Duplex 可以读写，但是读的内容和写的内容是相互独立的，没有交叉。</p><p>而 Transform 是自己写自己读。</p><p>比如一个 babel，把es6转换为，我们在左边写入 es6，从右边读取 es5。 就像洗车一样，黑车进去，白车出来。</p><h2 id="Readable-Stream-可读流"><a href="#Readable-Stream-可读流" class="headerlink" title="Readable Stream 可读流"></a>Readable Stream 可读流</h2><h3 id="静止态-paused-和流动态-flowing"><a href="#静止态-paused-和流动态-flowing" class="headerlink" title="静止态 paused 和流动态 flowing"></a>静止态 paused 和流动态 flowing</h3><p>可读流有两个状态 paused 和 flowing。</p><p>可以把可读流看成内容生产者，不发内容时就是静止态，内容恢复发送时就是流动态。</p><ul><li>可读流默认处于 paused 态。</li><li>一旦添加 data 事件监听，它就变为 flowing 态。</li><li>删掉 data 事件监听，paused 态。</li><li>pause() 可以将它变为 paused。</li><li>resume() 可以将它变为 flowing。</li></ul><pre><code>const http = require('http')const fs = require('fs')const server = http.createServer()server,on('request', (request, response) =&gt; &amp;#123;  // 默认处于 paused 态  const stream = fs.createReadStream('./big_file.txt')  stream.pipe(response)  stream.pause(); // 暂停  setTimeout(() =&gt; &amp;#123;  // 恢复    stream.resume()  &amp;#125;, 3000)&amp;#125;)server.listen(8888);复制代码</code></pre><h1 id="Writable-Stream"><a href="#Writable-Stream" class="headerlink" title="Writable Stream"></a>Writable Stream</h1><h2 id="drain-流干了事件"><a href="#drain-流干了事件" class="headerlink" title="drain 流干了事件"></a>drain 流干了事件</h2><p>表示可以加点水了，也就是可以继续写入数据了。 我们调用 <code>stream.write(chunk)</code> 的时候，可能会得到 false。</p><p>false 的意思是你写太快了，积压数据。</p><p>这个时候我们就不能再 write 了，要监听 drain。</p><p>等 drain 事件触发了，我们才能继续 write。</p><p>光看这些有点难以理解，可以看看 <a href="https://nodejs.org/api/stream.html#stream_event_drain">官网上的例子</a>：</p><pre><code>const fs = require('fs');// 将 data 写入文件 1000000 次function writeOneMillionTimes(writer, data) &amp;#123;  let i = 1000000;  write();  function write() &amp;#123;    let ok = true;    do &amp;#123;      i--;      if (i === 0) &amp;#123;        // 最后一次写入        writer.write(data);      &amp;#125; else &amp;#123;        // 在这里判断是不是可以继续写    // ok 为 false 的意思是你写太快了，数据积压        ok = writer.write(data);        if (ok === false) &amp;#123;          console.log('不能再写了')        &amp;#125;      &amp;#125;    &amp;#125; while (i &gt; 0 &amp;&amp; ok);    if (i &gt; 0) &amp;#123;      // 干涸了,可以继续写入       writer.once('drain', () =&gt; &amp;#123;        console.log('干涸了')        write()      &amp;#125;);    &amp;#125;  &amp;#125;&amp;#125;const write = fs.createWriteStream('./../big_file.txt')writeOneMillionTimes(write, 'hello world')复制代码</code></pre><h2 id="finish-事件"><a href="#finish-事件" class="headerlink" title="finish 事件"></a>finish 事件</h2><p>在调用 <code>stream.end()</code> 之后，而且缓冲区数据都已经传给底层系统之后，触发 finish 事件。</p><p>我们往文件中写入数据时，不是直接存入硬盘中，而是先放入缓冲区。 当数据到达一定大小后，才会写入硬盘。</p><h1 id="创建自己的流"><a href="#创建自己的流" class="headerlink" title="创建自己的流"></a>创建自己的流</h1><p>下面我们来看看，如何创建自己的流。</p><p>按照流的四个类型依次讲解。</p><h2 id="Writable"><a href="#Writable" class="headerlink" title="Writable"></a>Writable</h2><pre><code>const &amp;#123;Writable&amp;#125; = require('stream')const outStream = new Writable(&amp;#123;  // 如果别人调用，我们做什么  write(chunk, encoding, callback) &amp;#123;    console.log(chunk.toString())    // 进入下一个流程    callback()  &amp;#125;&amp;#125;)process.stdin.pipe(outStream);复制代码</code></pre><p>保存文件为 writable.js 然后用 node 运行。 不管你输入什么，都会得到相同的结果。</p><h2 id="Readable"><a href="#Readable" class="headerlink" title="Readable"></a>Readable</h2><h3 id="一次读取所有数据"><a href="#一次读取所有数据" class="headerlink" title="一次读取所有数据"></a>一次读取所有数据</h3><pre><code>const &amp;#123;Readable&amp;#125; = require('stream')const inStream = new Readable()inStream.push('hello world') // 写入数据inStream.push('hello node')inStream.push(null) // 没有数据了// 将这个可读流，导入到可写流 process.stdout。inStream.pipe(process.stdout)复制代码</code></pre><p>先把所有数据都 push 进 inStream，再使用管道导入到可写流 <code>process.stdout</code> 中。</p><p>这样，当我们用 node 运行文件时，我们可以从 inStream 中读取所有数据，并且打印出来。</p><p>这种方式非常简单，但是并不高效。</p><p>更好的方式是按需 push，当用户需要的时候，我们才读取数据。</p><h3 id="调用-read-才会给一次数据"><a href="#调用-read-才会给一次数据" class="headerlink" title="调用 read 才会给一次数据"></a>调用 read 才会给一次数据</h3><p>这种写法数据是按需供给的，对方调用 <code>read</code> ，我们才会给一次数据。</p><p>例如下面这个例子，我们一次 <code>push</code> 一个字符，从字符码 65（代表 A） 开始。</p><p>当用户读取时，会持续触发 <code>read</code>，我们会 <code>push</code> 更多地字符。</p><p>当字符全部 <code>push</code> 完毕，我们 <code>push null</code>，停止 Stream。</p><pre><code>const &amp;#123;Readable&amp;#125; = require('stream')const inStream = new Readable(&amp;#123;  read(size) &amp;#123;    const char = String.fromCharCode(this.currentCharCode++)    this.push(char);    console.log(`推了$&amp;#123;char&amp;#125;`)    // 这个时候停止    if (this.currentCharCode &gt; 90) &amp;#123; // Z      this.push(null)    &amp;#125;  &amp;#125;&amp;#125;)inStream.currentCharCode = 65 // AinStream.pipe(process.stdout)复制代码</code></pre><h2 id="Duplex-Stream"><a href="#Duplex-Stream" class="headerlink" title="Duplex Stream"></a>Duplex Stream</h2><p>看完了可读流、可写流，<code>Duplex Stream</code> 就简单多了。</p><p>同时实现 <code>write</code> 和 <code>read</code> 方法就好啦。</p><pre><code>const &amp;#123;Duplex&amp;#125; = require('stream')const inoutStream = new Duplex(&amp;#123;  write(chunk, encoding, callback) &amp;#123;    console.log(chunk.toString())    callback()  &amp;#125;,  read(size) &amp;#123;    this.push(String.fromCharCode(this.currentCharCode++))    if (this.currentCharCode &gt; 90) &amp;#123;      this.pull(null)    &amp;#125;  &amp;#125;&amp;#125;)inoutStream.currentCharCode = 65;process.stdin.pipe(inoutStream).pipe(process.stdout);复制代码</code></pre><h2 id="Transform-Stream"><a href="#Transform-Stream" class="headerlink" title="Transform Stream"></a>Transform Stream</h2><p>对于 Transform Stream，我们实现 transform 方法就好了，它结合了可读、可写两个方法。</p><p>这里有一个简单的 transform 例子，会以大写的格式打印任何你键入的字符：</p><pre><code>const &amp;#123;Transform&amp;#125; = require('stream')const upperCaseTr = new Transform(&amp;#123;  transform(chunk, encoding, callback) &amp;#123;    // 1. 读数据 chunk.toString()    // 2. 写数据 this.push(xxx)    this.push(chunk.toString().toUpperCase())    callback();  &amp;#125;&amp;#125;)// 监听用户输入，调用 upperCaseTr// 转化完成后，输出process.stdin.pipe(upperCaseTr)     .pipe(process.stdout)复制代码</code></pre><h1 id="Node-js-内置的-Transform-Stream"><a href="#Node-js-内置的-Transform-Stream" class="headerlink" title="Node.js 内置的 Transform Stream"></a>Node.js 内置的 Transform Stream</h1><p>比如面试中经常说的优化方案：gzip 压缩。</p><p>在 Node.js 中用 4 行代码就可以实现</p><pre><code>const fs = require('fs')const zlib = require('zlib')const file = process.argv[2]fs.createReadStream(file)  .pipe(zlib.createGzip())    .on('data', () =&gt; process.stdout.write(".")) // 打出进度条  .pipe(fs.createWriteStream(file + ".gz"))复制代码</code></pre><h1 id="Stream-在-Node-js-中随处可见"><a href="#Stream-在-Node-js-中随处可见" class="headerlink" title="Stream 在 Node.js 中随处可见"></a>Stream 在 Node.js 中随处可见</h1><table><thead><tr><th>Readable Stream</th><th>Writeable Stream</th></tr></thead><tbody><tr><td>HTTP Response 客户端</td><td>HTTP Request 客户端</td></tr><tr><td>HTTP Request 服务端</td><td>HTTP Response 服务端</td></tr><tr><td>fs read stream</td><td>fs write stream</td></tr><tr><td>zlib stream</td><td>zlib stream</td></tr><tr><td>TCP sockets</td><td>TCP sockets</td></tr><tr><td>child process stdout &amp; stderr</td><td>child process stdin</td></tr><tr><td>process.stdin</td><td>process.stdout,process.stderr</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><h1 id="数据积压问题"><a href="#数据积压问题" class="headerlink" title="数据积压问题"></a>数据积压问题</h1><p>在 Stream 中，还有一个非常重要的问题：数据积压。</p><p>如果数据太多，堵住了，怎么解决。</p><p>Node.js 官网有一篇专门的文章解释如何解决，大家碰到问题的时候可以翻出来看看。</p><p>我在这里就不赘述了，<a href="https://nodejs.org/zh-cn/docs/guides/backpressuring-in-streams/">地址在这里</a></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>来总结下到目前为止，我们了解的 Stream 对象。</p><ul><li><p>为什么使用 Stream 呢？</p><ul><li>因为读写大文件的时候，可以有效降低内存压力。</li></ul></li><li><p>管道 pipe 是 Stream 中的一个重要概念，可以连接流。</p></li><li><p>Stream 对象都继承了 EventEmitter。</p></li><li><p>Stream 分为四类</p><ul><li>可读 Readable，有两个状态：paused、flowing。</li><li>可写 Writable，两个重要事件：drain、finish。</li><li>可读可写（双向）Duplex</li><li>可读可写（变化）Transform</li></ul></li><li><p>最后了解如何创建四类 Stream 和 Node.js 中的 Stream</p></li></ul><p><a href="https://juejin.im/post/6854573219060400141">转自【掘金 <strong>Marica</strong>】</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> backend </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象深拷贝和浅拷贝</title>
      <link href="/blog/web/20200730001/"/>
      <url>/blog/web/20200730001/</url>
      
        <content type="html"><![CDATA[<p>各类技术论坛关于深拷贝的博客有很多,有些写的也比我好,那为什么我还要坚持写这篇博客呢,之前看到的一篇<a href="https://juejin.im/post/5c0c87b35188252e8966c78a">博客</a>中有句话写的非常好</p><blockquote><p>学习就好比是座大山，人们沿着不同的路登山，分享着自己看到的风景。你不一定能看到别人看到的风景，体会到别人的心情。只有自己去登山，才能看到不一样的风景，体会才更加深刻。</p></blockquote><p>写博客的初衷也是作为自己学到的知识点的总结,同时也希望能给点开这篇文章的人一些帮助,在前端开发的路上能够少一点坎坷多一点希望</p><p><strong>如有错误欢迎指出会在第一时间改正</strong></p><h1 id="基本类型的值和引用类型的值"><a href="#基本类型的值和引用类型的值" class="headerlink" title="基本类型的值和引用类型的值"></a>基本类型的值和引用类型的值</h1><p>JavaScript的变量中包含两种类型的值</p><h2 id="基本类型值"><a href="#基本类型值" class="headerlink" title="基本类型值"></a><strong>基本类型值</strong></h2><p>基本类型值指的是存储在栈中的一些简单的数据段</p><pre class=" language-dart"><code class="language-dart"><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token keyword">var</span> num <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><p>在JavaScript中基本数据类型有String,Number,Undefined,Null,Boolean，在ES6中，又定义了一种新的基本数据类型Symbol,所以一共有6种</p><p>基本类型是按值访问的，从一个变量复制基本类型的值到另一个变量后这2个变量的值是完全独立的，即使一个变量改变了也不会影响到第二个变量</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">var</span> str1 <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">;</span><span class="token keyword">var</span> str2 <span class="token operator">=</span> str1<span class="token punctuation">;</span>str2 <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//'b'</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//'a'</span></code></pre><h2 id="引用类型值"><a href="#引用类型值" class="headerlink" title="引用类型值"></a><strong>引用类型值</strong></h2><p>引用类型值是引用类型的实例，它是保存在堆内存中的一个对象，引用类型是一种数据结构，最常用的是Object,Array,Function类型，另外还有Date,RegExp,Error等，ES6同样也提供了Set,Map2种新的数据结构</p><h2 id="JavaScript是如何复制引用类型的"><a href="#JavaScript是如何复制引用类型的" class="headerlink" title="JavaScript是如何复制引用类型的"></a>JavaScript是如何复制引用类型的</h2><p>JavaScript对于基本类型和引用类型的赋值是不一样的</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> ob2 <span class="token operator">=</span> obj1<span class="token punctuation">;</span>obj2<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:2&amp;#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:2&amp;#125;</span></code></pre><p>在这里只修改了obj1中的a属性，却同时改变了ob1和obj2中的a属性</p><p>当变量复制引用类型值的时候，同样和基本类型值一样会将变量的值复制到新变量上，不同的是对于变量的值，它是一个指针，指向存储在堆内存中的对象（JS规定放在堆内存中的对象无法直接访问，必须要访问这个对象在堆内存中的地址，然后再按照这个地址去获得这个对象中的值，所以引用类型的值是按引用访问）</p><p>变量的值也就是这个指针是存储在栈上的，当变量obj1复制变量的值给变量obj2时，obj1,obj2只是一个保存在栈中的指针,指向同一个存储在堆内存中的对象，所以当通过变量obj1操作堆内存的对象时，obj2也会一起改变</p><p><img src="https://imgkr.cn-bj.ufileos.com/a87f5944-9fd3-4021-be03-3ad11f39b9f7.jpg"></p><p>保存在于栈中的变量和堆内存中对象的关系</p><p>再举个例子，小明(obj1变量)知道他家的地址(对象{a:1})，然后小明告诉了小刚(obj2变量)他家的地址(复制变量)，小刚这个时候就知道了小明家的地址，然后小刚去小明家把小明家的门给拆了(修改对象)，小明回家一看就会发现门没了,这时小明和小刚去这个地址的时候都会看到一个没有门的家-.-(对象的修改反映到变量)</p><h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>对于浅拷贝的定义可以理解为</p><blockquote><p>创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p></blockquote><p>以下是一些JavaScript提供的浅拷贝方法</p><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p>ES6中拷贝对象的方法，接受的第一个参数是拷贝的目标，剩下的参数是拷贝的源对象（可以是多个）</p><blockquote><p>语法：Object.assign(target, …sources)</p></blockquote><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">var</span> target <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> source <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>target <span class="token punctuation">,</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:1&amp;#125;</span>source<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:2&amp;#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:1&amp;#125;</span></code></pre><p>Object.assign是一个浅拷贝,它只是在<strong>根属性</strong>(对象的第一层级)创建了一个新的对象，但是对于属性的值是仍是对象的话依然是浅拷贝，</p><p><strong>Object.assign还有一些注意的点是:</strong></p><ol><li>不会拷贝对象继承的属性</li><li>不可枚举的属性</li><li>属性的数据属性/访问器属性</li><li>可以拷贝Symbol类型</li></ol><p>可以理解为Object.assign就是使用简单的=来赋值,遍历从右往左遍历源对象(sources)的所有属性用 <strong>=</strong> 赋值到目标对象(target)上</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>    a<span class="token punctuation">:</span><span class="token entity" title="&#123;">&amp;#123;</span>        b<span class="token punctuation">:</span><span class="token number">1</span>    <span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">,</span>    sym<span class="token punctuation">:</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span><span class="token string">'innumerable'</span><span class="token punctuation">,</span><span class="token entity" title="&#123;">&amp;#123;</span>    value<span class="token punctuation">:</span><span class="token string">'不可枚举属性'</span><span class="token punctuation">,</span>    enumerable<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>obj2<span class="token punctuation">,</span>obj1<span class="token punctuation">)</span>obj1<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj1'</span><span class="token punctuation">,</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj2'</span><span class="token punctuation">,</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p><img src="https://imgkr.cn-bj.ufileos.com/80111e2b-b228-4838-adbf-e9acff055e7b.jpg"></p><p>可以看到Symbol类型可以正确拷贝，但是不可枚举的属性被忽略了并且改变了obj1.a.b的值，obj2.a.b的值也会跟着改变，说明依旧存在访问的是堆内存中同一个对象的问题</p><h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p>利用扩展运算符可以在构造字面量对象时,进行克隆或者属性拷贝</p><blockquote><p>语法：var cloneObj = { …obj };</p></blockquote><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span>b<span class="token punctuation">:</span><span class="token entity" title="&#123;">&amp;#123;</span>c<span class="token punctuation">:</span><span class="token number">1</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span><span class="token operator">...</span>obj<span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>a<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:2,b:&amp;#123;c:1&amp;#125;&amp;#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:1,b:&amp;#123;c:1&amp;#125;&amp;#125;</span>obj<span class="token punctuation">.</span>b<span class="token punctuation">.</span>c <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:2,b:&amp;#123;c:2&amp;#125;&amp;#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:1,b:&amp;#123;c:2&amp;#125;&amp;#125;</span></code></pre><p>扩展运算符Object.assign()有同样的缺陷，对于值是对象的属性无法完全拷贝成2个不同对象,但是如果属性都是基本类型的值的话,使用扩展运算符更加方便</p><h2 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h2><p>slice() 方法返回一个新的数组对象，这一对象是一个由 begin和 end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</p><blockquote><p>语法: arr.slice(begin, end);</p></blockquote><p>在ES6以前,没有剩余运算符,Array.from的时候可以用 Array.prototype.slice将arguments类数组转为真正的数组,它返回一个浅拷贝后的的新数组</p><pre class=" language-jsx"><code class="language-jsx">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token entity" title="&#123;">&amp;#123;</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token string">"aaa"</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token number">1</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//["aaa"]</span><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> arr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span></code></pre><h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>浅拷贝只在根属性上在堆内存中创建了一个新的的对象，复制了基本类型的值,但是复杂数据类型也就是对象则是拷贝相同的地址，而深拷贝则是对于复杂数据类型在堆内存中开辟了一块内存地址用于存放复制的对象并且把原有的对象复制过来，这2个对象是相互独立的,也就是2个不同的地址</p><blockquote><p>将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象</p></blockquote><h2 id="一个简单的深拷贝"><a href="#一个简单的深拷贝" class="headerlink" title="一个简单的深拷贝"></a>一个简单的深拷贝</h2><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>    a<span class="token punctuation">:</span> <span class="token entity" title="&#123;">&amp;#123;</span>        b<span class="token punctuation">:</span> <span class="token number">1</span>    <span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">,</span>    c<span class="token punctuation">:</span> <span class="token number">1</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span>obj2<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span><span class="token entity" title="&#125;">&amp;#125;</span>obj2<span class="token punctuation">.</span>c <span class="token operator">=</span> obj1<span class="token punctuation">.</span>cobj2<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b <span class="token operator">=</span> obj1<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:&amp;#123;b:1&amp;#125;,c:1&amp;#125;;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:&amp;#123;b:1&amp;#125;,c:1&amp;#125;;</span>obj1<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:&amp;#123;b:2&amp;#125;,c:1&amp;#125;;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:&amp;#123;b:1&amp;#125;,c:1&amp;#125;;</span></code></pre><p>在上面的代码中，我们新建了一个obj2对象,同时根据obj1对象的a属性是一个引用类型,我们给obj2.a的值也新建一个新对象(即在内存中新开辟了一块内存地址),然后把obj1.a.b属性的值数字1复制给obj2.a.b，因为数字1是基本类型的值，所以改变obj1.a.b的值后，obj2.a不会收到影响，因为他们的引用是完全2个独立的对象,这就完成了一个简单的深拷贝</p><h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h2><p>JSON.stringify()是目前前端开发过程中最常用的深拷贝方式，原理是把一个对象序列化成为一个JSON字符串，将对象的内容转换成字符串的形式再保存在磁盘上，再用JSON.parse()反序列化将JSON字符串变成一个新的对象</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>    a<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span>    b<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token keyword">var</span> str <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:1,b:[1,2,3]&amp;#125;</span>obj1<span class="token punctuation">.</span>a<span class="token operator">=</span><span class="token number">2</span>obj1<span class="token punctuation">.</span>b<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:2,b:[1,2,3,4]&amp;#125;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:1,b:[1,2,3]&amp;#125;</span></code></pre><p><strong>通过JSON.stringify实现深拷贝有几点要注意</strong></p><ol><li>拷贝的对象的值中如果有函数,undefined,symbol则经过JSON.stringify()序列化后的JSON字符串中这个键值对会消失</li><li>无法拷贝不可枚举的属性，无法拷贝对象的原型链</li><li>拷贝Date引用类型会变成字符串</li><li>拷贝RegExp引用类型会变成空对象</li><li>对象中含有NaN、Infinity和-Infinity，则序列化的结果会变成null</li><li>无法拷贝对象的循环应用(即obj[key] = obj)</li></ol><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">function</span> <span class="token function">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>func <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>        <span class="token function">alert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>     <span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>a<span class="token punctuation">:</span><span class="token number">1</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>und <span class="token operator">=</span> undefined<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>reg <span class="token operator">=</span> <span class="token regex">/123/</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token number">NaN</span> <span class="token operator">=</span> <span class="token number">NaN</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>infinity <span class="token operator">=</span> <span class="token number">Infinity</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>sym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span><span class="token string">'innumerable'</span><span class="token punctuation">,</span><span class="token entity" title="&#123;">&amp;#123;</span>    enumerable<span class="token punctuation">:</span><span class="token boolean">false</span><span class="token punctuation">,</span>    value<span class="token punctuation">:</span><span class="token string">'innumerable'</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj1'</span><span class="token punctuation">,</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> str <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj2'</span><span class="token punctuation">,</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>打印出来的结果如下</p><p><img src="https://imgkr.cn-bj.ufileos.com/5a4c6a84-751c-42d4-9898-8bbe1d49542d.jpg"></p><p>可以看到除了Object对象和数组其他基本都和原来的不一样，obj1的constructor是Obj(),而obj2的constructor指向了Object()，而对于循环引用则是直接报错了</p><p>虽说通过JSON.stringify()方法深拷贝对象也有很多无法实现的功能，但是对于日常的开发需求(对象和数组)，使用这种方法是最简单和快捷的</p><h2 id="使用第三方库实现对象的深拷贝"><a href="#使用第三方库实现对象的深拷贝" class="headerlink" title="使用第三方库实现对象的深拷贝"></a>使用第三方库实现对象的深拷贝</h2><p>1.<a href="https://github.com/lodash/lodash/blob/master/.internal/baseClone.js">lodash</a></p><p>2.<a href="https://www.jquery123.com/jQuery.extend/">jQuery</a></p><p>以上2个第三方的库都很好的封装的深拷贝的方法，有兴趣的同学可以去深入研究一下</p><h2 id="自己来实现一个深拷贝函数"><a href="#自己来实现一个深拷贝函数" class="headerlink" title="自己来实现一个深拷贝函数"></a>自己来实现一个深拷贝函数</h2><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>这里简单封装了一个deepClone的函数，for in遍历传入参数的值，如果值是引用类型则再次调用deepClone函数，并且传入第一次调用deepClone参数的值作为第二次调用deepClone的参数，如果不是引用类型就直接复制</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>    a<span class="token punctuation">:</span><span class="token entity" title="&#123;">&amp;#123;</span>        b<span class="token punctuation">:</span><span class="token number">1</span>    <span class="token entity" title="&#125;">&amp;#125;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>    <span class="token keyword">var</span> cloneObj <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在堆内存中新建一个对象</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span><span class="token entity" title="&#123;">&amp;#123;</span> <span class="token comment" spellcheck="true">//遍历参数的键</span>       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span><span class="token string">'object'</span><span class="token punctuation">)</span><span class="token entity" title="&#123;">&amp;#123;</span>           cloneObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//值是对象就再次调用函数</span>       <span class="token entity" title="&#125;">&amp;#125;</span><span class="token keyword">else</span><span class="token entity" title="&#123;">&amp;#123;</span>           cloneObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token comment" spellcheck="true">//基本类型直接复制值</span>       <span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token keyword">return</span> cloneObj <span class="token entity" title="&#125;">&amp;#125;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>obj1<span class="token punctuation">.</span>a<span class="token punctuation">.</span>b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//&amp;#123;a:&amp;#123;b:1&amp;#125;&amp;#125;</span></code></pre><p>但是还有很多问题</p><ul><li>首先这个deepClone函数并不能复制不可枚举的属性以及Symbol类型</li><li>这里只是针对Object引用类型的值做的循环迭代，而对于Array,Date,RegExp,Error,Function引用类型无法正确拷贝</li><li>对象循环引用成环了的情况</li></ul><h2 id="本人总结的深拷贝的方法"><a href="#本人总结的深拷贝的方法" class="headerlink" title="本人总结的深拷贝的方法"></a>本人总结的深拷贝的方法</h2><p>看过很多关于深拷贝的博客，本人总结出了一个能够深拷贝ECMAScript的<strong>原生引用类型</strong>的方法</p><pre class=" language-jsx"><code class="language-jsx"><span class="token keyword">const</span> isComplexDataType <span class="token operator">=</span> obj <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> obj <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>obj <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token keyword">const</span> deepClone <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>obj<span class="token punctuation">,</span> hash <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> Date<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//日期对象就返回一个新的日期对象</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>constructor <span class="token operator">===</span> RegExp<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//正则对象就返回一个新的正则对象</span>    <span class="token comment" spellcheck="true">//如果成环了,参数obj = obj.loop = 最初的obj 会在WeakMap中找到第一次放入的obj提前返回第一次放入WeakMap的cloneObj</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> hash<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>    <span class="token keyword">let</span> allDesc <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptors</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//遍历传入参数所有键的特性</span>    <span class="token keyword">let</span> cloneObj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">,</span> allDesc<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//继承原型链</span>    hash<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> cloneObj<span class="token punctuation">)</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>   <span class="token comment" spellcheck="true">//Reflect.ownKeys(obj)可以拷贝不可枚举属性和符号类型</span>        <span class="token comment" spellcheck="true">// 如果值是引用类型(非函数)则递归调用deepClone</span>        cloneObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span>            <span class="token punctuation">(</span><span class="token function">isComplexDataType</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token operator">?</span>                <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span> <span class="token punctuation">:</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token entity" title="&#125;">&amp;#125;</span>    <span class="token keyword">return</span> cloneObj<span class="token punctuation">;</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token entity" title="&#123;">&amp;#123;</span>    num<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>    str<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>    boolean<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    unf<span class="token punctuation">:</span> undefined<span class="token punctuation">,</span>    nul<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>    obj<span class="token punctuation">:</span> <span class="token entity" title="&#123;">&amp;#123;</span>        name<span class="token punctuation">:</span> <span class="token string">'我是一个对象'</span><span class="token punctuation">,</span>        id<span class="token punctuation">:</span> <span class="token number">1</span>    <span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">,</span>    arr<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>    func<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'我是一个函数'</span><span class="token punctuation">)</span>    <span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">,</span>    date<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    reg<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span><span class="token string">'/我是一个正则/ig'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token punctuation">[</span><span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">;</span>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'innumerable'</span><span class="token punctuation">,</span> <span class="token entity" title="&#123;">&amp;#123;</span>    enumerable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>    value<span class="token punctuation">:</span> <span class="token string">'不可枚举属性'</span><span class="token entity" title="&#125;">&amp;#125;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptors</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>obj<span class="token punctuation">.</span>loop <span class="token operator">=</span> obj<span class="token keyword">let</span> cloneObj <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj'</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'cloneObj'</span><span class="token punctuation">,</span> cloneObj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>cloneObj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> cloneObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> cloneObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token entity" title="&#123;">&amp;#123;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`$&amp;#123;key&amp;#125;相同吗？ `</span></span><span class="token punctuation">,</span> cloneObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token entity" title="&#125;">&amp;#125;</span><span class="token entity" title="&#125;">&amp;#125;</span></code></pre><p>这个函数有几个要点</p><ol><li>利用Reflect.ownKeys()方法,能够遍历对象的不可枚举属性和Symbol类型</li><li>当参数为Date,RegExp类型则直接生成一个新的实例</li><li>使用Object.getOwnPropertyDescriptors()获得对象的所有属性对应的特性,结合Object.create()创建一个新对象继承传入原对象的原型链</li><li>利用WeekMap()类型作为哈希表,WeekMap()因为是弱引用的可以有效的防止内存泄露,作为检测循环引用很有帮助,如果存在循环引用直接返回WeekMap()存储的值</li></ol><p>这里我用全等判断打印了2个对象的属性是否相等,通过打印的结果可以看到,虽然值是一样的,但是在内存中是两个完全独立的对象</p><p><img src="https://imgkr.cn-bj.ufileos.com/1901f66f-d6da-4df0-ae46-2b0091bed2c5.jpg"></p><p>上述的深拷贝函数中Null和Function类型引用的还是同一个对象,因为deepClone函数对于对象的值是函数或者null时直接返回,这里没有深拷贝函数,如果需要深拷贝一个函数,可以考虑使用Function构造函数或者eval?这里还有待研究</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><p>封装的deepClone方法虽然能实现对ECMAScript原生引用类型的拷贝,但是对于对象来说范围太广了,仍有很多无法准确拷贝的(比如DOM节点),但是在日常开发中一般并不需要拷贝很多特殊的引用类型，深拷贝对象使用JSON.stringify依然是最方便的方法之一（当然也需要了解JSON.stringify的缺点）</p></li><li><p>实现一个完整的深拷贝是非常复杂的,需要考虑到很多边界情况,这里我也只是对部分的原生的构造函数进行了深拷贝,对于特殊的引用类型有拷贝需求的话,建议还是借助第三方完整的库</p></li><li><p>对于深入研究深拷贝的原理有助于理解JavaScript引用类型的特点，以及遇到相关特殊的问题也能迎刃而解，对于提高JavaScript的基础还是很有帮助的~~~</p></li></ol><p><strong>感谢观看</strong></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.jianshu.com/p/b08bc61714c7">深入JS深拷贝对象</a></p><p>JavaScript高级程序设计第三版</p><p><a href="https://www.jianshu.com/p/c651aeabf582">转自【心_c2a2】</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写async await的最简实现（20行搞定）面试必考！</title>
      <link href="/blog/interview/20200730002/"/>
      <url>/blog/interview/20200730002/</url>
      
        <content type="html"><![CDATA[<p>如果让你手写 async 函数的实现，你是不是会觉得很复杂？这篇文章带你用 20 行搞定它的核心。经常有人说 async 函数是 generator 函数的语法糖，那么到底是怎么样一个糖呢？让我们来一层层的剥开它的糖衣。有的同学想说，既然用了 generator 函数何必还要实现 async 呢？这篇文章的目的就是带大家理解清楚 async 和 generator 之间到底是如何相互协作，管理异步的。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre><code>const getData = () =&gt;newPromise(resolve =&gt; setTimeout(() =&gt; resolve("data"), 1000)) asyncfunction test() &amp;#123; const data = await getData() console.log('data: ', data); const data2 = await getData() console.log('data2: ', data2); return'success'&amp;#125; // 这样的一个函数 应该再1秒后打印data 再过一秒打印data2 最后打印successtest().then(res =&gt;console.log(res))</code></pre><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于这个简单的案例来说，如果我们把它用 generator 函数表达，会是怎么样的呢？</p><pre><code>function* testG() &amp;#123; // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return'success'&amp;#125;</code></pre><p>我们知道，generator 函数是不会自动执行的，每一次调用它的 next 方法，会停留在下一个 yield 的位置。利用这个特性，我们只要编写一个自动执行的函数，就可以让这个 generator 函数完全实现 async 函数的功能。</p><pre><code>const getData = () =&gt;newPromise(resolve =&gt; setTimeout(() =&gt; resolve("data"), 1000)) var test = asyncToGenerator( function* testG() { // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return'success' }) test().then(res =&gt;console.log(res))</code></pre><p>那么大体上的思路已经确定了，<code>asyncToGenerator</code>接受一个<code>generator</code>函数，返回一个<code>promise</code>，关键就在于，里面用<code>yield</code>来划分的异步流程，应该如何自动执行。</p><h2 id="如果是手动执行"><a href="#如果是手动执行" class="headerlink" title="如果是手动执行"></a>如果是手动执行</h2><p>在编写这个函数之前，我们先模拟手动去调用这个<code>generator</code>函数去一步步的把流程走完，有助于后面的思考。</p><pre><code>function* testG() { // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return'success'}</code></pre><p>我们先调用<code>testG</code>生成一个迭代器</p><pre><code>// 返回了一个迭代器var gen = testG()</code></pre><p>然后开始执行第一次<code>next</code></p><pre><code>// 第一次调用next 停留在第一个yield的位置// 返回的promise里 包含了data需要的数据var dataPromise = gen.next()</code></pre><p>这里返回了一个<code>promise</code>，就是第一次<code>getData()</code>所返回的<code>promise</code>，注意</p><pre><code>const data = yield getData()</code></pre><p>这段代码要切割成左右两部分来看，第一次调用<code>next</code>，其实只是停留在了<code>yield getData()</code>这里，<code>data</code>的值并没有被确定。那么什么时候 data 的值会被确定呢？<strong>「下一次调用 next 的时候，传的参数会被作为上一个 yield 前面接受的值」</strong>也就是说，我们再次调用<code>gen.next('这个参数才会被赋给data变量')</code>的时候<code>data</code>的值才会被确定为<code>'这个参数才会被赋给data变量'</code></p><pre><code>gen.next('这个参数才会被赋给data变量') // 然后这里的data才有值const data = yield getData() // 然后打印出dataconsole.log('data: ', data); // 然后继续走到下一个yieldconst data2 = yield getData() </code></pre><p>然后往下执行，直到遇到下一个<code>yield</code>，继续这样的流程…这是 generator 函数设计的一个比较难理解的点，但是为了实现我们的目标，还是得去学习它~借助这个特性，如果我们这样去控制 yield 的流程，是不是就能实现异步串行了？</p><pre><code>function* testG() { // await被编译成了yield const data = yield getData() console.log('data: ', data); const data2 = yield getData() console.log('data2: ', data2); return'success'} var gen = testG() var dataPromise = gen.next() dataPromise.then((value1) =&gt; { // data1的value被拿到了 继续调用next并且传递给data var data2Promise = gen.next(value1) // console.log('data: ', data); // 此时就会打印出data data2Promise.then((value2) =&gt; { // data2的value拿到了 继续调用next并且传递value2 gen.next(value2) // console.log('data2: ', data2); // 此时就会打印出data2 })})</code></pre><p>这样的一个看着像<code>callback hell</code>的调用，就可以让我们的 generator 函数把异步安排的明明白白。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>有了这样的思路，实现这个高阶函数就变得很简单了。先整体看一下结构，有个印象，然后我们逐行注释讲解。</p><pre><code>function asyncToGenerator(generatorFunc) { returnfunction() { const gen = generatorFunc.apply(this, arguments) returnnewPromise((resolve, reject) =&gt; { function step(key, arg) { let generatorResult try { generatorResult = gen[key](arg) } catch (error) { return reject(error) } const { value, done } = generatorResult if (done) { return resolve(value) } else { returnPromise.resolve(value).then(val =&gt; step('next', val), err =&gt; step('throw', err)) } } step("next") }) }}</code></pre><p>不多不少，22 行。接下来逐行讲解。</p><pre><code>function asyncToGenerator(generatorFunc) { // 返回的是一个新的函数 returnfunction() { // 先调用generator函数 生成迭代器 // 对应 var gen = testG() const gen = generatorFunc.apply(this, arguments) // 返回一个promise 因为外部是用.then的方式 或者await的方式去使用这个函数的返回值的 // var test = asyncToGenerator(testG) // test().then(res =&gt; console.log(res)) returnnewPromise((resolve, reject) =&gt; { // 内部定义一个step函数 用来一步一步的跨过yield的阻碍 // key有next和throw两种取值，分别对应了gen的next和throw方法 // arg参数则是用来把promise resolve出来的值交给下一个yield function step(key, arg) { let generatorResult // 这个方法需要包裹在try catch中 // 如果报错了 就把promise给reject掉 外部通过.catch可以获取到错误 try { generatorResult = gen[key](arg) } catch (error) { return reject(error) } // gen.next() 得到的结果是一个 { value, done } 的结构 const { value, done } = generatorResult if (done) { // 如果已经完成了 就直接resolve这个promise // 这个done是在最后一次调用next后才会为true // 以本文的例子来说 此时的结果是 { done: true, value: 'success' } // 这个value也就是generator函数最后的返回值 return resolve(value) } else { // 除了最后结束的时候外，每次调用gen.next() // 其实是返回 { value: Promise, done: false } 的结构， // 这里要注意的是Promise.resolve可以接受一个promise为参数 // 并且这个promise参数被resolve的时候，这个then才会被调用 returnPromise.resolve( // 这个value对应的是yield后面的promise value ).then( // value这个promise被resove的时候，就会执行next // 并且只要done不是true的时候 就会递归的往下解开promise // 对应gen.next().value.then(value =&gt; { //    gen.next(value).value.then(value2 =&gt; { //       gen.next() // //      // 此时done为true了 整个promise被resolve了 //      // 最外部的test().then(res =&gt; console.log(res))的then就开始执行了 //    }) // }) function onResolve(val) { step("next", val) }, // 如果promise被reject了 就再次进入step函数 // 不同的是，这次的try catch中调用的是gen.throw(err) // 那么自然就被catch到 然后把promise给reject掉啦 function onReject(err) { step("throw", err) }, ) } } step("next") }) }}</code></pre><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p>这个 js 文件的代码可以直接放进浏览器里运行，欢迎调戏。<br>github.com/sl1673495/f…[2]</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文用最简单的方式实现了 asyncToGenerator 这个函数，这是 babel 编译 async 函数的核心，当然在 babel 中，generator 函数也被编译成了一个很原始的形式，本文我们直接以 generator 替代。这也是实现 promise 串行的一个很棒的模式，如果本篇文章对你有帮助，点个赞就好啦。</p><p><a href="https://mp.weixin.qq.com/s/eASescI3ZO0InccGQgQSjg">转自 图雀社区</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> interview </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
